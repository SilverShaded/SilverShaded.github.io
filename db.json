{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/dist/main.css","path":"dist/main.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/dist/main.js","path":"dist/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/404.jpg","path":"images/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/ayer.png","path":"images/ayer.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/beian.png","path":"images/beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/forkme.png","path":"images/forkme.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/sponsor.jpg","path":"images/sponsor.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/dz.js","path":"js/dz.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/jquery-3.6.0.min.js","path":"js/jquery-3.6.0.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"source/img/ascii/1.jpg","path":"img/ascii/1.jpg","modified":0,"renderable":0},{"_id":"source/img/ascii/2.jpg","path":"img/ascii/2.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1628238007344},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1628238016362},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1628238016362},{"_id":"node_modules/hexo-theme-ayer/.gitattributes","hash":"2e08e93c6f6790b02ab7f81a6191ed097b20cbf9","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/.stylintrc","hash":"eec4e824067be1a223745ca426aa367c8d482673","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/.travis.yml","hash":"870fcd9eb33bc4269d53bc84ddc6f8a69db7c611","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/LICENSE","hash":"d7308ddbd63bf372429401e188a906c52622f62e","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/README.md","hash":"3ed8085be8610af567e3b1fcaaccb9160fe16685","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/index.js","hash":"a144d64baec7130267f64272fb256a9be3aa7cd5","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/package.json","hash":"e6be53ad14bd6fbc25565c9db737da13bcc1c4fa","modified":1628857092006},{"_id":"node_modules/hexo-theme-ayer/move_config.js","hash":"9fde64d58714990bf93ba877bbc3b48f6b8fb7d9","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/rollup.config.js","hash":"3d98bd1db1dcf2e0878b6fcbbbf8ff9c3da6d357","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/de.yml","hash":"2b7fa47fbe06f6928a43ea3b345ab3aeaa2cee81","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/en.yml","hash":"1853255c243858cf9d26a589d7d26571e11ed5d1","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/es.yml","hash":"fc27661276313c1c539252517d664359cb286f8a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/default.yml","hash":"1853255c243858cf9d26a589d7d26571e11ed5d1","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/fr.yml","hash":"3dac4d53b9b2a1b10c0273ce7472b2e76576dc5a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/ja.yml","hash":"aea06ea7bcb439d2b84501924cdd092293ee891a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/ko.yml","hash":"00db39dd43875774088511b4d467dcb71f1ce8ac","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/nl.yml","hash":"d619955fd9659a209c58f696ee2160dfe8c6ac41","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/no.yml","hash":"fa4d2da9bb00ad0febc631afaf17f76aaa17e950","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/ru.yml","hash":"45edcadb57176d0b11a839055df1964da8ca08f9","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/pt.yml","hash":"fa0b3a4a01a0493f3ef402039e394a291a1251fd","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/vi.yml","hash":"20f25fe0e9017d530a771687fe9d21353e034fff","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/zh-CN.yml","hash":"edf1f8c164f3d166f94e213148e984fdfc3a7c85","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/languages/zh-TW.yml","hash":"750fba5314d340ddb00812fc17a608a084f04462","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/categories.ejs","hash":"b2deae0c31dd7fbf42a124db1b4c8c28d435c8e5","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/friends.ejs","hash":"2a4c0bfdf189ebae720f1325786a87c7cac51d37","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/layout.ejs","hash":"ad2222b1819f763cd981f72b8204a19cb0fa75ae","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/index.ejs","hash":"c40a98c0a6f55c27959e44c9e8e4f2619fc2ad3f","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/page.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/plain-page.ejs","hash":"d351ff4aadd020a1960cc00f17fdd91a17e0cc54","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/post.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/tags.ejs","hash":"e7c9f93c6f7041a7d2aa95e85cc131b22aa426b7","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/default_config.js","hash":"617c2614d8bd8ffda2f2f84ab54fb18866e39b33","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/404.html","hash":"727bb80b870df99b9d816f36613fc6eae4c61c98","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/main.js","hash":"fcb7c6c5ffcfd72ba9bd55b475af8a0e74484634","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/ads.ejs","hash":"2be035aeef82265c5b0cb6aec6f4135ad1e0aa75","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/after-footer.ejs","hash":"e6336c5d5061dd440100e1add829fa1bed19cd70","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/archive-post.ejs","hash":"6b3e77cdbf8271c2a22b839608cccaa651f84e93","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/archive.ejs","hash":"1da014dd52294e132bc91eb2f45f67264a41e059","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/article.ejs","hash":"ff1f8fd0dce22409038e72097a9582d1bbf4e6e0","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/ayer.ejs","hash":"061e5d25789c9a0c3df3172c0c53966053af89d1","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/broadcast.ejs","hash":"21fadeb390cff713fd432d0565bb901f8caff0c0","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/float-btns.ejs","hash":"b2fc5726168f012bc61845f33a46404ff4065947","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/footer.ejs","hash":"16c6877db510a28afff0334be8d2ffe2f76d7a3e","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/google-analytics.ejs","hash":"3a23d6ae48305c9f1b5c400da780288c2425254b","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/head.ejs","hash":"52fc68c6d75ac19373a839598f970d5d7a08cd80","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/lock.ejs","hash":"72ec0a339f98399c5141f4b3aca4cc8e8310f03a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/mathjax.ejs","hash":"bcc264b6d6b58b3b692139c4d8b1381da4820da8","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/katex.ejs","hash":"02cb9da065cd315a06d62d13872dc687c62e9a1f","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/modal.ejs","hash":"b9caece8b5fb47e250c67f6f80f101f08d04eba9","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/music.ejs","hash":"4a67b36cadf2661a5579a454b7d6e0be34e7a0d4","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/sidebar.ejs","hash":"b7efb7f2b300de23d12ef310d710d809d979f4fd","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/viewer.ejs","hash":"219f0a0ec2eb35e8ba27a849639a5f634273fb6f","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/events/index.js","hash":"2c84d99e881f5cd1ee8a406b595a4365f3aea41e","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/filters/index.js","hash":"e0c3b821ecd1cb614569282fb4f6e6f555545f8b","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/filters/meta_generator.js","hash":"46f6461a2bdc509837c36ede4d32c8b12e3d49b9","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/helpers/ayer-plus-vendors.js","hash":"611f3bcd8220312f92c11fa6a5dad02f011068d2","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/helpers/wordcount.js","hash":"2014b5c5053ad737887b61014a045cc1b08799cd","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/lib/core.js","hash":"00509e97554914e5b0a20e0843dc90bcf53461aa","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/css/clipboard.styl","hash":"145f335d6369744a75c2c39a50f63a88f720f85b","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/css/custom.styl","hash":"32990e811ea6fba84673b6d7175c88a3b890b109","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/dist/main.css","hash":"cedc06200d45eb7b000db1624b2585d7522137bc","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/dist/main.js","hash":"436093b4310b4656fb1e60ae946d04b85d6b1fa5","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/sponsor.jpg","hash":"5b5e4498177b369a7eca7ab2b1d0710b8690e21d","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/clickBoom1.js","hash":"c97ea1f120dba2c6804d0420186ef5d6f2419b7c","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/clickBoom2.js","hash":"2bc7267652ec49cea5dc3a8bd470c7d5ec57c721","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/lazyload.min.js","hash":"d9bc50752cd7e331dbd0a833386838397c9a079f","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/search.js","hash":"6d5c093d12e922ad204dab1723b786c35847bf1b","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_darkmode.styl","hash":"eda0bf55d64f2cdeb75f9489818c34635bc85c00","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_extend.styl","hash":"996ed7faa5ebf69af1f14f90f774dc7a53774537","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_mixins.styl","hash":"e4804d78ded3714495f8ac9cebdbd2871ed97549","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_normalize.styl","hash":"b90386215434cc76549c046e7f67392049492a6a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_remixicon.styl","hash":"78f4dd8c613df005d6ecf6a073d96d38bbbe531e","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_variables.styl","hash":"2fdb4425b6213fed28921f53179e825aee0500cf","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/style.styl","hash":"89dfb772754ee919cb157a6e28d61bbabfe46c8d","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/js/ayer.js","hash":"a3d349fb8af029e710d064c15373163680da2d39","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/js/share.js","hash":"7c105c427d472d84bee2ef3f0a61efa4ac6d564f","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/albums.ejs","hash":"f4cfbabca9f59a9e5aa457a6f2a9cf6f56cd22b3","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/author.ejs","hash":"0e6c2862d75e5b21faf28a5cc3310d3515340287","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/busuanzi.ejs","hash":"895293405b2b3b19fe97d79f4a25e16bea153ae8","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/category.ejs","hash":"89cb32e8d98bad81d3ef33377212e9b253699d3d","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/clipboard.ejs","hash":"c93d82de1635536a633b6254b604590ab4428594","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/gallery.ejs","hash":"6f78a49edc91f230b0a838c77630e9671d8d6089","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/gitalk.ejs","hash":"c81d54a9d818fa21ebcab03cfecc3528821ff9a5","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/justifiedGallery.ejs","hash":"a313df6a014a0f2ba6b869dabc56bacb8ff6324d","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/minivaline.ejs","hash":"c09ba80cfa41aaac17f0f7ff2586e73241adab20","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/nav.ejs","hash":"a73010cbbc463089a1376889850fb0890143c988","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/search.ejs","hash":"47c818c236b063d6ce0c41e0824f9f10a3521414","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/share.ejs","hash":"9a978d55358878c97186ed010e536e1b314adb35","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/title.ejs","hash":"e55c57b8cb8c8acf0ed998ea31c2fbc1d6256027","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/tocbot.ejs","hash":"17ac504f2a6d561765046a0ba19dcce504104517","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/topping.ejs","hash":"de2c50fb5b7a816287c6d048a2a22ae9c29abcdd","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/twikoo.ejs","hash":"7f064611a2297dda84e6b329252e838666ac7c93","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/valine.ejs","hash":"b71f2af08c1916b3c5ef3a553a1df16f1787af24","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/layout/_partial/post/word.ejs","hash":"5b785368a0a6f3b5538aa1b9e7574daa8dfb0df6","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/events/lib/hello.js","hash":"058c73fa3900d143affb9cc7ea0b2105d3925915","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/scripts/events/lib/merge-configs.js","hash":"734aac9a53cf168ee51482b02b75954a2a3df150","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/ads.styl","hash":"e3e533ac5b9b6c5ef7d3829c890aff42dc29cfc1","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/apple.styl","hash":"333f9e59dc6625c4dee126a1c1a9c25ce9292655","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/albums.styl","hash":"5802253789028a4d9dac474168fc7132045e72ff","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/archive.styl","hash":"9dbb04cf0ae07b50acd6f343e673df215a3c868e","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/article.styl","hash":"659a35544b321a101f7cf114f0c9fdf2cc125625","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/articles.styl","hash":"ddbe833939180afdc832659c5cdad08f77ef4f46","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/ayer.styl","hash":"38187e5c88eaf1ea099f2ded56f1f60194c95ec4","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/categories.styl","hash":"cb3b1667c83182d6309e6d066f53f2771723729e","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/float.styl","hash":"b1abfdfd05e74745484f7e6d043ef2842b3f6b41","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/footer.styl","hash":"ae22e9d1525f267be368359ed0096f26791b809e","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/friends.styl","hash":"10332c63736e4ce31353b7605012caf744a8286a","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/gallery.styl","hash":"f5eae1b0030cfd97f1646844c9d3f692dbb38946","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/gitalk.styl","hash":"0678e8b330daea56fa30d14e97de73289a7d6f22","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/highlight.styl","hash":"1210f704aae34ef653e3a458cccb700b05353ea1","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/justifiedGallery.styl","hash":"9828c78fb59c3ea3de7cce2569313d12c4b1a6ff","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/layout.styl","hash":"d4613f176636cae6a4af6124863a176c32ea6471","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/lists.styl","hash":"dc45f8b1a5942d4d979fb0859bc47a86f73fe0a9","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/mobile.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/navbar.styl","hash":"266df43ec4041226f1801719e873265b75fe6515","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/pace.styl","hash":"bbda18c692fc66ae99e45347ff52c14e44a08e3b","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/search.styl","hash":"3f2c7bd1371f6f25aec7c581dbae7b52f95ec4c6","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/reward.styl","hash":"924114f723a22dbb8970d023bc2e033141b3438d","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/share.styl","hash":"4a6e6ac9156553dd5cee1eeee8fdc6f1f8a5d117","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/sidebar.styl","hash":"cdc7bea47a768b18991decde0d38c554399621ee","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/tag.styl","hash":"6072aa6bd16e0a1e75f0258d7b20587cab56fff8","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/tocbot.styl","hash":"130e29937aa750e63e8cf216934dbdd4ea95969f","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source-src/css/_partial/totop.styl","hash":"b6010788be1d99a345abcf0cf9cdf0a564b90d3c","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":499162500000},{"_id":"node_modules/hexo-theme-ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":499162500000},{"_id":"public/2021/08/06/hello-world/index.html","hash":"c7fdd6793f13994a739e260c282fb2e56b6d99f8","modified":1628240803313},{"_id":"public/archives/index.html","hash":"7e386fdd6b0cbc36864b0b4bb2268c0e98a04b2a","modified":1635332807023},{"_id":"public/archives/2021/index.html","hash":"3c753d17b2882686318bb3fd67fab78618a7c3be","modified":1635332807023},{"_id":"public/archives/2021/08/index.html","hash":"5aba70b2e0c011c254d8628ee71ac6328897176c","modified":1630552004881},{"_id":"public/index.html","hash":"3d01e99c258a34662ff16c4ad7c5bc7f108f4f1c","modified":1635423086903},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1628240803313},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1628240803313},{"_id":"public/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1628240803313},{"_id":"public/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1628240803313},{"_id":"public/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1628240803313},{"_id":"public/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1628240803313},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1628240803313},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1628240803313},{"_id":"public/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1628240803313},{"_id":"public/images/sponsor.jpg","hash":"5b5e4498177b369a7eca7ab2b1d0710b8690e21d","modified":1628240803313},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1628240803313},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1628240803313},{"_id":"public/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1628240803313},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1628240803313},{"_id":"public/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1628240803313},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1628240803313},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1628240803313},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1628240803313},{"_id":"public/css/style.css","hash":"b3156fdcfe6586e60fa1d1a3c6cdd92fccc7873f","modified":1628240803313},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1628240803313},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1628240803313},{"_id":"public/404.html","hash":"86cb9b15558d623c1e6038e77e781e544524684e","modified":1628240803313},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1628240803313},{"_id":"public/css/custom.css","hash":"58950a4f4cd82465f85428ec17b3bc05f8153b56","modified":1628240803313},{"_id":"public/dist/main.js","hash":"436093b4310b4656fb1e60ae946d04b85d6b1fa5","modified":1628240803313},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1628240803313},{"_id":"public/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1628240803313},{"_id":"public/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1628240803313},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1628240803313},{"_id":"public/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1628240803313},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1628240803313},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1628240803313},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1628240803313},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1628240803313},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1628240803313},{"_id":"public/dist/main.css","hash":"cedc06200d45eb7b000db1624b2585d7522137bc","modified":1628240803313},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1628240803313},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1628240803313},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1628240803313},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1628240803313},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1628240803313},{"_id":"public/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1628240803313},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1628240803313},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1628240803313},{"_id":"source/_posts/blog的诞生.md","hash":"0958068097505b1c1a20fe65c5b63a8d060d6c96","modified":1628242379176},{"_id":"public/2021/08/06/blog的诞生/index.html","hash":"6428913648257e2cf9d2f00cd263d152ebb3b247","modified":1628249317005},{"_id":"source/categories/index.md","hash":"173bb6642e4d63ca121e9cdf64b58f87f1852ff9","modified":1628246544927},{"_id":"source/tags/index.md","hash":"e5c1dd9c1a481a3d9165056296349fb46fdc125c","modified":1628246964398},{"_id":"source/_posts/init-algorithm.md","hash":"f09d2767338021f7ac2efd81699804dad7232084","modified":1628249994597},{"_id":"source/_posts/init-java.md","hash":"cb7e35b41467efedcdc575ed32191996f3c798f6","modified":1628250041685},{"_id":"source/_posts/init-network.md","hash":"b824a1cb400e49880cd8f47090e20782de0ec787","modified":1628250101621},{"_id":"source/_posts/init-pet.md","hash":"80f8bbe7e04991c6c801d4e65155174e24a61c16","modified":1628250086154},{"_id":"source/_posts/init-travel.md","hash":"4d8580a10f4b18bfa397cf0c3cfa7a1cba03acdb","modified":1628250099771},{"_id":"source/2021/about/index.md","hash":"a48f2ce2d1189b1b7c7c7ca8407fd967273b9bcb","modified":1628248389501},{"_id":"public/categories/index.html","hash":"1dbfe9e1b5371793da5786fc64038f48d5097531","modified":1635332807023},{"_id":"public/tags/index.html","hash":"6e2338fda581f350f6950a42aebad96a1a2ba79b","modified":1634107664729},{"_id":"public/2021/about/index.html","hash":"6cc06148ac93779031b399244201805760550200","modified":1628248407478},{"_id":"public/2021/08/06/init-pet/index.html","hash":"3ad8667ae936d512785e6d27ea62f5bddf511ffe","modified":1628837789493},{"_id":"public/2021/08/06/init-travel/index.html","hash":"47bedd23567d10091d5276a55b8e55c247c14649","modified":1628481027059},{"_id":"public/2021/08/06/init-java/index.html","hash":"258ba748ef86222b9d751546b17d270a4073ea85","modified":1628250152474},{"_id":"public/2021/08/06/init-algorithm/index.html","hash":"78a77d0ad315d44ce67e3122d58551e9c8f3bb30","modified":1628481027059},{"_id":"public/2021/08/06/init-network/index.html","hash":"5055361bffe9ed87864ab5192e7b3656e0c6afab","modified":1628250152474},{"_id":"public/tags/algorithm/index.html","hash":"b4f785fba6631062d64e67304dc96f8d74d8166d","modified":1628249999748},{"_id":"public/tags/java/index.html","hash":"b90aadce4a0705da25a58e40eb7cdaaa5c9c256e","modified":1635332807023},{"_id":"public/tags/network/index.html","hash":"7e3c12c495d07e62939a3e9f37cdbcde03d63086","modified":1628250152474},{"_id":"public/tags/pet/index.html","hash":"110294e4642518a2a6415720355cfe6cefa2677d","modified":1628250152474},{"_id":"public/tags/travel/index.html","hash":"f0c958bebef56e072bae01353046a249e4618038","modified":1628250152474},{"_id":"source/categories/blog的诞生.md","hash":"0958068097505b1c1a20fe65c5b63a8d060d6c96","modified":1628242379176},{"_id":"source/categories/init-algorithm.md","hash":"a9940aa5f3e766bf9ca60a667265e82ca45d1b1c","modified":1628248483684},{"_id":"source/categories/init-java.md","hash":"69e7e140ed4e588f00af7ad0423048b20a89bc69","modified":1628248494133},{"_id":"source/categories/init-network.md","hash":"18b8b3eda23b258eb92cd944ad6b362035a4fd1d","modified":1628249006430},{"_id":"source/categories/init-pet.md","hash":"4e4eceb8782580c6e08ec2077ceb4481bebc52e2","modified":1628249015548},{"_id":"source/categories/init-travel.md","hash":"56e8c5833e92e6132c977333bfd9d7794c6df35d","modified":1628249027285},{"_id":"public/categories/init-algorithm.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628249245524},{"_id":"public/categories/init-java.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628249245524},{"_id":"public/categories/init-network.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628249245524},{"_id":"public/categories/init-pet.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628249245524},{"_id":"public/categories/init-travel.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628249245524},{"_id":"public/categories/blog的诞生.html","hash":"af208a1d5aee3ed986853dc3b7c0259609389890","modified":1628249245524},{"_id":"public/categories/algorithm/index.html","hash":"19516bc21ea083536a94f4c85db677286484b11d","modified":1628249999748},{"_id":"public/categories/java/index.html","hash":"b24a88a81c3e69d5d56085c4762cb7830535c990","modified":1635332807023},{"_id":"public/categories/network/index.html","hash":"7a5d91118de4bbb5a3b8bd0c5e7caf105174b451","modified":1628250152474},{"_id":"public/categories/pet/index.html","hash":"aa7f6efb4717eb88d3b104c2cd117c49bf9a4961","modified":1628250152474},{"_id":"public/categories/travel/index.html","hash":"54881988b1d815417decc1b365772587f5e20955","modified":1628250152474},{"_id":"source/_posts/java-basic-data-type.md","hash":"c28305e56e719c518f3742d36e9beaaef5f9c36e","modified":1628578089491},{"_id":"public/2021/08/09/java-basic-data-type/index.html","hash":"364b9f27ef0536322a41cc23a7298520788ceb05","modified":1628578096521},{"_id":"source/_posts/array-type.md","hash":"00bfed60721ce982dc41f1ca55d0ab0bb08752c0","modified":1628493422056},{"_id":"public/2021/08/09/array-type/index.html","hash":"098205270b537d7d113e88a848696921820d9f37","modified":1628493428982},{"_id":"public/tags/array/index.html","hash":"7d704472adcac7c4094af9f24629a33da99d9dd0","modified":1628837789493},{"_id":"source/_posts/array-storage.md","hash":"01c6f48603ad02e12dd0000554191eb8424bae72","modified":1628578061836},{"_id":"public/2021/08/09/array-storage/index.html","hash":"d4eab6fa26418e28268e2a17cfb9ad5533ffac2d","modified":1628578096521},{"_id":"source/_posts/数组存储.md","hash":"7498071b6c5338b42b799441f647f85197d415c0","modified":1628839722846},{"_id":"source/_posts/java基本数据类型.md","hash":"571ca03c9d355e3c5bdfd4a8fc45160710e894a4","modified":1628839533870},{"_id":"public/2021/08/09/数组存储/index.html","hash":"ff1e3ffca082d018b03df851af46480b78567099","modified":1628848827594},{"_id":"public/2021/08/09/java基本数据类型/index.html","hash":"62817b4f0ae9ce91e0276c702edd63b62753b672","modified":1628839543015},{"_id":"source/_posts/位运算.md","hash":"fc4c58aa03a514c61715213a20efaff05b6814b4","modified":1629711657192},{"_id":"source/_posts/十六进制.md","hash":"99c082cef728f8672ba3772e360f33f4395389e7","modified":1629711666937},{"_id":"source/_posts/负数的二进制表示.md","hash":"7060f46c783c0af8c28fb5d84e728fcea1289f0f","modified":1629711675708},{"_id":"public/2021/08/13/位运算/index.html","hash":"5f3c11554577566712522f4e3bf7240c56ca3327","modified":1629711689991},{"_id":"public/2021/08/13/负数的二进制表示/index.html","hash":"0a252b022f3d017decb017ca06df7a293edfe078","modified":1629711689991},{"_id":"public/2021/08/13/十六进制/index.html","hash":"da38369da84f5703f2636ab2f1779b712569179a","modified":1629711689991},{"_id":"source/_posts/乱码.md","hash":"ce13b8ab0cf32be33c50521353c7a69c2449c33e","modified":1629711652315},{"_id":"public/2021/08/17/乱码/index.html","hash":"feaf5518aeb350efa423126ae29f868a8af5f896","modified":1629711689991},{"_id":"public/archives/page/2/index.html","hash":"04ce2a556009b1815368e65f7caf1ff68a09334c","modified":1635332807023},{"_id":"public/archives/2021/page/2/index.html","hash":"58bd95e379acf61f0e45d66d5c86a8f351b89ff6","modified":1635332807023},{"_id":"public/page/2/index.html","hash":"ef5c4a7b4f113f100da5ef482e3be80085646b95","modified":1635332807023},{"_id":"public/archives/2021/08/page/2/index.html","hash":"bfa0eaca32e195e22f8b3cbd1fff589507354721","modified":1630552004881},{"_id":"source/img/ascii/1.jpg","hash":"b3efc5a3fd89c377bdfa180b6d63fb935d824dc4","modified":1629267948849},{"_id":"source/img/ascii/2.jpg","hash":"b46431909aa7e497c7ae4def6ac79ff566c890f2","modified":1629267979526},{"_id":"public/img/ascii/2.jpg","hash":"b46431909aa7e497c7ae4def6ac79ff566c890f2","modified":1629268906709},{"_id":"public/img/ascii/1.jpg","hash":"b3efc5a3fd89c377bdfa180b6d63fb935d824dc4","modified":1629268906709},{"_id":"source/_posts/char的含义.md","hash":"625af6608785a0b7e74f36bd25cd849717de71a7","modified":1629711684168},{"_id":"public/2021/08/18/char的含义/index.html","hash":"db47cfa73dd65da8027f1917922f15fcf412273d","modified":1629711689991},{"_id":"source/_posts/四种循环.md","hash":"22f1d65593db233e89ba050969539d722e8fcb1f","modified":1629711669872},{"_id":"public/2021/08/20/四种循环/index.html","hash":"1ae23199f30840bf88e9f52f85027673b926f8f4","modified":1629711689991},{"_id":"source/_posts/函数定义.md","hash":"0737579536d407ca8d94a80e758846007a12aa1c","modified":1629711660541},{"_id":"public/tags/function/index.html","hash":"3f7448d12c94873807a379a78340d457b98fbbaf","modified":1629713473329},{"_id":"public/2021/08/23/函数定义/index.html","hash":"ac444cb46ac53fa3a59704216c784631ea6342a9","modified":1629711689991},{"_id":"source/_posts/函数重载.md","hash":"eef89e683bf32e2c1dcfcc4eec98f9e09290fecf","modified":1629711917234},{"_id":"public/2021/08/23/函数重载/index.html","hash":"104afa55b68878552651a053ed6a0f8051393ba0","modified":1629713473329},{"_id":"source/_posts/函数递归.md","hash":"b147a7f3385c3867b73a6499a784f4bc9d621bfc","modified":1629714340956},{"_id":"public/categories/java/page/2/index.html","hash":"626fbd7eb9a10b348f2f6cb7e1475336ce55fd7d","modified":1635332807023},{"_id":"public/tags/java/page/2/index.html","hash":"261b847b5a2be2025410b0f9bdc3df4211089afa","modified":1635332807023},{"_id":"public/2021/08/23/函数递归/index.html","hash":"057746d26e46eb663f3386f129706591a2ce8bb1","modified":1629715990562},{"_id":"source/_posts/data-structure.md","hash":"ef6a200f2173d06d2318841e679c7c6214eca9f5","modified":1629715936399},{"_id":"source/_posts/栈.md","hash":"9729f0f81b973ec8595a1878d11dde9ff36a5e6c","modified":1629970541816},{"_id":"public/2021/08/23/data-structure/index.html","hash":"96170654a6b427743c106738d752d047c15b8f45","modified":1629715990562},{"_id":"public/categories/data-structure/index.html","hash":"3535274d1272b7378fd45c315305b7b6dc341984","modified":1629715990562},{"_id":"public/tags/stack/index.html","hash":"9a6c51c16d880072e677528eea6d846fdf9b0ca8","modified":1629720708550},{"_id":"public/2021/08/23/栈/index.html","hash":"b1ea5d98fba26d17a181d331be1d4f06033208c4","modified":1630060351954},{"_id":"public/tags/data-structure/index.html","hash":"4545e75c9732953548b45dc57aaec9a37c4331f9","modified":1629720708550},{"_id":"source/_posts/类的定义.md","hash":"66384793b4d9eda90e6ef7c7822f76e742e6b85e","modified":1630381417894},{"_id":"public/tags/class/index.html","hash":"25f95694976b1bdb86e9384e173635e83b70703b","modified":1632883710216},{"_id":"public/2021/08/27/类的定义/index.html","hash":"629c9b998b9d29c06135f900757c48c3e3e574c3","modified":1630391555128},{"_id":"source/_posts/类的组合.md","hash":"c5d9ac6ea671b7e7d665d6da4f24d79dd4e1c3d6","modified":1631690642996},{"_id":"public/2021/08/31/类的组合/index.html","hash":"a2d923086a8bd4a277a66d6f7e1eefa039fd14c7","modified":1631690650723},{"_id":"source/_posts/类的继承.md","hash":"f12a0473df613ac5b73f4a18b57d8c3d9c731b85","modified":1630571445625},{"_id":"public/2021/08/31/类的继承/index.html","hash":"5a240a7ea1cf841f056bf18213e2921f078bc9aa","modified":1630576470184},{"_id":"source/_posts/从图形处理类看继承和多态.md","hash":"4026ab52ea0e6a0b36b6d24a484fb775061ae9bf","modified":1630571459868},{"_id":"public/archives/page/3/index.html","hash":"850892168df1742490e81a67e465cdd85ddb2b46","modified":1635332807023},{"_id":"public/archives/2021/page/3/index.html","hash":"0bff36f8a267b344ddefb87b3f0d5c44df7fcd39","modified":1635332807023},{"_id":"public/archives/2021/08/page/3/index.html","hash":"19d282c5d59c791d154356610f4982c938198cec","modified":1630552004881},{"_id":"public/page/3/index.html","hash":"b6f9c618cb9af6436417b13c121e481e3441c763","modified":1635332807023},{"_id":"public/2021/08/31/从图形处理类看继承和多态/index.html","hash":"805d3c787c41122881baa7a9cebd6ec5f6cafe4d","modified":1631527682313},{"_id":"source/_posts/继承的细节--构造方法.md","hash":"bc17e2ded99e16bc48fbb93fcf643a3909b6c378","modified":1630577578418},{"_id":"public/archives/2021/09/index.html","hash":"01f128c72643844266bc293d4e00df0a52e0607f","modified":1634029742719},{"_id":"public/2021/09/02/继承的细节--构造方法/index.html","hash":"bab805a12ac602d529563c5da8514783c36e1946","modified":1630585115958},{"_id":"public/tags/extends/index.html","hash":"66f1e3bf63bd1275d265423788c3d303887c192e","modified":1632730915228},{"_id":"source/_posts/继承的细节-重名与静态绑定.md","hash":"47a0dc7ab41e71d7443543408603fc6fdbaa23cc","modified":1632656784838},{"_id":"public/2021/09/02/继承的细节-重名与静态绑定/index.html","hash":"27f1209ba0216fc4e254c9ee122dc1f91f829d36","modified":1632656795921},{"_id":"source/_posts/继承的细节-重载和重写.md","hash":"0f115acf8a7c9eb04f617a132a8425116d3e4e42","modified":1630641378073},{"_id":"public/2021/09/02/继承的细节-重载和重写/index.html","hash":"7ca64e5db6f09506d93dc19589fcf942de261405","modified":1630661291606},{"_id":"source/_posts/继承的细节-父子类型转换.md","hash":"1dc0b3ae8e484956fa563ead646b638c5f9daca0","modified":1630665467996},{"_id":"public/2021/09/03/继承的细节-父子类型转换/index.html","hash":"931b9ed97f0aeeaabf23c5bdce02ad9e4ab2546b","modified":1631183906181},{"_id":"source/_posts/继承的细节-protected.md","hash":"52128ea7bf99652c259d82facb5111c9bc841f79","modified":1631694898842},{"_id":"public/2021/09/03/继承的细节-protected/index.html","hash":"1aaf8d63fdd20974ceb1d20355b315a9be0e44a4","modified":1631694910657},{"_id":"source/_posts/继承的细节-构造方法.md","hash":"bc17e2ded99e16bc48fbb93fcf643a3909b6c378","modified":1630577578418},{"_id":"public/2021/09/02/继承的细节-构造方法/index.html","hash":"2f2378f58fa01a706cf88400f0520763acf6c633","modified":1631527682313},{"_id":"source/_posts/继承的细节-可见性重写.md","hash":"b7dbfdc1d4d9bf87b55a16d6eb091d05b33b3b17","modified":1631529847695},{"_id":"public/categories/java/page/3/index.html","hash":"bc75123f832102e12159e3554dd669244053bff6","modified":1635332807023},{"_id":"public/tags/java/page/3/index.html","hash":"534b3f23c7b37e9f771d0f9245dca1d3ee39e547","modified":1635332807023},{"_id":"public/2021/09/13/继承的细节-可见性重写/index.html","hash":"625a37888034a24bf006b1251125d835a3b3ece8","modified":1631530862197},{"_id":"source/_posts/继承的细节-防止继承.md","hash":"763cb2e8973af48453af8662ad97eb34740d77ac","modified":1631612362768},{"_id":"public/2021/09/13/继承的细节-防止继承/index.html","hash":"0d6b904e169356e0df2e95ed6569983e38f2ac20","modified":1632653937522},{"_id":"public/tags/class/page/2/index.html","hash":"8fb6a892d94292fac2f3da3f128f6077f7c32d86","modified":1632883710216},{"_id":"source/_posts/继承实现的基本原理.md","hash":"190b87395e1985483ba8aba1a1fc09f803ac0d41","modified":1632653899354},{"_id":"public/2021/09/15/继承实现的基本原理/index.html","hash":"7a2fedd4fe4d807a45588b35e59b0db80026acd4","modified":1632653937522},{"_id":"source/_posts/虚方法表.md","hash":"a6f03f4dc17d1f235a77f0c2a8c7a48193291412","modified":1632656789596},{"_id":"public/2021/09/17/虚方法表/index.html","hash":"04b36980d29298b3ac4cd5d598fea3b402be6e9c","modified":1632730915228},{"_id":"public/tags/extends/page/2/index.html","hash":"ca8b10294d97cc36a8d74f96bb8914b51a55653d","modified":1632730915228},{"_id":"source/_posts/破坏封装的继承是一把双刃剑.md","hash":"655d8002e2d0db277ef556b9ca87f8985abe5531","modified":1632730908751},{"_id":"public/page/4/index.html","hash":"cecb6fe0180a7446ba46b582305d35095238c013","modified":1635332807023},{"_id":"public/archives/page/4/index.html","hash":"2cdeb85f4c732ebb7a686f00031c696a3babeeb1","modified":1635332807023},{"_id":"public/archives/2021/page/4/index.html","hash":"9885522d65c80cf6f2536331e43b485b37ee535b","modified":1635332807023},{"_id":"public/2021/09/27/破坏封装的继承是一把双刃剑/index.html","hash":"0f3176485a227110bd4aa27d05638b76b5f4373e","modified":1632733005712},{"_id":"source/_posts/接口的本质.md","hash":"586baaad13431a367a28d472b2c9c8a6c3cfabee","modified":1632738934728},{"_id":"public/archives/2021/09/page/2/index.html","hash":"47e700724ca7647d4a02639ade2a5f616e3f1bb4","modified":1632997240236},{"_id":"public/tags/interface/index.html","hash":"60f23574a4236e65567481db05354637e3c95c65","modified":1632820999648},{"_id":"public/2021/09/27/接口的本质/index.html","hash":"d22f3340befe8ebdaa17bba24b85dbb2b1f3b0d3","modified":1632798337204},{"_id":"source/_posts/针对接口而非具体类型的编程.md","hash":"e59254c4958e3e894d440925b6a5f0d8dc2644fa","modified":1632798330225},{"_id":"public/2021/09/27/针对接口而非具体类型的编程/index.html","hash":"71fd3b54204fac1736fbe6f2b71785851f8b1385","modified":1632810078561},{"_id":"source/_posts/接口的细节.md","hash":"876ebd06c58fe53edec37386ce2ccba1c460caae","modified":1632810069417},{"_id":"public/2021/09/28/接口的细节/index.html","hash":"630b19e5173a98fcfaee3d8f64b15943273db517","modified":1632813832353},{"_id":"source/_posts/使用接口替代继承.md","hash":"b6c65acd1866e00c5cdd078ff0b04b0270b3d076","modified":1632813828150},{"_id":"public/2021/09/28/使用接口替代继承/index.html","hash":"84c922869d788d3af4910f15af20cf5eee0e2a17","modified":1632817750173},{"_id":"source/_posts/抽象类.md","hash":"d533d108ebd6f475f4b400a9cd43290fb035d6fb","modified":1632817703316},{"_id":"public/tags/abstract/index.html","hash":"0aaf9e7f87cd66efda66a4c1a1b7e623be185ab2","modified":1632820999648},{"_id":"public/2021/09/28/抽象类/index.html","hash":"65826f0db1f49f84d3d5991afdf4c8dd779be2bc","modified":1632817709005},{"_id":"source/_posts/抽象方法和抽象类.md","hash":"d533d108ebd6f475f4b400a9cd43290fb035d6fb","modified":1632817703316},{"_id":"public/2021/09/28/抽象方法和抽象类/index.html","hash":"8ca0e027f0a1f7063fe6f35b3c32bafe312ddf4d","modified":1632820999648},{"_id":"source/_posts/抽象类和接口.md","hash":"1ccfc3239546a25191336e10941ef79825d44d92","modified":1632820992522},{"_id":"public/categories/java/page/4/index.html","hash":"0a1fa5759c91fa94aa5f982d1718af6f7c6c549c","modified":1635332807023},{"_id":"public/tags/java/page/4/index.html","hash":"af8684788878ab39490927472b84180a7c15c5b4","modified":1635332807023},{"_id":"public/2021/09/28/抽象类和接口/index.html","hash":"e3b718bb03392754ffd36901576d504d71277c24","modified":1632883710216},{"_id":"source/_posts/内部类的定义.md","hash":"4940eeceb1415f4b49455afa1b000f20809b5696","modified":1632883703016},{"_id":"public/tags/class/page/3/index.html","hash":"ceb76dd266bcf691db552e2a9adf22eefbc32854","modified":1632883710216},{"_id":"public/2021/09/28/内部类的定义/index.html","hash":"1f62e9b0b96c7b70b0564437dbfa06471132ba3e","modified":1632993310566},{"_id":"source/_posts/程序打包.md","hash":"ec2680c99e501fc654209f989cc634808217b53d","modified":1632993305587},{"_id":"public/tags/package/index.html","hash":"4cc304c08bdd03608e114681342a9d252a1af5a1","modified":1632993310566},{"_id":"public/2021/09/30/程序打包/index.html","hash":"2e0514be67a510a9b00aba0b3e88258eb4d9edda","modified":1632994700200},{"_id":"source/_posts/程序的编译与连接.md","hash":"72072f0f86422157f1ecbef87c1cc55ffeb67eb3","modified":1632994692854},{"_id":"public/2021/09/30/程序的编译与连接/index.html","hash":"7d32a1256a58219c01b86f2524a95a7e6a4c96c5","modified":1634029742719},{"_id":"source/_posts/枚举.md","hash":"32d9b80b3deafbdc60b88597d5b5ec4e1fa3201d","modified":1633953357079},{"_id":"public/archives/page/5/index.html","hash":"31b2ea629d9b1523853a596caf00644dd62addec","modified":1635332807023},{"_id":"public/archives/2021/page/5/index.html","hash":"5c5679748eaca0059ea5b132063250310380efc9","modified":1635332807023},{"_id":"public/page/5/index.html","hash":"427f2cf158f09331f6c23b6d894ee5458f8322e4","modified":1635332807023},{"_id":"public/tags/enum/index.html","hash":"22e4dc6e6504cd40083bacbaf35bc64bf46b13a2","modified":1634038752404},{"_id":"public/2021/09/30/枚举/index.html","hash":"c9764141052e4e53f259cd2325454bce7c20d9c5","modified":1633954198743},{"_id":"source/_posts/枚举的基本用法.md","hash":"57199560a3bbbf8f62a23bb12f38c235a02cde48","modified":1634029734354},{"_id":"public/2021/09/30/枚举的基本用法/index.html","hash":"fc7ac18b7b3463d79c6fccd184f89c1bf39a37cf","modified":1634030762531},{"_id":"source/_posts/枚举的好处.md","hash":"d7321dfcfea5906f42d1a86742dd766e09cb1a8e","modified":1634030757058},{"_id":"public/archives/2021/10/index.html","hash":"cf921d7c03c10b8a5f90b7f8a6943cdc3ccde251","modified":1635332807023},{"_id":"public/2021/10/12/枚举的好处/index.html","hash":"dc2a9c22780a700f151f1bd26a6ce0fca30a35dd","modified":1634031631157},{"_id":"source/_posts/枚举的基本实现原理.md","hash":"c121d2d01e4e3740976a5f777bdf776dff6c5b70","modified":1634037913374},{"_id":"public/2021/10/12/枚举的基本实现原理/index.html","hash":"b8042e514086a3b2330300354746082f8bbd3059","modified":1634038752404},{"_id":"source/_posts/枚举的典型场景.md","hash":"017f26683b1256b2849dea827f55147d5412b07b","modified":1634106076422},{"_id":"public/2021/10/12/枚举的典型场景/index.html","hash":"6a0734bf075ac4fd5367179d59ba240d456c6edf","modified":1634107664729},{"_id":"source/_posts/NullPointerException（空指针异常）.md","hash":"c0ace82c8fbbac6c8ff3cb63988c0ffbdc89ac78","modified":1634107653011},{"_id":"public/tags/exception/index.html","hash":"cb6d8f50c6f2ebf1620ec19cdeedafd05c14bb0e","modified":1635332807023},{"_id":"public/2021/10/13/NullPointerException（空指针异常）/index.html","hash":"e2c1a0f501e1b936f67cc737d1e65cc0a717ba34","modified":1634116170778},{"_id":"source/_posts/NumberFormatException（数字格式异常）.md","hash":"18cbe0095bf8d4b3b9dee55d1de09e9c505c8721","modified":1634116166491},{"_id":"public/2021/10/13/NumberFormatException（数字格式异常）/index.html","hash":"9e1f54cc2bfe62ff097d5c01f88e6a0a05f21df5","modified":1634124684512},{"_id":"source/_posts/异常类.md","hash":"77930b37cf0716648632b5046117945a02a7b991","modified":1634641706482},{"_id":"public/categories/java/page/5/index.html","hash":"422e16d26a8562963063e45dc53ec5abd53ea303","modified":1635332807023},{"_id":"public/tags/java/page/5/index.html","hash":"1398a44a018455f55167da611d90e06592ada235","modified":1635332807023},{"_id":"public/2021/10/13/异常类/index.html","hash":"1be61aa428ca0d9684ea6dd258aadb8ea5489973","modified":1634643587515},{"_id":"source/_posts/RuntimeException的常见子类.md","hash":"9da6b3385d3975ac489dae240c31dc89193a0394","modified":1634643580642},{"_id":"public/2021/10/19/RuntimeException的常见子类/index.html","hash":"1d621c2a2d36ce6a8092688cec691acf89487857","modified":1634817007287},{"_id":"source/_posts/自定义异常.md","hash":"1efa935e11d935444bc1ddf249106cce21b89cbf","modified":1634816986688},{"_id":"public/2021/10/19/自定义异常/index.html","hash":"5d3242d8c1beb0fab7dc4486f06af756bee39bec","modified":1635332807023},{"_id":"source/_posts/异常中的finally.md","hash":"b0d1300469fcf018ad0cb0df0827f84c70c7965f","modified":1635335211889},{"_id":"public/2021/10/22/异常中的finally/index.html","hash":"80699b18dc1bc1bcb0547ae808d532ad4f1e49ec","modified":1635423086903}],"Category":[{"name":"algorithm","_id":"cks0a08qy000030uihje6g1ho"},{"name":"java","_id":"cks0a192p0000pwui9vseab12"},{"name":"network","_id":"cks0a1py50002pwuif3yu6wjc"},{"name":"pet","_id":"cks0a27e00004pwuic91m9w0b"},{"name":"travel","_id":"cks0a2hip0006pwuiabxrblnm"},{"name":"data structure","_id":"cksoitmkn00020wui5opq73cc"}],"Data":[],"Page":[{"title":"categories","type":"categories","layout":"categories","date":"2021-08-06T10:41:28.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\nlayout: \"categories\"\ndate: 2021-08-06 18:41:28\n---\n","updated":"2021-08-06T10:42:24.927Z","path":"categories/index.html","comments":1,"_id":"cks0855lk00008wui1itudyao","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","date":"2021-08-06T10:48:44.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\nlayout: \"tags\"\ndate: 2021-08-06 18:48:44\n---\n","updated":"2021-08-06T10:49:24.398Z","path":"tags/index.html","comments":1,"_id":"cks089um800001wui4c0n4yq2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2021-08-06T11:13:09.000Z","_content":"","source":"2021/about/index.md","raw":"---\ntitle: about\ndate: 2021-08-06 19:13:09\n---\n","updated":"2021-08-06T11:13:09.501Z","path":"2021/about/index.html","comments":1,"layout":"page","_id":"cks09286u0000bwui3kk01uiw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"blog的诞生","date":"2021-08-06T09:32:59.000Z","_content":"","source":"_posts/blog的诞生.md","raw":"---\ntitle: blog的诞生\ndate: 2021-08-06 17:32:59\ntags:\n---\n","slug":"blog的诞生","published":1,"updated":"2021-08-06T09:32:59.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks09kwa00000e8ui9lyab5jh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"init algorithm","date":"2021-08-06T11:10:24.000Z","_content":"","source":"_posts/init-algorithm.md","raw":"---\ntitle: init algorithm\ndate: 2021-08-06 19:10:24\ntags: algorithm\ncategories: algorithm\n---\n","slug":"init-algorithm","published":1,"updated":"2021-08-06T11:39:54.597Z","_id":"cks09lpzv00012wuibu7zcrrm","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"init network","date":"2021-08-06T11:09:40.000Z","_content":"\n","source":"_posts/init-network.md","raw":"---\ntitle: init network\ndate: 2021-08-06 19:09:40\ntags: network\ncategories: network\n---\n\n","slug":"init-network","published":1,"updated":"2021-08-06T11:41:41.621Z","_id":"cks09lpzx00032wuignus8w75","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"init travel","date":"2021-08-06T11:10:37.000Z","_content":"","source":"_posts/init-travel.md","raw":"---\ntitle: init travel\ndate: 2021-08-06 19:10:37\ntags: travel\ncategories: travel\n---\n","slug":"init-travel","published":1,"updated":"2021-08-06T11:41:39.771Z","_id":"cks09lpzx00052wui0r89d0sk","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"init pet","date":"2021-08-06T11:10:42.000Z","_content":"","source":"_posts/init-pet.md","raw":"---\ntitle: init pet\ndate: 2021-08-06 19:10:42\ntags: pet\ncategories: pet\n---\n","slug":"init-pet","published":1,"updated":"2021-08-06T11:41:26.154Z","_id":"cks09lpzy00072wui2zot8kay","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java基本数据类型","date":"2021-08-09T03:31:43.000Z","_content":"\n#### Java有八种基本数据类型\n\n- 整数类型：有四种整形 byte/short/int/long，取值范围各不同\n- 小数类型：有两种小数型：float/double，取值范围和精度各不同\n- 字符类型：char，表示单个字符\n- 真假类型：boolean，表示真假  \n\n每个基本数据类型都有对应的数组类型，比如整数对应整数数组，char对应char数组.\n\n​          \n\nlong型要在赋值常量后面加L，表示是long型，否则默认int型 \n\nfloat型要在赋值常量后面加f或F，表示是float型，否则默认double型   \n\n​       \n\n\nchar用两个字节表示一个字符，可中文可英文，单引号   \n\n","source":"_posts/java基本数据类型.md","raw":"---\ntitle: java基本数据类型\ndate: 2021-08-09 11:31:43\ntags: java\ncategories: java\n---\n\n#### Java有八种基本数据类型\n\n- 整数类型：有四种整形 byte/short/int/long，取值范围各不同\n- 小数类型：有两种小数型：float/double，取值范围和精度各不同\n- 字符类型：char，表示单个字符\n- 真假类型：boolean，表示真假  \n\n每个基本数据类型都有对应的数组类型，比如整数对应整数数组，char对应char数组.\n\n​          \n\nlong型要在赋值常量后面加L，表示是long型，否则默认int型 \n\nfloat型要在赋值常量后面加f或F，表示是float型，否则默认double型   \n\n​       \n\n\nchar用两个字节表示一个字符，可中文可英文，单引号   \n\n","slug":"java基本数据类型","published":1,"updated":"2021-08-13T07:28:23.099Z","_id":"cks9zyqbi0000jwui5j9j24rj","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"Java有八种基本数据类型\"><a href=\"#Java有八种基本数据类型\" class=\"headerlink\" title=\"Java有八种基本数据类型\"></a>Java有八种基本数据类型</h4><ul>\n<li>整数类型：有四种整形 byte/short/int/long，取值范围各不同</li>\n<li>小数类型：有两种小数型：float/double，取值范围和精度各不同</li>\n<li>字符类型：char，表示单个字符</li>\n<li>真假类型：boolean，表示真假  </li>\n</ul>\n<p>每个基本数据类型都有对应的数组类型，比如整数对应整数数组，char对应char数组.</p>\n<p>​          </p>\n<p>long型要在赋值常量后面加L，表示是long型，否则默认int型 </p>\n<p>float型要在赋值常量后面加f或F，表示是float型，否则默认double型   </p>\n<p>​       </p>\n<p>char用两个字节表示一个字符，可中文可英文，单引号   </p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Java有八种基本数据类型\"><a href=\"#Java有八种基本数据类型\" class=\"headerlink\" title=\"Java有八种基本数据类型\"></a>Java有八种基本数据类型</h4><ul>\n<li>整数类型：有四种整形 byte/short/int/long，取值范围各不同</li>\n<li>小数类型：有两种小数型：float/double，取值范围和精度各不同</li>\n<li>字符类型：char，表示单个字符</li>\n<li>真假类型：boolean，表示真假  </li>\n</ul>\n<p>每个基本数据类型都有对应的数组类型，比如整数对应整数数组，char对应char数组.</p>\n<p>​          </p>\n<p>long型要在赋值常量后面加L，表示是long型，否则默认int型 </p>\n<p>float型要在赋值常量后面加f或F，表示是float型，否则默认double型   </p>\n<p>​       </p>\n<p>char用两个字节表示一个字符，可中文可英文，单引号   </p>\n"},{"title":"数组存储","date":"2021-08-09T07:14:29.000Z","_content":"\n基本类型的数组有三种赋值形式：\n\n```java\nint[] arr = {1,2,3}; //给定初始值\nint[] arr = new int[]{1,2,3}; //给定初始值\nint[] arr = new int[3]; //3代表长度\n```\n\n不能在给定初始值的同时还给定长度。    \n\n​    \n\n一个基本类型变量，内存中只会有一块对应的内存空间；\n\n一个数组，内存中有两块对应的内存空间，一块用于存储数组内容本身，另一块用于存储内容的位置。\n\n|         代码         | 内存地址 | 内存数据 |\n| :------------------: | :------: | :------: |\n|     int a = 100;     |   1000   |   100    |\n| int[] arr = {1,2,3}; |   2000   |   2500   |\n|                      |   2500   |    1     |\n|                      |   2504   |    2     |\n|                      |   2508   |    3     |\n\n如上面表格，int a 的内存地址是1000，该地址（1000）存储的值就是值100。int[] arr的内存地址是2000，该地址存储的值是的地址2500，而从2500的地址开始才实际存储1、2、3。\n\n\n\n\n\n\n\n\n\n","source":"_posts/数组存储.md","raw":"---\ntitle: 数组存储\ndate: 2021-08-09 15:14:29\ntags:\n- java\n- array\ncategories: java\n---\n\n基本类型的数组有三种赋值形式：\n\n```java\nint[] arr = {1,2,3}; //给定初始值\nint[] arr = new int[]{1,2,3}; //给定初始值\nint[] arr = new int[3]; //3代表长度\n```\n\n不能在给定初始值的同时还给定长度。    \n\n​    \n\n一个基本类型变量，内存中只会有一块对应的内存空间；\n\n一个数组，内存中有两块对应的内存空间，一块用于存储数组内容本身，另一块用于存储内容的位置。\n\n|         代码         | 内存地址 | 内存数据 |\n| :------------------: | :------: | :------: |\n|     int a = 100;     |   1000   |   100    |\n| int[] arr = {1,2,3}; |   2000   |   2500   |\n|                      |   2500   |    1     |\n|                      |   2504   |    2     |\n|                      |   2508   |    3     |\n\n如上面表格，int a 的内存地址是1000，该地址（1000）存储的值就是值100。int[] arr的内存地址是2000，该地址存储的值是的地址2500，而从2500的地址开始才实际存储1、2、3。\n\n\n\n\n\n\n\n\n\n","slug":"数组存储","published":1,"updated":"2021-08-13T07:28:42.846Z","_id":"cks9zyqbl0001jwuid70l7ic2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基本类型的数组有三种赋值形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;; <span class=\"comment\">//给定初始值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;; <span class=\"comment\">//给定初始值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>]; <span class=\"comment\">//3代表长度</span></span><br></pre></td></tr></table></figure>\n\n<p>不能在给定初始值的同时还给定长度。    </p>\n<p>​    </p>\n<p>一个基本类型变量，内存中只会有一块对应的内存空间；</p>\n<p>一个数组，内存中有两块对应的内存空间，一块用于存储数组内容本身，另一块用于存储内容的位置。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">代码</th>\n<th align=\"center\">内存地址</th>\n<th align=\"center\">内存数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">int a = 100;</td>\n<td align=\"center\">1000</td>\n<td align=\"center\">100</td>\n</tr>\n<tr>\n<td align=\"center\">int[] arr = {1,2,3};</td>\n<td align=\"center\">2000</td>\n<td align=\"center\">2500</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2500</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2504</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2508</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody></table>\n<p>如上面表格，int a 的内存地址是1000，该地址（1000）存储的值就是值100。int[] arr的内存地址是2000，该地址存储的值是的地址2500，而从2500的地址开始才实际存储1、2、3。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>基本类型的数组有三种赋值形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;; <span class=\"comment\">//给定初始值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;; <span class=\"comment\">//给定初始值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>]; <span class=\"comment\">//3代表长度</span></span><br></pre></td></tr></table></figure>\n\n<p>不能在给定初始值的同时还给定长度。    </p>\n<p>​    </p>\n<p>一个基本类型变量，内存中只会有一块对应的内存空间；</p>\n<p>一个数组，内存中有两块对应的内存空间，一块用于存储数组内容本身，另一块用于存储内容的位置。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">代码</th>\n<th align=\"center\">内存地址</th>\n<th align=\"center\">内存数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">int a = 100;</td>\n<td align=\"center\">1000</td>\n<td align=\"center\">100</td>\n</tr>\n<tr>\n<td align=\"center\">int[] arr = {1,2,3};</td>\n<td align=\"center\">2000</td>\n<td align=\"center\">2500</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2500</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2504</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2508</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody></table>\n<p>如上面表格，int a 的内存地址是1000，该地址（1000）存储的值就是值100。int[] arr的内存地址是2000，该地址存储的值是的地址2500，而从2500的地址开始才实际存储1、2、3。</p>\n"},{"title":"位运算","date":"2021-08-13T09:59:36.000Z","_content":"\n位运算是将数据看作二进制，进行位级别的操作。\nJava不能单独表示一个位，但是可以用byte表示8位，也可以用16进制来写二进制常量。\n\n​    \n\n位运算有移位运算和逻辑运算。\n\n\n\n移位运算：\n\n- 左移：操作符为<<，向左移动，右边的低位补0，高位的舍弃掉。左移1位相当于乘以2。\n- 无符号右移：操作符为>>>，向右移动，右边的舍弃掉，左边补0。\n- 有符号右移：操作符为>>，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是0就补0，原来是1就补1。有符号右移相当于除以2。\n\n","source":"_posts/位运算.md","raw":"---\ntitle: 位运算\ndate: 2021-08-13 17:59:36\ntags: java\ncategories: java\n---\n\n位运算是将数据看作二进制，进行位级别的操作。\nJava不能单独表示一个位，但是可以用byte表示8位，也可以用16进制来写二进制常量。\n\n​    \n\n位运算有移位运算和逻辑运算。\n\n\n\n移位运算：\n\n- 左移：操作符为<<，向左移动，右边的低位补0，高位的舍弃掉。左移1位相当于乘以2。\n- 无符号右移：操作符为>>>，向右移动，右边的舍弃掉，左边补0。\n- 有符号右移：操作符为>>，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是0就补0，原来是1就补1。有符号右移相当于除以2。\n\n","slug":"位运算","published":1,"updated":"2021-08-23T09:40:57.192Z","_id":"cksa6jbbo0000zsui1w1k1ld5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>位运算是将数据看作二进制，进行位级别的操作。<br>Java不能单独表示一个位，但是可以用byte表示8位，也可以用16进制来写二进制常量。</p>\n<p>​    </p>\n<p>位运算有移位运算和逻辑运算。</p>\n<p>移位运算：</p>\n<ul>\n<li>左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的舍弃掉。左移1位相当于乘以2。</li>\n<li>无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。</li>\n<li>有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是0就补0，原来是1就补1。有符号右移相当于除以2。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>位运算是将数据看作二进制，进行位级别的操作。<br>Java不能单独表示一个位，但是可以用byte表示8位，也可以用16进制来写二进制常量。</p>\n<p>​    </p>\n<p>位运算有移位运算和逻辑运算。</p>\n<p>移位运算：</p>\n<ul>\n<li>左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的舍弃掉。左移1位相当于乘以2。</li>\n<li>无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。</li>\n<li>有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是0就补0，原来是1就补1。有符号右移相当于除以2。</li>\n</ul>\n"},{"title":"十六进制","date":"2021-08-13T09:43:25.000Z","_content":"\n在数字前面加0x，代表十六进制\n\n比如十进制的123，等于十六进制的0x7B\n\n​    \n\njava中不支持直接写二进制常量，可以用十六进制来表示\n\n​    \n\n可以是用Long和Integer的方法，查看二进制和十六进制的表示：\n```java\nint a =25;\nSystem.out.println(Integer.toBinaryString(a));  //二进制\nSystem.out.println(Integer.toHexString(a));  //十六进制\nSystem.out.println(Long.toBinaryString(a));  //二进制\nSystem.out.println(Long.toHexString(a));  //十六进制\n```\n\n","source":"_posts/十六进制.md","raw":"---\ntitle: 十六进制\ndate: 2021-08-13 17:43:25\ntags: java\ncategories: java\n---\n\n在数字前面加0x，代表十六进制\n\n比如十进制的123，等于十六进制的0x7B\n\n​    \n\njava中不支持直接写二进制常量，可以用十六进制来表示\n\n​    \n\n可以是用Long和Integer的方法，查看二进制和十六进制的表示：\n```java\nint a =25;\nSystem.out.println(Integer.toBinaryString(a));  //二进制\nSystem.out.println(Integer.toHexString(a));  //十六进制\nSystem.out.println(Long.toBinaryString(a));  //二进制\nSystem.out.println(Long.toHexString(a));  //十六进制\n```\n\n","slug":"十六进制","published":1,"updated":"2021-08-23T09:41:06.937Z","_id":"cksa6jbbs0001zsui2hml9797","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在数字前面加0x，代表十六进制</p>\n<p>比如十进制的123，等于十六进制的0x7B</p>\n<p>​    </p>\n<p>java中不支持直接写二进制常量，可以用十六进制来表示</p>\n<p>​    </p>\n<p>可以是用Long和Integer的方法，查看二进制和十六进制的表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a =<span class=\"number\">25</span>;</span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a));  <span class=\"comment\">//二进制</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));  <span class=\"comment\">//十六进制</span></span><br><span class=\"line\">System.out.println(Long.toBinaryString(a));  <span class=\"comment\">//二进制</span></span><br><span class=\"line\">System.out.println(Long.toHexString(a));  <span class=\"comment\">//十六进制</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>在数字前面加0x，代表十六进制</p>\n<p>比如十进制的123，等于十六进制的0x7B</p>\n<p>​    </p>\n<p>java中不支持直接写二进制常量，可以用十六进制来表示</p>\n<p>​    </p>\n<p>可以是用Long和Integer的方法，查看二进制和十六进制的表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a =<span class=\"number\">25</span>;</span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a));  <span class=\"comment\">//二进制</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));  <span class=\"comment\">//十六进制</span></span><br><span class=\"line\">System.out.println(Long.toBinaryString(a));  <span class=\"comment\">//二进制</span></span><br><span class=\"line\">System.out.println(Long.toHexString(a));  <span class=\"comment\">//十六进制</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"负数的二进制表示","date":"2021-08-13T07:30:45.000Z","_content":"\n正数的表示法：原码表示法\n\n​    \n\n负数的表示法：补码表示法。补码=原码取反然后加1\n\n例如(byte类型)：\n\n-1：1的原码是00000001，取反是11111110，然后再加1，就是11111111\n\n 如何计算11111111等于多少？\n\n解：先取反，得00000000，再加1，得00000001，可知该负数绝对值为1，实际值为-1\n\n对负数进行补码运算就可以得到原码，如同十进制的负负得正。\n\n​     \n\n","source":"_posts/负数的二进制表示.md","raw":"---\ntitle: 负数的二进制表示\ndate: 2021-08-13 15:30:45\ntags: java\ncategories: java\n---\n\n正数的表示法：原码表示法\n\n​    \n\n负数的表示法：补码表示法。补码=原码取反然后加1\n\n例如(byte类型)：\n\n-1：1的原码是00000001，取反是11111110，然后再加1，就是11111111\n\n 如何计算11111111等于多少？\n\n解：先取反，得00000000，再加1，得00000001，可知该负数绝对值为1，实际值为-1\n\n对负数进行补码运算就可以得到原码，如同十进制的负负得正。\n\n​     \n\n","slug":"负数的二进制表示","published":1,"updated":"2021-08-23T09:41:15.708Z","_id":"cksa6jbbt0003zsuicl9y0ain","comments":1,"layout":"post","photos":[],"link":"","content":"<p>正数的表示法：原码表示法</p>\n<p>​    </p>\n<p>负数的表示法：补码表示法。补码=原码取反然后加1</p>\n<p>例如(byte类型)：</p>\n<p>-1：1的原码是00000001，取反是11111110，然后再加1，就是11111111</p>\n<p> 如何计算11111111等于多少？</p>\n<p>解：先取反，得00000000，再加1，得00000001，可知该负数绝对值为1，实际值为-1</p>\n<p>对负数进行补码运算就可以得到原码，如同十进制的负负得正。</p>\n<p>​     </p>\n","site":{"data":{}},"excerpt":"","more":"<p>正数的表示法：原码表示法</p>\n<p>​    </p>\n<p>负数的表示法：补码表示法。补码=原码取反然后加1</p>\n<p>例如(byte类型)：</p>\n<p>-1：1的原码是00000001，取反是11111110，然后再加1，就是11111111</p>\n<p> 如何计算11111111等于多少？</p>\n<p>解：先取反，得00000000，再加1，得00000001，可知该负数绝对值为1，实际值为-1</p>\n<p>对负数进行补码运算就可以得到原码，如同十进制的负负得正。</p>\n<p>​     </p>\n"},{"title":"乱码","date":"2021-08-17T11:42:55.000Z","_content":"\nASCII编码：美国规定了128个字符的二进制表示法，即ASCII（美国信息互换标准代码）。\n\n\n\n数字32~126表示的字符都是可打印字符。\n\n![ASCII:32~126](https://i.loli.net/2021/08/18/Ff3mCbyeoNtBswc.jpg)\n\n0~31和127表示的这些字符都是不可打印字符，它们一般用于控制目的。\n\n![ASCII:0~31,127](https://i.loli.net/2021/08/18/IOQ7fqUmaC9Vwb8.jpg)\n\n​       \n\n美国的编码不够其他国家使用，其他国家陆续发明了各种各样的编码方式。在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312，GBK，GB18030和Big5。\n\n​    \n\n美国和西欧都是用一个字节（8位）就够了，但中文是两个字节（16位）\n\n​    \n\nAscii码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容Ascii的，最高位使用1来进行区分。\n\n西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。\n\n中文大陆地区的三个主要编码GB2312，GBK，GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。\n\n​    \n\n最高位用1的编码，除了GB2312/GBK/GB18030外，都是不兼容的。比如Windows-1252和GBK就不兼容。\n\n​     \n\nUnicode：将世界上所有的字符统一编码，给世界上所有字符都分配了一个唯一的数字编号。\n\n其中UTF-8使用1~4个字节表示，兼容ASCII编码。英文字符使用1个字节，中文字符大多使用3个字节。\n\n\n\n如何恢复乱码？\n\n答:先将A编码的字符映射为二进制，再通过二进制映射B编码的字符。\n\n","source":"_posts/乱码.md","raw":"---\ntitle: 乱码\ndate: 2021-08-17 19:42:55\ntags: java\ncategories: java\n---\n\nASCII编码：美国规定了128个字符的二进制表示法，即ASCII（美国信息互换标准代码）。\n\n\n\n数字32~126表示的字符都是可打印字符。\n\n![ASCII:32~126](https://i.loli.net/2021/08/18/Ff3mCbyeoNtBswc.jpg)\n\n0~31和127表示的这些字符都是不可打印字符，它们一般用于控制目的。\n\n![ASCII:0~31,127](https://i.loli.net/2021/08/18/IOQ7fqUmaC9Vwb8.jpg)\n\n​       \n\n美国的编码不够其他国家使用，其他国家陆续发明了各种各样的编码方式。在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312，GBK，GB18030和Big5。\n\n​    \n\n美国和西欧都是用一个字节（8位）就够了，但中文是两个字节（16位）\n\n​    \n\nAscii码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容Ascii的，最高位使用1来进行区分。\n\n西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。\n\n中文大陆地区的三个主要编码GB2312，GBK，GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。\n\n​    \n\n最高位用1的编码，除了GB2312/GBK/GB18030外，都是不兼容的。比如Windows-1252和GBK就不兼容。\n\n​     \n\nUnicode：将世界上所有的字符统一编码，给世界上所有字符都分配了一个唯一的数字编号。\n\n其中UTF-8使用1~4个字节表示，兼容ASCII编码。英文字符使用1个字节，中文字符大多使用3个字节。\n\n\n\n如何恢复乱码？\n\n答:先将A编码的字符映射为二进制，再通过二进制映射B编码的字符。\n\n","slug":"乱码","published":1,"updated":"2021-08-23T09:40:52.315Z","_id":"cksg2fmre0000oguieldgcz2c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>ASCII编码：美国规定了128个字符的二进制表示法，即ASCII（美国信息互换标准代码）。</p>\n<p>数字32~126表示的字符都是可打印字符。</p>\n<p><img src=\"https://i.loli.net/2021/08/18/Ff3mCbyeoNtBswc.jpg\" alt=\"ASCII:32~126\"></p>\n<p>0~31和127表示的这些字符都是不可打印字符，它们一般用于控制目的。</p>\n<p><img src=\"https://i.loli.net/2021/08/18/IOQ7fqUmaC9Vwb8.jpg\" alt=\"ASCII:0~31,127\"></p>\n<p>​       </p>\n<p>美国的编码不够其他国家使用，其他国家陆续发明了各种各样的编码方式。在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312，GBK，GB18030和Big5。</p>\n<p>​    </p>\n<p>美国和西欧都是用一个字节（8位）就够了，但中文是两个字节（16位）</p>\n<p>​    </p>\n<p>Ascii码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容Ascii的，最高位使用1来进行区分。</p>\n<p>西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。</p>\n<p>中文大陆地区的三个主要编码GB2312，GBK，GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。</p>\n<p>​    </p>\n<p>最高位用1的编码，除了GB2312/GBK/GB18030外，都是不兼容的。比如Windows-1252和GBK就不兼容。</p>\n<p>​     </p>\n<p>Unicode：将世界上所有的字符统一编码，给世界上所有字符都分配了一个唯一的数字编号。</p>\n<p>其中UTF-8使用1~4个字节表示，兼容ASCII编码。英文字符使用1个字节，中文字符大多使用3个字节。</p>\n<p>如何恢复乱码？</p>\n<p>答:先将A编码的字符映射为二进制，再通过二进制映射B编码的字符。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ASCII编码：美国规定了128个字符的二进制表示法，即ASCII（美国信息互换标准代码）。</p>\n<p>数字32~126表示的字符都是可打印字符。</p>\n<p><img src=\"https://i.loli.net/2021/08/18/Ff3mCbyeoNtBswc.jpg\" alt=\"ASCII:32~126\"></p>\n<p>0~31和127表示的这些字符都是不可打印字符，它们一般用于控制目的。</p>\n<p><img src=\"https://i.loli.net/2021/08/18/IOQ7fqUmaC9Vwb8.jpg\" alt=\"ASCII:0~31,127\"></p>\n<p>​       </p>\n<p>美国的编码不够其他国家使用，其他国家陆续发明了各种各样的编码方式。在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312，GBK，GB18030和Big5。</p>\n<p>​    </p>\n<p>美国和西欧都是用一个字节（8位）就够了，但中文是两个字节（16位）</p>\n<p>​    </p>\n<p>Ascii码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容Ascii的，最高位使用1来进行区分。</p>\n<p>西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。</p>\n<p>中文大陆地区的三个主要编码GB2312，GBK，GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。</p>\n<p>​    </p>\n<p>最高位用1的编码，除了GB2312/GBK/GB18030外，都是不兼容的。比如Windows-1252和GBK就不兼容。</p>\n<p>​     </p>\n<p>Unicode：将世界上所有的字符统一编码，给世界上所有字符都分配了一个唯一的数字编号。</p>\n<p>其中UTF-8使用1~4个字节表示，兼容ASCII编码。英文字符使用1个字节，中文字符大多使用3个字节。</p>\n<p>如何恢复乱码？</p>\n<p>答:先将A编码的字符映射为二进制，再通过二进制映射B编码的字符。</p>\n"},{"title":"char的含义","date":"2021-08-18T07:40:16.000Z","_content":"\nchar本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编码，用于表示Unicode编号对应的字符。\n\n由于char固定占用两个字符，char只能表示Unicode编号在65536以内的字符（无论是英文字符还是中文字符），而不能表示超出范围的字符。\n\n​    \n\n由于char本质是一个整数，可以进行整数的一些运算。\n\n在进行运算时会被看做int，但由于char占两个字节，运算结果不能直接赋值给char类型，而是需要进行强制类型转换。\n\nchar类型的比较，就是Unicode编号的比较。\n\n​    \n\n大小写转换：大写A-Z的编号是65-90，小写a-z的编号是97-122，正好相差32，所以大写转小写要加32，小写转大写要减32。\n\n","source":"_posts/char的含义.md","raw":"---\ntitle: char的含义\ndate: 2021-08-18 15:40:16\ntags: java\ncategories: java\n---\n\nchar本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编码，用于表示Unicode编号对应的字符。\n\n由于char固定占用两个字符，char只能表示Unicode编号在65536以内的字符（无论是英文字符还是中文字符），而不能表示超出范围的字符。\n\n​    \n\n由于char本质是一个整数，可以进行整数的一些运算。\n\n在进行运算时会被看做int，但由于char占两个字节，运算结果不能直接赋值给char类型，而是需要进行强制类型转换。\n\nchar类型的比较，就是Unicode编号的比较。\n\n​    \n\n大小写转换：大写A-Z的编号是65-90，小写a-z的编号是97-122，正好相差32，所以大写转小写要加32，小写转大写要减32。\n\n","slug":"char的含义","published":1,"updated":"2021-08-23T09:41:24.168Z","_id":"ckshdjvb80000nsui582ycseo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编码，用于表示Unicode编号对应的字符。</p>\n<p>由于char固定占用两个字符，char只能表示Unicode编号在65536以内的字符（无论是英文字符还是中文字符），而不能表示超出范围的字符。</p>\n<p>​    </p>\n<p>由于char本质是一个整数，可以进行整数的一些运算。</p>\n<p>在进行运算时会被看做int，但由于char占两个字节，运算结果不能直接赋值给char类型，而是需要进行强制类型转换。</p>\n<p>char类型的比较，就是Unicode编号的比较。</p>\n<p>​    </p>\n<p>大小写转换：大写A-Z的编号是65-90，小写a-z的编号是97-122，正好相差32，所以大写转小写要加32，小写转大写要减32。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编码，用于表示Unicode编号对应的字符。</p>\n<p>由于char固定占用两个字符，char只能表示Unicode编号在65536以内的字符（无论是英文字符还是中文字符），而不能表示超出范围的字符。</p>\n<p>​    </p>\n<p>由于char本质是一个整数，可以进行整数的一些运算。</p>\n<p>在进行运算时会被看做int，但由于char占两个字节，运算结果不能直接赋值给char类型，而是需要进行强制类型转换。</p>\n<p>char类型的比较，就是Unicode编号的比较。</p>\n<p>​    </p>\n<p>大小写转换：大写A-Z的编号是65-90，小写a-z的编号是97-122，正好相差32，所以大写转小写要加32，小写转大写要减32。</p>\n"},{"title":"四种循环","date":"2021-08-20T08:58:53.000Z","_content":"\n在java中，循环有四种形式，分别是while,do/while,for,foreach。\n\n​    \n\n**while**\n\n```java\nScanner reader = new Scanner(System.in);\nSystem.out.println(\"please input password\");\nint num = reader.nextInt();\nint password = 12345;\nwhile(num!=password) {\n    System.out.println(\"please input password\");\n    num = reader.nextInt();\n}\nSystem.out.println(\"correct\");\nreader.close();\n```\n\n上述代码的功能：使用类型为Scanner的reader变量从屏幕控制台接收数字,reader.nextInt()从屏幕接收一个数字。如果数字不是12345，就一直提示输入；数字是12345，就跳出循环。\n\n​    \n\n**do/while**\n\n不管语句条件是什么，代码块都会至少执行一次。\n\n先执行代码块，然后再判断条件语句。如果成立，则继续循环，否则退出循环。\n\n```java\nScanner reader = new Scanner(System.in);\nint password = 6789;\nint num = 0;\ndo {\n    System.out.println(\"please input password\");\n    num = reader.nextInt();\n}while(num!=password); //注意加分号\nSystem.out.println(\"correct\");\nreader.close();\n```\n\n   \n\n**for**\n\nfor(初始化语句;循环条件;步进操作){\n\n​\t循环体\n}\n\n分号不能省略。\n\n​    \n\n**foreach**\n\nfor (元素类型 元素名称 : 遍历数组/集合/能进行迭代的实例) {\n\n​\t语句\n\n}\n\n```java\nint[] arr = {1,2,3,4};\nfor(int element : arr) {\n    System.out.println(element);\n}\n```\n\nforeach使用冒号:，冒号前面是循环中的每个元素，包括数据类型和变量名称。\n\n冒号后面是要遍历的数组或集合。\n\n每次循环中element都会自动更新。\n\n对于不需要使用索引变量、只是简单遍历的情况，foreach语法上更为简洁。\n\n​    \n\n**循环控制 - break **\n\n使用break关键字可以中断循环。\n\n​    \n\n**循环控制 - continue **\n\ncontinue语句会跳过循环体中剩下的代码，然后执行步进操作。\n\n","source":"_posts/四种循环.md","raw":"---\ntitle: 四种循环\ndate: 2021-08-20 16:58:53\ntags: java\ncategories: java\n---\n\n在java中，循环有四种形式，分别是while,do/while,for,foreach。\n\n​    \n\n**while**\n\n```java\nScanner reader = new Scanner(System.in);\nSystem.out.println(\"please input password\");\nint num = reader.nextInt();\nint password = 12345;\nwhile(num!=password) {\n    System.out.println(\"please input password\");\n    num = reader.nextInt();\n}\nSystem.out.println(\"correct\");\nreader.close();\n```\n\n上述代码的功能：使用类型为Scanner的reader变量从屏幕控制台接收数字,reader.nextInt()从屏幕接收一个数字。如果数字不是12345，就一直提示输入；数字是12345，就跳出循环。\n\n​    \n\n**do/while**\n\n不管语句条件是什么，代码块都会至少执行一次。\n\n先执行代码块，然后再判断条件语句。如果成立，则继续循环，否则退出循环。\n\n```java\nScanner reader = new Scanner(System.in);\nint password = 6789;\nint num = 0;\ndo {\n    System.out.println(\"please input password\");\n    num = reader.nextInt();\n}while(num!=password); //注意加分号\nSystem.out.println(\"correct\");\nreader.close();\n```\n\n   \n\n**for**\n\nfor(初始化语句;循环条件;步进操作){\n\n​\t循环体\n}\n\n分号不能省略。\n\n​    \n\n**foreach**\n\nfor (元素类型 元素名称 : 遍历数组/集合/能进行迭代的实例) {\n\n​\t语句\n\n}\n\n```java\nint[] arr = {1,2,3,4};\nfor(int element : arr) {\n    System.out.println(element);\n}\n```\n\nforeach使用冒号:，冒号前面是循环中的每个元素，包括数据类型和变量名称。\n\n冒号后面是要遍历的数组或集合。\n\n每次循环中element都会自动更新。\n\n对于不需要使用索引变量、只是简单遍历的情况，foreach语法上更为简洁。\n\n​    \n\n**循环控制 - break **\n\n使用break关键字可以中断循环。\n\n​    \n\n**循环控制 - continue **\n\ncontinue语句会跳过循环体中剩下的代码，然后执行步进操作。\n\n","slug":"四种循环","published":1,"updated":"2021-08-23T09:41:09.872Z","_id":"cksk9m4970000s0ui6zm8el39","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在java中，循环有四种形式，分别是while,do/while,for,foreach。</p>\n<p>​    </p>\n<p><strong>while</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner reader = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;please input password&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> num = reader.nextInt();</span><br><span class=\"line\"><span class=\"keyword\">int</span> password = <span class=\"number\">12345</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(num!=password) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;please input password&quot;</span>);</span><br><span class=\"line\">    num = reader.nextInt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;correct&quot;</span>);</span><br><span class=\"line\">reader.close();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码的功能：使用类型为Scanner的reader变量从屏幕控制台接收数字,reader.nextInt()从屏幕接收一个数字。如果数字不是12345，就一直提示输入；数字是12345，就跳出循环。</p>\n<p>​    </p>\n<p><strong>do/while</strong></p>\n<p>不管语句条件是什么，代码块都会至少执行一次。</p>\n<p>先执行代码块，然后再判断条件语句。如果成立，则继续循环，否则退出循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner reader = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> password = <span class=\"number\">6789</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;please input password&quot;</span>);</span><br><span class=\"line\">    num = reader.nextInt();</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(num!=password); <span class=\"comment\">//注意加分号</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;correct&quot;</span>);</span><br><span class=\"line\">reader.close();</span><br></pre></td></tr></table></figure>\n\n<p><strong>for</strong></p>\n<p>for(初始化语句;循环条件;步进操作){</p>\n<p>​    循环体<br>}</p>\n<p>分号不能省略。</p>\n<p>​    </p>\n<p><strong>foreach</strong></p>\n<p>for (元素类型 元素名称 : 遍历数组/集合/能进行迭代的实例) {</p>\n<p>​    语句</p>\n<p>}</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> element : arr) &#123;</span><br><span class=\"line\">    System.out.println(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>foreach使用冒号:，冒号前面是循环中的每个元素，包括数据类型和变量名称。</p>\n<p>冒号后面是要遍历的数组或集合。</p>\n<p>每次循环中element都会自动更新。</p>\n<p>对于不需要使用索引变量、只是简单遍历的情况，foreach语法上更为简洁。</p>\n<p>​    </p>\n<p>**循环控制 - break **</p>\n<p>使用break关键字可以中断循环。</p>\n<p>​    </p>\n<p>**循环控制 - continue **</p>\n<p>continue语句会跳过循环体中剩下的代码，然后执行步进操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在java中，循环有四种形式，分别是while,do/while,for,foreach。</p>\n<p>​    </p>\n<p><strong>while</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner reader = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;please input password&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> num = reader.nextInt();</span><br><span class=\"line\"><span class=\"keyword\">int</span> password = <span class=\"number\">12345</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(num!=password) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;please input password&quot;</span>);</span><br><span class=\"line\">    num = reader.nextInt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;correct&quot;</span>);</span><br><span class=\"line\">reader.close();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码的功能：使用类型为Scanner的reader变量从屏幕控制台接收数字,reader.nextInt()从屏幕接收一个数字。如果数字不是12345，就一直提示输入；数字是12345，就跳出循环。</p>\n<p>​    </p>\n<p><strong>do/while</strong></p>\n<p>不管语句条件是什么，代码块都会至少执行一次。</p>\n<p>先执行代码块，然后再判断条件语句。如果成立，则继续循环，否则退出循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner reader = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> password = <span class=\"number\">6789</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;please input password&quot;</span>);</span><br><span class=\"line\">    num = reader.nextInt();</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(num!=password); <span class=\"comment\">//注意加分号</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;correct&quot;</span>);</span><br><span class=\"line\">reader.close();</span><br></pre></td></tr></table></figure>\n\n<p><strong>for</strong></p>\n<p>for(初始化语句;循环条件;步进操作){</p>\n<p>​    循环体<br>}</p>\n<p>分号不能省略。</p>\n<p>​    </p>\n<p><strong>foreach</strong></p>\n<p>for (元素类型 元素名称 : 遍历数组/集合/能进行迭代的实例) {</p>\n<p>​    语句</p>\n<p>}</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> element : arr) &#123;</span><br><span class=\"line\">    System.out.println(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>foreach使用冒号:，冒号前面是循环中的每个元素，包括数据类型和变量名称。</p>\n<p>冒号后面是要遍历的数组或集合。</p>\n<p>每次循环中element都会自动更新。</p>\n<p>对于不需要使用索引变量、只是简单遍历的情况，foreach语法上更为简洁。</p>\n<p>​    </p>\n<p>**循环控制 - break **</p>\n<p>使用break关键字可以中断循环。</p>\n<p>​    </p>\n<p>**循环控制 - continue **</p>\n<p>continue语句会跳过循环体中剩下的代码，然后执行步进操作。</p>\n"},{"title":"函数定义","date":"2021-08-23T06:42:25.000Z","_content":"\n函数的基本语法结构:\n\n```java\n修饰符 返回值类型 函数名字(参数类型 参数名字,...) {\n    操作 ...\n    return 返回值;\n}\n```\n\n定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。\n\n​    \n\njava中，任何函数都需要放在一个类中。函数放在类中，类中包含多个函数。\n\n函数一般叫做方法。\n\n一个类里面可以定义多个函数，可以定义一个叫做**main**的函数，形式如下:\n\n```java\npublic static void main(String[] args) {\n    ...\n}\n```\n\nmain函数表示程序的入口，String[] args表示从控制台接收到的参数。\n\njava中运行一个程序的时候，需要指定一个定义了main函数的类，java会寻找main函数，并从main函数开始执行。\n\n​    \n\n对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。\n\n\n\n**数组参数**\n\n数组作为参数与基本类型不同，~~基本类型不会对调用者中的变量造成任何影响~~(不懂这句= =)，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。\n\n```java\npublic static void reset(int[] arr){\n    for(int i=0;i<arr.length;i++){\n        arr[i] = i;\n    }\n}\npublic static void main(String[] args){\n    int[] arr = {10,20,30,40};\n    reset(arr);\n    for(int i=0;i<arr.length;i++){\n        System.out.println(arr[i]);\n    }\n}\n```\n\n在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。\n\n​    \n\n**可变长度的参数**\n\n有的时候，参数个数不是固定的，数量是未知的。\n\njava支持可变长度的参数：\n\n```java\npublic static int max(int min,int... a) {\n    int max = min;\n    for(int i=0;i<a.length;i++) {\n        if(max<a[i]) {\n            max = a[i];\n        }\n    }\n    return max;\n}\n\npublic static void main(String[] args) {\n    System.out.println(max(0));\n    System.out.println(max(0,2));\n    System.out.println(max(0,2,4));\n    System.out.println(max(0,2,4,5));\n}\n```\n\nmax函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。\n\n可变长度参数的语法是在数据类型后面加三个点...，在函数内，可变长度参数可以看作是数组，可变长度参数必须是参数列表中的最后一个参数，一个函数也只能有一个可变长度的参数。\n\n可变长度参数实际上会转换为数组参数，函数声明max(int min,int... a)实际上会转换为max(int min,int[] a)。在main函数调用max(0,2,4,5)的时候，实际上会转换为调用max(0,new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。\n\n   \n\n函数的返回值最多只能有一个，void情况下没有返回值。\n\n​    \n\n同一个类里，函数可以重名，但是参数不能一样。一样是指参数个数相同，每个位置的参数类型也一样。但参数的名字不算，返回值类型也不算。\n\n换句话说，函数的**唯一性标示是：类名\\_函数名\\_参数2类型\\_...参数n类型**。\n\n","source":"_posts/函数定义.md","raw":"---\ntitle: 函数定义\ndate: 2021-08-23 14:42:25\ntags:\n - java\n - function\ncategories: java\n---\n\n函数的基本语法结构:\n\n```java\n修饰符 返回值类型 函数名字(参数类型 参数名字,...) {\n    操作 ...\n    return 返回值;\n}\n```\n\n定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。\n\n​    \n\njava中，任何函数都需要放在一个类中。函数放在类中，类中包含多个函数。\n\n函数一般叫做方法。\n\n一个类里面可以定义多个函数，可以定义一个叫做**main**的函数，形式如下:\n\n```java\npublic static void main(String[] args) {\n    ...\n}\n```\n\nmain函数表示程序的入口，String[] args表示从控制台接收到的参数。\n\njava中运行一个程序的时候，需要指定一个定义了main函数的类，java会寻找main函数，并从main函数开始执行。\n\n​    \n\n对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。\n\n\n\n**数组参数**\n\n数组作为参数与基本类型不同，~~基本类型不会对调用者中的变量造成任何影响~~(不懂这句= =)，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。\n\n```java\npublic static void reset(int[] arr){\n    for(int i=0;i<arr.length;i++){\n        arr[i] = i;\n    }\n}\npublic static void main(String[] args){\n    int[] arr = {10,20,30,40};\n    reset(arr);\n    for(int i=0;i<arr.length;i++){\n        System.out.println(arr[i]);\n    }\n}\n```\n\n在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。\n\n​    \n\n**可变长度的参数**\n\n有的时候，参数个数不是固定的，数量是未知的。\n\njava支持可变长度的参数：\n\n```java\npublic static int max(int min,int... a) {\n    int max = min;\n    for(int i=0;i<a.length;i++) {\n        if(max<a[i]) {\n            max = a[i];\n        }\n    }\n    return max;\n}\n\npublic static void main(String[] args) {\n    System.out.println(max(0));\n    System.out.println(max(0,2));\n    System.out.println(max(0,2,4));\n    System.out.println(max(0,2,4,5));\n}\n```\n\nmax函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。\n\n可变长度参数的语法是在数据类型后面加三个点...，在函数内，可变长度参数可以看作是数组，可变长度参数必须是参数列表中的最后一个参数，一个函数也只能有一个可变长度的参数。\n\n可变长度参数实际上会转换为数组参数，函数声明max(int min,int... a)实际上会转换为max(int min,int[] a)。在main函数调用max(0,2,4,5)的时候，实际上会转换为调用max(0,new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。\n\n   \n\n函数的返回值最多只能有一个，void情况下没有返回值。\n\n​    \n\n同一个类里，函数可以重名，但是参数不能一样。一样是指参数个数相同，每个位置的参数类型也一样。但参数的名字不算，返回值类型也不算。\n\n换句话说，函数的**唯一性标示是：类名\\_函数名\\_参数2类型\\_...参数n类型**。\n\n","slug":"函数定义","published":1,"updated":"2021-08-23T09:41:00.541Z","_id":"cksofxgbq0000ksuifs3mcind","comments":1,"layout":"post","photos":[],"link":"","content":"<p>函数的基本语法结构:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 返回值类型 函数名字(参数类型 参数名字,...) &#123;</span><br><span class=\"line\">    操作 ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> 返回值;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。</p>\n<p>​    </p>\n<p>java中，任何函数都需要放在一个类中。函数放在类中，类中包含多个函数。</p>\n<p>函数一般叫做方法。</p>\n<p>一个类里面可以定义多个函数，可以定义一个叫做<strong>main</strong>的函数，形式如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>main函数表示程序的入口，String[] args表示从控制台接收到的参数。</p>\n<p>java中运行一个程序的时候，需要指定一个定义了main函数的类，java会寻找main函数，并从main函数开始执行。</p>\n<p>​    </p>\n<p>对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。</p>\n<p><strong>数组参数</strong></p>\n<p>数组作为参数与基本类型不同，<del>基本类型不会对调用者中的变量造成任何影响</del>(不懂这句= =)，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        arr[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>&#125;;</span><br><span class=\"line\">    reset(arr);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        System.out.println(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。</p>\n<p>​    </p>\n<p><strong>可变长度的参数</strong></p>\n<p>有的时候，参数个数不是固定的，数量是未知的。</p>\n<p>java支持可变长度的参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> min,<span class=\"keyword\">int</span>... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = min;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(max&lt;a[i]) &#123;</span><br><span class=\"line\">            max = a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>));</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。</p>\n<p>可变长度参数的语法是在数据类型后面加三个点…，在函数内，可变长度参数可以看作是数组，可变长度参数必须是参数列表中的最后一个参数，一个函数也只能有一个可变长度的参数。</p>\n<p>可变长度参数实际上会转换为数组参数，函数声明max(int min,int… a)实际上会转换为max(int min,int[] a)。在main函数调用max(0,2,4,5)的时候，实际上会转换为调用max(0,new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。</p>\n<p>函数的返回值最多只能有一个，void情况下没有返回值。</p>\n<p>​    </p>\n<p>同一个类里，函数可以重名，但是参数不能一样。一样是指参数个数相同，每个位置的参数类型也一样。但参数的名字不算，返回值类型也不算。</p>\n<p>换句话说，函数的<strong>唯一性标示是：类名_函数名_参数2类型_…参数n类型</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>函数的基本语法结构:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 返回值类型 函数名字(参数类型 参数名字,...) &#123;</span><br><span class=\"line\">    操作 ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> 返回值;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。</p>\n<p>​    </p>\n<p>java中，任何函数都需要放在一个类中。函数放在类中，类中包含多个函数。</p>\n<p>函数一般叫做方法。</p>\n<p>一个类里面可以定义多个函数，可以定义一个叫做<strong>main</strong>的函数，形式如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>main函数表示程序的入口，String[] args表示从控制台接收到的参数。</p>\n<p>java中运行一个程序的时候，需要指定一个定义了main函数的类，java会寻找main函数，并从main函数开始执行。</p>\n<p>​    </p>\n<p>对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。</p>\n<p><strong>数组参数</strong></p>\n<p>数组作为参数与基本类型不同，<del>基本类型不会对调用者中的变量造成任何影响</del>(不懂这句= =)，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        arr[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>&#125;;</span><br><span class=\"line\">    reset(arr);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        System.out.println(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。</p>\n<p>​    </p>\n<p><strong>可变长度的参数</strong></p>\n<p>有的时候，参数个数不是固定的，数量是未知的。</p>\n<p>java支持可变长度的参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> min,<span class=\"keyword\">int</span>... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = min;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(max&lt;a[i]) &#123;</span><br><span class=\"line\">            max = a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>));</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\">    System.out.println(max(<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。</p>\n<p>可变长度参数的语法是在数据类型后面加三个点…，在函数内，可变长度参数可以看作是数组，可变长度参数必须是参数列表中的最后一个参数，一个函数也只能有一个可变长度的参数。</p>\n<p>可变长度参数实际上会转换为数组参数，函数声明max(int min,int… a)实际上会转换为max(int min,int[] a)。在main函数调用max(0,2,4,5)的时候，实际上会转换为调用max(0,new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。</p>\n<p>函数的返回值最多只能有一个，void情况下没有返回值。</p>\n<p>​    </p>\n<p>同一个类里，函数可以重名，但是参数不能一样。一样是指参数个数相同，每个位置的参数类型也一样。但参数的名字不算，返回值类型也不算。</p>\n<p>换句话说，函数的<strong>唯一性标示是：类名_函数名_参数2类型_…参数n类型</strong>。</p>\n"},{"title":"函数重载","date":"2021-08-23T09:36:42.000Z","_content":"\n同一个类中函数名字相同但参数不同的现象，一般称为函数重载。\n\n为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但函数个数或类型不一样。\n\n比如，求两个数的最大值，在java的Math库中就定义了四个函数：\n\n![Math库的四个max函数.png](https://i.loli.net/2021/08/23/BpzlJTPda4WvUnx.png)\n\n","source":"_posts/函数重载.md","raw":"---\ntitle: 函数重载\ndate: 2021-08-23 17:36:42\ntags:\n - java\n - function\ncategories: java\n---\n\n同一个类中函数名字相同但参数不同的现象，一般称为函数重载。\n\n为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但函数个数或类型不一样。\n\n比如，求两个数的最大值，在java的Math库中就定义了四个函数：\n\n![Math库的四个max函数.png](https://i.loli.net/2021/08/23/BpzlJTPda4WvUnx.png)\n\n","slug":"函数重载","published":1,"updated":"2021-08-23T09:45:17.234Z","_id":"cksog5rns000008uifraogqoq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>同一个类中函数名字相同但参数不同的现象，一般称为函数重载。</p>\n<p>为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但函数个数或类型不一样。</p>\n<p>比如，求两个数的最大值，在java的Math库中就定义了四个函数：</p>\n<p><img src=\"https://i.loli.net/2021/08/23/BpzlJTPda4WvUnx.png\" alt=\"Math库的四个max函数.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>同一个类中函数名字相同但参数不同的现象，一般称为函数重载。</p>\n<p>为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但函数个数或类型不一样。</p>\n<p>比如，求两个数的最大值，在java的Math库中就定义了四个函数：</p>\n<p><img src=\"https://i.loli.net/2021/08/23/BpzlJTPda4WvUnx.png\" alt=\"Math库的四个max函数.png\"></p>\n"},{"title":"函数递归","date":"2021-08-23T09:45:52.000Z","_content":"\n调用自己的函数，就叫做递归函数。\n\n​     \n\n典型例子：数学中一个数n的阶乘，表示为n!，它的值定义是这样的：\n\n```java\n0! = 1\nn! = (n-1)*n\n```\n\n0的阶乘是1，n的阶乘的值是n-1的阶乘的值乘以n，所以这个定义是一个递归的定义。\n\n为求n的值，需先求n-1的值，直到0，然后一次往回退。\n\n求阶乘的递归函数代码如下:\n\n```java\npublic static long factorial(int n) {\n    if(n==0){\n        return 1;\n    }else{\n        return n*factorial(n-1);\n    }\n}\n```\n\n​    \n\n递归是有开销的，而且使用不当，可能会出现意外的错误。\n\n","source":"_posts/函数递归.md","raw":"---\ntitle: 函数递归\ndate: 2021-08-23 17:45:52\ntags:\n - java\n - function\ncategories: java\n---\n\n调用自己的函数，就叫做递归函数。\n\n​     \n\n典型例子：数学中一个数n的阶乘，表示为n!，它的值定义是这样的：\n\n```java\n0! = 1\nn! = (n-1)*n\n```\n\n0的阶乘是1，n的阶乘的值是n-1的阶乘的值乘以n，所以这个定义是一个递归的定义。\n\n为求n的值，需先求n-1的值，直到0，然后一次往回退。\n\n求阶乘的递归函数代码如下:\n\n```java\npublic static long factorial(int n) {\n    if(n==0){\n        return 1;\n    }else{\n        return n*factorial(n-1);\n    }\n}\n```\n\n​    \n\n递归是有开销的，而且使用不当，可能会出现意外的错误。\n\n","slug":"函数递归","published":1,"updated":"2021-08-23T10:25:40.956Z","_id":"cksohbobg0000nwui24ycb092","comments":1,"layout":"post","photos":[],"link":"","content":"<p>调用自己的函数，就叫做递归函数。</p>\n<p>​     </p>\n<p>典型例子：数学中一个数n的阶乘，表示为n!，它的值定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>! = <span class=\"number\">1</span></span><br><span class=\"line\">n! = (n-<span class=\"number\">1</span>)*n</span><br></pre></td></tr></table></figure>\n\n<p>0的阶乘是1，n的阶乘的值是n-1的阶乘的值乘以n，所以这个定义是一个递归的定义。</p>\n<p>为求n的值，需先求n-1的值，直到0，然后一次往回退。</p>\n<p>求阶乘的递归函数代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>递归是有开销的，而且使用不当，可能会出现意外的错误。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>调用自己的函数，就叫做递归函数。</p>\n<p>​     </p>\n<p>典型例子：数学中一个数n的阶乘，表示为n!，它的值定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>! = <span class=\"number\">1</span></span><br><span class=\"line\">n! = (n-<span class=\"number\">1</span>)*n</span><br></pre></td></tr></table></figure>\n\n<p>0的阶乘是1，n的阶乘的值是n-1的阶乘的值乘以n，所以这个定义是一个递归的定义。</p>\n<p>为求n的值，需先求n-1的值，直到0，然后一次往回退。</p>\n<p>求阶乘的递归函数代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>递归是有开销的，而且使用不当，可能会出现意外的错误。</p>\n"},{"title":"栈","date":"2021-08-23T10:43:57.000Z","_content":"\n函数调用方和函数本身就如何传递参数、如何返回结果、如何跳转指令等问题，使用内存来存放这些数据，并且就如何存放和使用这些数据达成一个一致的协议或约定。\n\n这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫**栈**。\n\n​    \n\n栈是一块内存，顺序是**先进后出**，类似于一个书堆，越晚放上的书越先拿走。\n\n栈的最下面称为栈底，最上面成为栈顶。\n\n往栈底放数据，称为入栈；往栈顶取数据，成为出栈。\n\n栈一般是从高位地址向低位地址扩展，所以**栈底的内存地址是最高的，栈顶的内存地址是最低的**。\n\n​     \n\n**计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，函数内定义的局部变量也放在栈中。**\n\n​    \n\n```java\npublic class Sum {\n    public static int sum(int a,int b) {\n        int c = a + b;\n        return c;\n    }\n    \n    public static void main(String[] args) {\n        int d = Sum.sum(1,2);\n        System.out.println(d);\n    }\n}\n```\n\n上面的代码，概念上：main函数调用了sum函数，计算1+2，然后输出计算结果。\n\n从栈的角度：\n\n(1)当程序在main函数调用Sum.sum函数之前，栈的情况如下表格 \n\n|  地址  | 内容 | 函数 |\n| :----: | :--: | :--: |\n| 0x7FF4 |      |      |\n| 0x7FF8 |      |      |\n| 0x7FFC |  d   | main |\n| 0x8000 | args | main |\n\n栈主要存放了两个变量args(从控制台接收到的参数)和d。\n\n(2)在程序执行到Sum.sum的函数内部，准备return c之前，栈的情况如下表格。\n\n|  地址  |        内容        | 函数 |\n| :----: | :----------------: | :--: |\n|        |                    |      |\n| 0x7FEC |        3(c)        | sum  |\n| 0x7FF0 | 栈中保存的返回地址 | sum  |\n| 0x7FF4 |        2(b)        | sum  |\n| 0x7FF8 |        1(a)        | sum  |\n| 0x7FFC |         d          | main |\n| 0x8000 |        args        | main |\n\nmain函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址入栈，接着跳转到sum函数，在sum函数内部，为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2。在返回之前，返回值3保存到了专门的**返回值存储器**中。\n\n(3)调用return后，程序会跳转到栈中保存的返回地址，sum函数相关的数据会出战，从而又变回(1)中的状态。\n\n|  地址  | 内容 | 函数 |\n| :----: | :--: | :--: |\n| 0x7FF4 |      |      |\n| 0x7FF8 |      |      |\n| 0x7FFC |  d   | main |\n| 0x8000 | args | main |\n\n(4)main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。\n\n​    \n\n​    \n\n函数中的基本数据类型参数和函数内定义的基本数据类型变量，都分配在栈中。这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。\n\n而数组和对象类型，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址。实际的内容一般不是分配在栈上的，而是分配在**堆**中，但存放地址的空间是分配在栈上的。\n\n```java\npublic class ArrayMax {\n    public static int max(int min,int[] arr) {\n        int max = min;\n        for(int a : arr) {\n            if(a > max) {\n                max = a;\n            }\n        }\n        return max;\n    }\n    \n    public static void main(String[] args) {\n        int[] arr = new int[]{2,3,4};\n        int ret = max(0,arr);\n        System.out.println(ret);\n    }\n}\n```\n\n上面的代码，概念上：main函数新建一个数组int[]{2,3,4}，然后调用函数max计算0和数组中元素的最大值，最后打印输出最大值。\n\n从栈的角度：\n\n| 栈-地址 |      栈-内容       | 函数 | 堆-地址 | 堆-内容 |\n| :-----: | :----------------: | :--: | :-----: | :-----: |\n| 0x7FE8  |       max(4)       | max  | 0x1000  |    2    |\n| 0x7EFC  | 栈中保存的返回地址 | max  | 0x1004  |    3    |\n| 0x7FF0  |    0x1000(arr)     | max  | 0x1008  |    4    |\n| 0x7FF4  |       0(min)       | max  |         |         |\n| 0x7FF8  |        ret         | main |         |         |\n| 0x7FFC  |    0x1000(arr)     | main |         |         |\n| 0x8000  |        args        | main |         |         |\n\n对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放。\n\n存放实际内容的堆空间，在函数结束、栈空间没有变量指向它的时候，java系统会自动进行垃圾回收，从而释放这块空间。\n\n​    \n\n栈的空间不是无限的。栈空间过深，系统就会抛出错误——java.lang.StackOverflowError，即栈溢出错误。\n\n","source":"_posts/栈.md","raw":"---\ntitle: 栈\ndate: 2021-08-23 18:43:57\ntags: \n - stack\n - data structure\ncategories: data structure\n---\n\n函数调用方和函数本身就如何传递参数、如何返回结果、如何跳转指令等问题，使用内存来存放这些数据，并且就如何存放和使用这些数据达成一个一致的协议或约定。\n\n这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫**栈**。\n\n​    \n\n栈是一块内存，顺序是**先进后出**，类似于一个书堆，越晚放上的书越先拿走。\n\n栈的最下面称为栈底，最上面成为栈顶。\n\n往栈底放数据，称为入栈；往栈顶取数据，成为出栈。\n\n栈一般是从高位地址向低位地址扩展，所以**栈底的内存地址是最高的，栈顶的内存地址是最低的**。\n\n​     \n\n**计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，函数内定义的局部变量也放在栈中。**\n\n​    \n\n```java\npublic class Sum {\n    public static int sum(int a,int b) {\n        int c = a + b;\n        return c;\n    }\n    \n    public static void main(String[] args) {\n        int d = Sum.sum(1,2);\n        System.out.println(d);\n    }\n}\n```\n\n上面的代码，概念上：main函数调用了sum函数，计算1+2，然后输出计算结果。\n\n从栈的角度：\n\n(1)当程序在main函数调用Sum.sum函数之前，栈的情况如下表格 \n\n|  地址  | 内容 | 函数 |\n| :----: | :--: | :--: |\n| 0x7FF4 |      |      |\n| 0x7FF8 |      |      |\n| 0x7FFC |  d   | main |\n| 0x8000 | args | main |\n\n栈主要存放了两个变量args(从控制台接收到的参数)和d。\n\n(2)在程序执行到Sum.sum的函数内部，准备return c之前，栈的情况如下表格。\n\n|  地址  |        内容        | 函数 |\n| :----: | :----------------: | :--: |\n|        |                    |      |\n| 0x7FEC |        3(c)        | sum  |\n| 0x7FF0 | 栈中保存的返回地址 | sum  |\n| 0x7FF4 |        2(b)        | sum  |\n| 0x7FF8 |        1(a)        | sum  |\n| 0x7FFC |         d          | main |\n| 0x8000 |        args        | main |\n\nmain函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址入栈，接着跳转到sum函数，在sum函数内部，为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2。在返回之前，返回值3保存到了专门的**返回值存储器**中。\n\n(3)调用return后，程序会跳转到栈中保存的返回地址，sum函数相关的数据会出战，从而又变回(1)中的状态。\n\n|  地址  | 内容 | 函数 |\n| :----: | :--: | :--: |\n| 0x7FF4 |      |      |\n| 0x7FF8 |      |      |\n| 0x7FFC |  d   | main |\n| 0x8000 | args | main |\n\n(4)main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。\n\n​    \n\n​    \n\n函数中的基本数据类型参数和函数内定义的基本数据类型变量，都分配在栈中。这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。\n\n而数组和对象类型，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址。实际的内容一般不是分配在栈上的，而是分配在**堆**中，但存放地址的空间是分配在栈上的。\n\n```java\npublic class ArrayMax {\n    public static int max(int min,int[] arr) {\n        int max = min;\n        for(int a : arr) {\n            if(a > max) {\n                max = a;\n            }\n        }\n        return max;\n    }\n    \n    public static void main(String[] args) {\n        int[] arr = new int[]{2,3,4};\n        int ret = max(0,arr);\n        System.out.println(ret);\n    }\n}\n```\n\n上面的代码，概念上：main函数新建一个数组int[]{2,3,4}，然后调用函数max计算0和数组中元素的最大值，最后打印输出最大值。\n\n从栈的角度：\n\n| 栈-地址 |      栈-内容       | 函数 | 堆-地址 | 堆-内容 |\n| :-----: | :----------------: | :--: | :-----: | :-----: |\n| 0x7FE8  |       max(4)       | max  | 0x1000  |    2    |\n| 0x7EFC  | 栈中保存的返回地址 | max  | 0x1004  |    3    |\n| 0x7FF0  |    0x1000(arr)     | max  | 0x1008  |    4    |\n| 0x7FF4  |       0(min)       | max  |         |         |\n| 0x7FF8  |        ret         | main |         |         |\n| 0x7FFC  |    0x1000(arr)     | main |         |         |\n| 0x8000  |        args        | main |         |         |\n\n对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放。\n\n存放实际内容的堆空间，在函数结束、栈空间没有变量指向它的时候，java系统会自动进行垃圾回收，从而释放这块空间。\n\n​    \n\n栈的空间不是无限的。栈空间过深，系统就会抛出错误——java.lang.StackOverflowError，即栈溢出错误。\n\n","slug":"栈","published":1,"updated":"2021-08-26T09:35:41.816Z","_id":"cksoitmkm00010wui92yh7e0b","comments":1,"layout":"post","photos":[],"link":"","content":"<p>函数调用方和函数本身就如何传递参数、如何返回结果、如何跳转指令等问题，使用内存来存放这些数据，并且就如何存放和使用这些数据达成一个一致的协议或约定。</p>\n<p>这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫<strong>栈</strong>。</p>\n<p>​    </p>\n<p>栈是一块内存，顺序是<strong>先进后出</strong>，类似于一个书堆，越晚放上的书越先拿走。</p>\n<p>栈的最下面称为栈底，最上面成为栈顶。</p>\n<p>往栈底放数据，称为入栈；往栈顶取数据，成为出栈。</p>\n<p>栈一般是从高位地址向低位地址扩展，所以<strong>栈底的内存地址是最高的，栈顶的内存地址是最低的</strong>。</p>\n<p>​     </p>\n<p><strong>计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，函数内定义的局部变量也放在栈中。</strong></p>\n<p>​    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = Sum.sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，概念上：main函数调用了sum函数，计算1+2，然后输出计算结果。</p>\n<p>从栈的角度：</p>\n<p>(1)当程序在main函数调用Sum.sum函数之前，栈的情况如下表格 </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">内容</th>\n<th align=\"center\">函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">d</td>\n<td align=\"center\">main</td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n</tr>\n</tbody></table>\n<p>栈主要存放了两个变量args(从控制台接收到的参数)和d。</p>\n<p>(2)在程序执行到Sum.sum的函数内部，准备return c之前，栈的情况如下表格。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">内容</th>\n<th align=\"center\">函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FEC</td>\n<td align=\"center\">3(c)</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF0</td>\n<td align=\"center\">栈中保存的返回地址</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\">2(b)</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\">1(a)</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">d</td>\n<td align=\"center\">main</td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n</tr>\n</tbody></table>\n<p>main函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址入栈，接着跳转到sum函数，在sum函数内部，为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2。在返回之前，返回值3保存到了专门的<strong>返回值存储器</strong>中。</p>\n<p>(3)调用return后，程序会跳转到栈中保存的返回地址，sum函数相关的数据会出战，从而又变回(1)中的状态。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">内容</th>\n<th align=\"center\">函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">d</td>\n<td align=\"center\">main</td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n</tr>\n</tbody></table>\n<p>(4)main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。</p>\n<p>​    </p>\n<p>​    </p>\n<p>函数中的基本数据类型参数和函数内定义的基本数据类型变量，都分配在栈中。这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。</p>\n<p>而数组和对象类型，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址。实际的内容一般不是分配在栈上的，而是分配在<strong>堆</strong>中，但存放地址的空间是分配在栈上的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayMax</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> min,<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = min;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a &gt; max) &#123;</span><br><span class=\"line\">                max = a;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = max(<span class=\"number\">0</span>,arr);</span><br><span class=\"line\">        System.out.println(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，概念上：main函数新建一个数组int[]{2,3,4}，然后调用函数max计算0和数组中元素的最大值，最后打印输出最大值。</p>\n<p>从栈的角度：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">栈-地址</th>\n<th align=\"center\">栈-内容</th>\n<th align=\"center\">函数</th>\n<th align=\"center\">堆-地址</th>\n<th align=\"center\">堆-内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x7FE8</td>\n<td align=\"center\">max(4)</td>\n<td align=\"center\">max</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">0x7EFC</td>\n<td align=\"center\">栈中保存的返回地址</td>\n<td align=\"center\">max</td>\n<td align=\"center\">0x1004</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF0</td>\n<td align=\"center\">0x1000(arr)</td>\n<td align=\"center\">max</td>\n<td align=\"center\">0x1008</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\">0(min)</td>\n<td align=\"center\">max</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\">ret</td>\n<td align=\"center\">main</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">0x1000(arr)</td>\n<td align=\"center\">main</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放。</p>\n<p>存放实际内容的堆空间，在函数结束、栈空间没有变量指向它的时候，java系统会自动进行垃圾回收，从而释放这块空间。</p>\n<p>​    </p>\n<p>栈的空间不是无限的。栈空间过深，系统就会抛出错误——java.lang.StackOverflowError，即栈溢出错误。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>函数调用方和函数本身就如何传递参数、如何返回结果、如何跳转指令等问题，使用内存来存放这些数据，并且就如何存放和使用这些数据达成一个一致的协议或约定。</p>\n<p>这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫<strong>栈</strong>。</p>\n<p>​    </p>\n<p>栈是一块内存，顺序是<strong>先进后出</strong>，类似于一个书堆，越晚放上的书越先拿走。</p>\n<p>栈的最下面称为栈底，最上面成为栈顶。</p>\n<p>往栈底放数据，称为入栈；往栈顶取数据，成为出栈。</p>\n<p>栈一般是从高位地址向低位地址扩展，所以<strong>栈底的内存地址是最高的，栈顶的内存地址是最低的</strong>。</p>\n<p>​     </p>\n<p><strong>计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，函数内定义的局部变量也放在栈中。</strong></p>\n<p>​    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = Sum.sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，概念上：main函数调用了sum函数，计算1+2，然后输出计算结果。</p>\n<p>从栈的角度：</p>\n<p>(1)当程序在main函数调用Sum.sum函数之前，栈的情况如下表格 </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">内容</th>\n<th align=\"center\">函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">d</td>\n<td align=\"center\">main</td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n</tr>\n</tbody></table>\n<p>栈主要存放了两个变量args(从控制台接收到的参数)和d。</p>\n<p>(2)在程序执行到Sum.sum的函数内部，准备return c之前，栈的情况如下表格。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">内容</th>\n<th align=\"center\">函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FEC</td>\n<td align=\"center\">3(c)</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF0</td>\n<td align=\"center\">栈中保存的返回地址</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\">2(b)</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\">1(a)</td>\n<td align=\"center\">sum</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">d</td>\n<td align=\"center\">main</td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n</tr>\n</tbody></table>\n<p>main函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址入栈，接着跳转到sum函数，在sum函数内部，为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2。在返回之前，返回值3保存到了专门的<strong>返回值存储器</strong>中。</p>\n<p>(3)调用return后，程序会跳转到栈中保存的返回地址，sum函数相关的数据会出战，从而又变回(1)中的状态。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">内容</th>\n<th align=\"center\">函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">d</td>\n<td align=\"center\">main</td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n</tr>\n</tbody></table>\n<p>(4)main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。</p>\n<p>​    </p>\n<p>​    </p>\n<p>函数中的基本数据类型参数和函数内定义的基本数据类型变量，都分配在栈中。这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。</p>\n<p>而数组和对象类型，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址。实际的内容一般不是分配在栈上的，而是分配在<strong>堆</strong>中，但存放地址的空间是分配在栈上的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayMax</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> min,<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = min;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a &gt; max) &#123;</span><br><span class=\"line\">                max = a;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = max(<span class=\"number\">0</span>,arr);</span><br><span class=\"line\">        System.out.println(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，概念上：main函数新建一个数组int[]{2,3,4}，然后调用函数max计算0和数组中元素的最大值，最后打印输出最大值。</p>\n<p>从栈的角度：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">栈-地址</th>\n<th align=\"center\">栈-内容</th>\n<th align=\"center\">函数</th>\n<th align=\"center\">堆-地址</th>\n<th align=\"center\">堆-内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x7FE8</td>\n<td align=\"center\">max(4)</td>\n<td align=\"center\">max</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">0x7EFC</td>\n<td align=\"center\">栈中保存的返回地址</td>\n<td align=\"center\">max</td>\n<td align=\"center\">0x1004</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF0</td>\n<td align=\"center\">0x1000(arr)</td>\n<td align=\"center\">max</td>\n<td align=\"center\">0x1008</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF4</td>\n<td align=\"center\">0(min)</td>\n<td align=\"center\">max</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FF8</td>\n<td align=\"center\">ret</td>\n<td align=\"center\">main</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x7FFC</td>\n<td align=\"center\">0x1000(arr)</td>\n<td align=\"center\">main</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">args</td>\n<td align=\"center\">main</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放。</p>\n<p>存放实际内容的堆空间，在函数结束、栈空间没有变量指向它的时候，java系统会自动进行垃圾回收，从而释放这块空间。</p>\n<p>​    </p>\n<p>栈的空间不是无限的。栈空间过深，系统就会抛出错误——java.lang.StackOverflowError，即栈溢出错误。</p>\n"},{"title":"类的定义","date":"2021-08-27T06:22:58.000Z","_content":"\n类既是函数的容器，也用来表示自定义数据类型。\n\n​    \n\n所谓自定义数据类型，就是除了八种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。\n\n一个数据类型，由其包含的属性以及该类型可以进行的操作组成。属性又可以分为是类型本身具有的属性，还是一个具体数据具有的属性。同样，操作也可以分为是类型本身可以进行的操作，还是一个具体数据可以进行的操作。\n\n由此，一个数据类型就主要由四部分组成：\n\n- 类型本身具有的属性，通过类变量体现\n\n- 类型本身可以进行的操作，通过类方法体现\n\n- 类型实例具有的属性，通过实例变量体现\n\n- 类型实例可以进行的操作，通过实例方法体现\n\n​    \n\n**类方法**\n\n**static**表示类方法，又称静态方法。与类方法相对的是实例方法，实例方法没有static修饰符，必须通过实例或者叫对象调用。而类方法可以直接通过类名进行调用，不需要创建实例。\n\n​    \n\n**类变量**\n\n类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。\n\n比如Math类中定义的两个数学常量：\n\n```java\npublic static final double E = 2.7182818284590452354;\npublic static final double PI = 3.14159265358979323846;\n```\n\n**static**表示是类变量。与类变量相对的是实例变量，没有static修饰符。\n\nfinal表示变量被赋值后，就不能再修改了。\n\n\n\n**实例变量**\n\n实例变量表示具体的实例所具有的属性。与基本类型对比， int a;这个语句，int就是类型，a就是实例。\n\n​    \n\n**实例方法**\n\n实例方法表示具体的实例可以进行的操作。\n\n在实例方法中，有一个隐含的参数(this)，这个参数就是当前操作的实例自己，它直接操作方法和变量。\n\n- 类方法只能访问类变量，但不能访问实例变量。可以调用其他的类方法，但不能调用实例方法。\n- 实例方法既能访问实例变量，也可以访问类变量。既可以调用实例方法，也可以调用类方法。\n\n\n\nclass变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们都称为**引用类型**的变量。\n\n​    \n\n通过对象来访问和操作其内部的数据是一种基本的面向对象思维。\n\n​    \n\n定义一个合格的类，实例变量是private属性，通过实例方法来操作实例变量。代码如下：\n\n```java\nclass Point {\n    private int x;\n    private int y;\n    \n    public void setX(int x) {\n        this.x = x;\n    }\n    \n    public void setY(int y) {\n        this.y = y;\n    }\n    \n    public int getX() {\n        return x;\n    }\n    \n    public int getY() {\n        return y;\n    }\n    \n    public double distance() {\n        return Math.sqrt(x*x + y*y);\n    }\n}\n```\n\n**this**关键字表示当前实例，实例方法中隐含的参数就是this。\n\n在语句this.x=x;中，this.x表示实例变量x，右边的x表示方法参数中的x。\n\n使用这个类的代码如下：\n\n```java\npublic static void main(String[] args) {\n    Point p = new Point();\n    p.setX(2);\n    p.setY(3);\n    System.out.println(p.distance());\n}\n```\n\n将对实例变量的直接访问改为了方法调用。\n\n​    \n\n**引入构造方法**\n\n```java\npublic Point() { //调用第二个构造方法\n    this(2,3);\n}\n\npublic Point(int x,int y) {\n    this.x=x;\n    this.y=y;\n}\n```\n\n上面代码中的两个方法就是构造方法，构造方法可以有多个。\n\n构造方法的特殊之处：\n\n- 名称是固定的，与类名相同。\n\n- 不能有返回值。\n\nthis不仅可以访问实例变量，还可以**在构造方法中调用其他方法**，这个this调用必须放在第一行。\n\n\n\n","source":"_posts/类的定义.md","raw":"---\ntitle: 类的定义\ndate: 2021-08-27 14:22:58\ntags:\n - java\n - class\ncategories: java\n---\n\n类既是函数的容器，也用来表示自定义数据类型。\n\n​    \n\n所谓自定义数据类型，就是除了八种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。\n\n一个数据类型，由其包含的属性以及该类型可以进行的操作组成。属性又可以分为是类型本身具有的属性，还是一个具体数据具有的属性。同样，操作也可以分为是类型本身可以进行的操作，还是一个具体数据可以进行的操作。\n\n由此，一个数据类型就主要由四部分组成：\n\n- 类型本身具有的属性，通过类变量体现\n\n- 类型本身可以进行的操作，通过类方法体现\n\n- 类型实例具有的属性，通过实例变量体现\n\n- 类型实例可以进行的操作，通过实例方法体现\n\n​    \n\n**类方法**\n\n**static**表示类方法，又称静态方法。与类方法相对的是实例方法，实例方法没有static修饰符，必须通过实例或者叫对象调用。而类方法可以直接通过类名进行调用，不需要创建实例。\n\n​    \n\n**类变量**\n\n类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。\n\n比如Math类中定义的两个数学常量：\n\n```java\npublic static final double E = 2.7182818284590452354;\npublic static final double PI = 3.14159265358979323846;\n```\n\n**static**表示是类变量。与类变量相对的是实例变量，没有static修饰符。\n\nfinal表示变量被赋值后，就不能再修改了。\n\n\n\n**实例变量**\n\n实例变量表示具体的实例所具有的属性。与基本类型对比， int a;这个语句，int就是类型，a就是实例。\n\n​    \n\n**实例方法**\n\n实例方法表示具体的实例可以进行的操作。\n\n在实例方法中，有一个隐含的参数(this)，这个参数就是当前操作的实例自己，它直接操作方法和变量。\n\n- 类方法只能访问类变量，但不能访问实例变量。可以调用其他的类方法，但不能调用实例方法。\n- 实例方法既能访问实例变量，也可以访问类变量。既可以调用实例方法，也可以调用类方法。\n\n\n\nclass变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们都称为**引用类型**的变量。\n\n​    \n\n通过对象来访问和操作其内部的数据是一种基本的面向对象思维。\n\n​    \n\n定义一个合格的类，实例变量是private属性，通过实例方法来操作实例变量。代码如下：\n\n```java\nclass Point {\n    private int x;\n    private int y;\n    \n    public void setX(int x) {\n        this.x = x;\n    }\n    \n    public void setY(int y) {\n        this.y = y;\n    }\n    \n    public int getX() {\n        return x;\n    }\n    \n    public int getY() {\n        return y;\n    }\n    \n    public double distance() {\n        return Math.sqrt(x*x + y*y);\n    }\n}\n```\n\n**this**关键字表示当前实例，实例方法中隐含的参数就是this。\n\n在语句this.x=x;中，this.x表示实例变量x，右边的x表示方法参数中的x。\n\n使用这个类的代码如下：\n\n```java\npublic static void main(String[] args) {\n    Point p = new Point();\n    p.setX(2);\n    p.setY(3);\n    System.out.println(p.distance());\n}\n```\n\n将对实例变量的直接访问改为了方法调用。\n\n​    \n\n**引入构造方法**\n\n```java\npublic Point() { //调用第二个构造方法\n    this(2,3);\n}\n\npublic Point(int x,int y) {\n    this.x=x;\n    this.y=y;\n}\n```\n\n上面代码中的两个方法就是构造方法，构造方法可以有多个。\n\n构造方法的特殊之处：\n\n- 名称是固定的，与类名相同。\n\n- 不能有返回值。\n\nthis不仅可以访问实例变量，还可以**在构造方法中调用其他方法**，这个this调用必须放在第一行。\n\n\n\n","slug":"类的定义","published":1,"updated":"2021-08-31T03:43:37.894Z","_id":"cksu7uhiv00002wui9vbe8g0i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>类既是函数的容器，也用来表示自定义数据类型。</p>\n<p>​    </p>\n<p>所谓自定义数据类型，就是除了八种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。</p>\n<p>一个数据类型，由其包含的属性以及该类型可以进行的操作组成。属性又可以分为是类型本身具有的属性，还是一个具体数据具有的属性。同样，操作也可以分为是类型本身可以进行的操作，还是一个具体数据可以进行的操作。</p>\n<p>由此，一个数据类型就主要由四部分组成：</p>\n<ul>\n<li><p>类型本身具有的属性，通过类变量体现</p>\n</li>\n<li><p>类型本身可以进行的操作，通过类方法体现</p>\n</li>\n<li><p>类型实例具有的属性，通过实例变量体现</p>\n</li>\n<li><p>类型实例可以进行的操作，通过实例方法体现</p>\n</li>\n</ul>\n<p>​    </p>\n<p><strong>类方法</strong></p>\n<p><strong>static</strong>表示类方法，又称静态方法。与类方法相对的是实例方法，实例方法没有static修饰符，必须通过实例或者叫对象调用。而类方法可以直接通过类名进行调用，不需要创建实例。</p>\n<p>​    </p>\n<p><strong>类变量</strong></p>\n<p>类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。</p>\n<p>比如Math类中定义的两个数学常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> E = <span class=\"number\">2.7182818284590452354</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>static</strong>表示是类变量。与类变量相对的是实例变量，没有static修饰符。</p>\n<p>final表示变量被赋值后，就不能再修改了。</p>\n<p><strong>实例变量</strong></p>\n<p>实例变量表示具体的实例所具有的属性。与基本类型对比， int a;这个语句，int就是类型，a就是实例。</p>\n<p>​    </p>\n<p><strong>实例方法</strong></p>\n<p>实例方法表示具体的实例可以进行的操作。</p>\n<p>在实例方法中，有一个隐含的参数(this)，这个参数就是当前操作的实例自己，它直接操作方法和变量。</p>\n<ul>\n<li>类方法只能访问类变量，但不能访问实例变量。可以调用其他的类方法，但不能调用实例方法。</li>\n<li>实例方法既能访问实例变量，也可以访问类变量。既可以调用实例方法，也可以调用类方法。</li>\n</ul>\n<p>class变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们都称为<strong>引用类型</strong>的变量。</p>\n<p>​    </p>\n<p>通过对象来访问和操作其内部的数据是一种基本的面向对象思维。</p>\n<p>​    </p>\n<p>定义一个合格的类，实例变量是private属性，通过实例方法来操作实例变量。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setX</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setY</span><span class=\"params\">(<span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(x*x + y*y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>this</strong>关键字表示当前实例，实例方法中隐含的参数就是this。</p>\n<p>在语句this.x=x;中，this.x表示实例变量x，右边的x表示方法参数中的x。</p>\n<p>使用这个类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Point p = <span class=\"keyword\">new</span> Point();</span><br><span class=\"line\">    p.setX(<span class=\"number\">2</span>);</span><br><span class=\"line\">    p.setY(<span class=\"number\">3</span>);</span><br><span class=\"line\">    System.out.println(p.distance());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将对实例变量的直接访问改为了方法调用。</p>\n<p>​    </p>\n<p><strong>引入构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//调用第二个构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x=x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y=y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的两个方法就是构造方法，构造方法可以有多个。</p>\n<p>构造方法的特殊之处：</p>\n<ul>\n<li><p>名称是固定的，与类名相同。</p>\n</li>\n<li><p>不能有返回值。</p>\n</li>\n</ul>\n<p>this不仅可以访问实例变量，还可以<strong>在构造方法中调用其他方法</strong>，这个this调用必须放在第一行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>类既是函数的容器，也用来表示自定义数据类型。</p>\n<p>​    </p>\n<p>所谓自定义数据类型，就是除了八种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。</p>\n<p>一个数据类型，由其包含的属性以及该类型可以进行的操作组成。属性又可以分为是类型本身具有的属性，还是一个具体数据具有的属性。同样，操作也可以分为是类型本身可以进行的操作，还是一个具体数据可以进行的操作。</p>\n<p>由此，一个数据类型就主要由四部分组成：</p>\n<ul>\n<li><p>类型本身具有的属性，通过类变量体现</p>\n</li>\n<li><p>类型本身可以进行的操作，通过类方法体现</p>\n</li>\n<li><p>类型实例具有的属性，通过实例变量体现</p>\n</li>\n<li><p>类型实例可以进行的操作，通过实例方法体现</p>\n</li>\n</ul>\n<p>​    </p>\n<p><strong>类方法</strong></p>\n<p><strong>static</strong>表示类方法，又称静态方法。与类方法相对的是实例方法，实例方法没有static修饰符，必须通过实例或者叫对象调用。而类方法可以直接通过类名进行调用，不需要创建实例。</p>\n<p>​    </p>\n<p><strong>类变量</strong></p>\n<p>类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。</p>\n<p>比如Math类中定义的两个数学常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> E = <span class=\"number\">2.7182818284590452354</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>static</strong>表示是类变量。与类变量相对的是实例变量，没有static修饰符。</p>\n<p>final表示变量被赋值后，就不能再修改了。</p>\n<p><strong>实例变量</strong></p>\n<p>实例变量表示具体的实例所具有的属性。与基本类型对比， int a;这个语句，int就是类型，a就是实例。</p>\n<p>​    </p>\n<p><strong>实例方法</strong></p>\n<p>实例方法表示具体的实例可以进行的操作。</p>\n<p>在实例方法中，有一个隐含的参数(this)，这个参数就是当前操作的实例自己，它直接操作方法和变量。</p>\n<ul>\n<li>类方法只能访问类变量，但不能访问实例变量。可以调用其他的类方法，但不能调用实例方法。</li>\n<li>实例方法既能访问实例变量，也可以访问类变量。既可以调用实例方法，也可以调用类方法。</li>\n</ul>\n<p>class变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们都称为<strong>引用类型</strong>的变量。</p>\n<p>​    </p>\n<p>通过对象来访问和操作其内部的数据是一种基本的面向对象思维。</p>\n<p>​    </p>\n<p>定义一个合格的类，实例变量是private属性，通过实例方法来操作实例变量。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setX</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setY</span><span class=\"params\">(<span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(x*x + y*y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>this</strong>关键字表示当前实例，实例方法中隐含的参数就是this。</p>\n<p>在语句this.x=x;中，this.x表示实例变量x，右边的x表示方法参数中的x。</p>\n<p>使用这个类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Point p = <span class=\"keyword\">new</span> Point();</span><br><span class=\"line\">    p.setX(<span class=\"number\">2</span>);</span><br><span class=\"line\">    p.setY(<span class=\"number\">3</span>);</span><br><span class=\"line\">    System.out.println(p.distance());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将对实例变量的直接访问改为了方法调用。</p>\n<p>​    </p>\n<p><strong>引入构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//调用第二个构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x=x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y=y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的两个方法就是构造方法，构造方法可以有多个。</p>\n<p>构造方法的特殊之处：</p>\n<ul>\n<li><p>名称是固定的，与类名相同。</p>\n</li>\n<li><p>不能有返回值。</p>\n</li>\n</ul>\n<p>this不仅可以访问实例变量，还可以<strong>在构造方法中调用其他方法</strong>，这个this调用必须放在第一行。</p>\n"},{"title":"类的组合","date":"2021-08-31T03:56:32.000Z","_content":"\n**基础类**\n\n**String**是Java API中的一个类，表示多个字符。它内部是一个char的数组，提供了若干方法用于方便操作字符串。\n\nString可以用一个字符串常量初始化，必须是双引号。\n\n​    \n\n**Date**是Java API中的一个类，表示日期和时间。它内部是一个long类型的值，提供了若干方法用于操作日期和时间。\n\n```java\nDate now = new Date();\n```\n\n如上面代码，用无参的构造方法创建一个Date对象，这个对象就表示当前时间。\n\n​    \n\n​    \n\n**图形类**\n\n先扩展一下《类的定义》一章中的Point类，为它添加一个“计算改点到另一个点的距离”的方法。\n\n```java\npublic double distance(Point p) {\n    return Math.sqrt(Math.pow(x-p.getX(),2)+\n                     Math.pow(y-p.getY(),2));\n}\n```\n\n设计一个表示**线 - Line**的类，其中类的属性含有Point类。\n\n```java\npublic class Line {\n    private Point start;\n    private Point end;\n    \n    public Line(Point start,Point end) {\n        this.start = start;\n        this.end = end;\n    }\n    \n    public double length() {\n        return start.distance(end);\n    }\n}\n```\n\nLine由两个Point组成，在创建Line时需要两个Point。\n\n使用这个类的代码如下：\n\n```java\npublic static void main(String[] args) {\n    Point start = new Point(2,3);\n    Point end = new Point(3,4);\n    \n    Line line = new Line(start,end);\n    System.out.println(Line.length());\n}\n```\n\n​    \n\n​    \n\n**电商概念**\n\n尝试用类描述一下电商系统中的一些基本概念。\n\n电商系统中最基本的有产品、用户和订单：\n\n- 产品：有产品唯一Id、名称、描述、图片、价格等属性。\n\n- 用户：有用户名、密码等属性。\n\n- 订单：有订单号、下单用户、选购产品列表及数量、下单时间、收货人、收货地址、联系电话、订单状态等属性。\n\n产品Product类的代码如下：\n\n```java\npublic class Product {\n    //唯一id\n    private String id;\n    \n    //产品名称\n    private String name;\n    \n    //产品图片链接\n    private String pictureUrl;\n    \n    //产品描述\n    private String description;\n    \n    //产品价格\n    private double price;\n}\n```\n\n用户User类的代码如下：\n\n```java\npublic class User {\n\tprivate String name;\n    private String password;\n}\n```\n\n订单条目OrderItem类来描述单个产品及选购的数量，代码如下：\n\n```java\npublic class OrderItem {\n    //购买产品\n    private Product product;\n    \n    //购买数量\n    private int quantity;\n    \n    public OrderItem(Product product,int quantity) {\n        this.product = productl;\n        this.quantity = quantity;\n    }\n    \n    //合计价格\n    public double computePrice() {\n        return product.getPrice()*quantity;\n    }\n}\n```\n\n最后是包含全部属性的订单Order类，代码如下：\n\n```java\npublic class Order {\n    //订单号\n    private String id;\n    \n    //购买用户\n    private User user;\n    \n    //购买产品列表及数量\n    private OrderItem[] items;\n    \n    //下单时间\n    private Date createtime;\n    \n    //收货人\n    private String receiver;\n    \n    //收货地址\n    private String address;\n    \n    //联系电话\n    private String phone;\n    \n    //订单状态\n    private String status;\n    \n    public double computeTotalPrice() {\n        double totalPrice = 0;\n        if(items != null) {\n            for(OrderItem item : items) {\n                totalPrice+=item.computePrice(); //计算总金额\n            }\n        }\n    }\n}\n```\n\nOrder类引用了User类，以及一个订单条目的数组items，定义了一个计算总价的方法。\n\n​    \n\n​    \n\n**引用自己的类**\n\n一个类定义中还可以引用它自己。\n\n比如想要描述人以及人之间的血缘关系，用Person类表示一个人，它的实例成员包括其父母孩子，这些成员也都是Person类型。\n\n代码如下：\n\n```java\npublic class Person {\n    //姓名\n    private String name;\n    \n    //父亲\n    private Person father;\n    \n    //母亲\n    private Person mother;\n    \n    //孩子数组\n    private Person[] children;\n    \n    public Person(String name) {\n        this.name = name;\n    }\n}\n```\n\n使用代码如下：\n\n```java\npublic static void main(String[] args) {\n    Person daZhongMa = new Person(\"大仲马\");\n    Person xiaoZhongMa = new Person(\"小仲马\");\n    \n    xiaoZhongMa.setFather(daZhongMa);\n    daZhongMa.setChildren(new Person[]{xiaoZhongMa});\n    \n    System.out.println(xiaoZhongMa.getFather().getName());\n}\n```\n\n上面代码先创建了大仲马，然后创建了小仲马，接着调用xiaozhongma的setFather()和dazhongma的setChildren()，设置了父子关系。\n\n| 栈-地址 | 栈-内容 | 堆-地址 | 堆-内容 |         含义         |\n| :-----: | :-----: | :-----: | :-----: | :------------------: |\n| 0x8000  | 0x1000  | 0x1000  | 小仲马  |   xiaoZhongMa.name   |\n|         |         | 0x1004  | 0x1010  |  xiaoZhongMa.father  |\n|         |         | 0x1008  |  null   |  xiaoZhongMa.mother  |\n|         |         | 0x100C  |  null   | xiaoZhongMa.children |\n| 0x8008  | 0x1010  | 0x1010  | 大仲马  |    daZhongMa.name    |\n|         |         | 0x1014  |  null   |   daZhongMa.father   |\n|         |         | 0x1018  |  null   |   daZhongMa.mother   |\n|         |         | 0x101C  | 0x1000  |  daZhongMa.children  |\n\n​    \n\n​    \n\n**互相引用的类**\n\n定义两个类MyFile和MyFolder，分别表示文件和文件夹。\n\n文件和文件夹都有名称、创建时间、父文件夹，根文件夹没有父文件夹，文件夹还有子文件列表和子文件夹列表。\n\n文件MyFile类代码如下：\n\n```java\npublic class MyFile {\n    //文件名称\n    private String name;\n    \n    //创建时间\n    private Date createtime;\n    \n    //文件大小\n    private int size;\n    \n    //上级目录\n    private MyFolder parent;\n    \n    public int getSize() {\n        return size;\n    }\n}\n```\n\n文件夹MyFolder类的代码如下：\n\n```java\npublic class MyFolder {\n    //文件夹名称\n    private String name;\n    \n    //创建时间\n    private Date createtime;\n    \n    //上级文件夹\n    private MyFolder parent;\n    \n    //包含的文件\n    private MyFile[] files;\n    \n    //包含的子文件夹\n    private MyFolder[] subFolders;\n    \n    public int totalSize() {\n        int totalSize = 0;\n        if (files != null) {\n            for(MyFile file : files) {\n                totalSize+=file.getSize(); \n            }\n        }\n        if(subFolders != null) {\n            for(MyFolder folder : subFolders) {\n                totalSize+=folder.totalSize(); //计算子文件夹的size\n            }\n        }\n        \n        return totalSize;\n    }\n}\n```\n\nMyFile引用了MyFolder，MyFolder也引用了MyFile，两者组合互相引用。\n","source":"_posts/类的组合.md","raw":"---\ntitle: 类的组合\ndate: 2021-08-31 11:56:32\ntags:\n - java\n - class\ncategories: java\n---\n\n**基础类**\n\n**String**是Java API中的一个类，表示多个字符。它内部是一个char的数组，提供了若干方法用于方便操作字符串。\n\nString可以用一个字符串常量初始化，必须是双引号。\n\n​    \n\n**Date**是Java API中的一个类，表示日期和时间。它内部是一个long类型的值，提供了若干方法用于操作日期和时间。\n\n```java\nDate now = new Date();\n```\n\n如上面代码，用无参的构造方法创建一个Date对象，这个对象就表示当前时间。\n\n​    \n\n​    \n\n**图形类**\n\n先扩展一下《类的定义》一章中的Point类，为它添加一个“计算改点到另一个点的距离”的方法。\n\n```java\npublic double distance(Point p) {\n    return Math.sqrt(Math.pow(x-p.getX(),2)+\n                     Math.pow(y-p.getY(),2));\n}\n```\n\n设计一个表示**线 - Line**的类，其中类的属性含有Point类。\n\n```java\npublic class Line {\n    private Point start;\n    private Point end;\n    \n    public Line(Point start,Point end) {\n        this.start = start;\n        this.end = end;\n    }\n    \n    public double length() {\n        return start.distance(end);\n    }\n}\n```\n\nLine由两个Point组成，在创建Line时需要两个Point。\n\n使用这个类的代码如下：\n\n```java\npublic static void main(String[] args) {\n    Point start = new Point(2,3);\n    Point end = new Point(3,4);\n    \n    Line line = new Line(start,end);\n    System.out.println(Line.length());\n}\n```\n\n​    \n\n​    \n\n**电商概念**\n\n尝试用类描述一下电商系统中的一些基本概念。\n\n电商系统中最基本的有产品、用户和订单：\n\n- 产品：有产品唯一Id、名称、描述、图片、价格等属性。\n\n- 用户：有用户名、密码等属性。\n\n- 订单：有订单号、下单用户、选购产品列表及数量、下单时间、收货人、收货地址、联系电话、订单状态等属性。\n\n产品Product类的代码如下：\n\n```java\npublic class Product {\n    //唯一id\n    private String id;\n    \n    //产品名称\n    private String name;\n    \n    //产品图片链接\n    private String pictureUrl;\n    \n    //产品描述\n    private String description;\n    \n    //产品价格\n    private double price;\n}\n```\n\n用户User类的代码如下：\n\n```java\npublic class User {\n\tprivate String name;\n    private String password;\n}\n```\n\n订单条目OrderItem类来描述单个产品及选购的数量，代码如下：\n\n```java\npublic class OrderItem {\n    //购买产品\n    private Product product;\n    \n    //购买数量\n    private int quantity;\n    \n    public OrderItem(Product product,int quantity) {\n        this.product = productl;\n        this.quantity = quantity;\n    }\n    \n    //合计价格\n    public double computePrice() {\n        return product.getPrice()*quantity;\n    }\n}\n```\n\n最后是包含全部属性的订单Order类，代码如下：\n\n```java\npublic class Order {\n    //订单号\n    private String id;\n    \n    //购买用户\n    private User user;\n    \n    //购买产品列表及数量\n    private OrderItem[] items;\n    \n    //下单时间\n    private Date createtime;\n    \n    //收货人\n    private String receiver;\n    \n    //收货地址\n    private String address;\n    \n    //联系电话\n    private String phone;\n    \n    //订单状态\n    private String status;\n    \n    public double computeTotalPrice() {\n        double totalPrice = 0;\n        if(items != null) {\n            for(OrderItem item : items) {\n                totalPrice+=item.computePrice(); //计算总金额\n            }\n        }\n    }\n}\n```\n\nOrder类引用了User类，以及一个订单条目的数组items，定义了一个计算总价的方法。\n\n​    \n\n​    \n\n**引用自己的类**\n\n一个类定义中还可以引用它自己。\n\n比如想要描述人以及人之间的血缘关系，用Person类表示一个人，它的实例成员包括其父母孩子，这些成员也都是Person类型。\n\n代码如下：\n\n```java\npublic class Person {\n    //姓名\n    private String name;\n    \n    //父亲\n    private Person father;\n    \n    //母亲\n    private Person mother;\n    \n    //孩子数组\n    private Person[] children;\n    \n    public Person(String name) {\n        this.name = name;\n    }\n}\n```\n\n使用代码如下：\n\n```java\npublic static void main(String[] args) {\n    Person daZhongMa = new Person(\"大仲马\");\n    Person xiaoZhongMa = new Person(\"小仲马\");\n    \n    xiaoZhongMa.setFather(daZhongMa);\n    daZhongMa.setChildren(new Person[]{xiaoZhongMa});\n    \n    System.out.println(xiaoZhongMa.getFather().getName());\n}\n```\n\n上面代码先创建了大仲马，然后创建了小仲马，接着调用xiaozhongma的setFather()和dazhongma的setChildren()，设置了父子关系。\n\n| 栈-地址 | 栈-内容 | 堆-地址 | 堆-内容 |         含义         |\n| :-----: | :-----: | :-----: | :-----: | :------------------: |\n| 0x8000  | 0x1000  | 0x1000  | 小仲马  |   xiaoZhongMa.name   |\n|         |         | 0x1004  | 0x1010  |  xiaoZhongMa.father  |\n|         |         | 0x1008  |  null   |  xiaoZhongMa.mother  |\n|         |         | 0x100C  |  null   | xiaoZhongMa.children |\n| 0x8008  | 0x1010  | 0x1010  | 大仲马  |    daZhongMa.name    |\n|         |         | 0x1014  |  null   |   daZhongMa.father   |\n|         |         | 0x1018  |  null   |   daZhongMa.mother   |\n|         |         | 0x101C  | 0x1000  |  daZhongMa.children  |\n\n​    \n\n​    \n\n**互相引用的类**\n\n定义两个类MyFile和MyFolder，分别表示文件和文件夹。\n\n文件和文件夹都有名称、创建时间、父文件夹，根文件夹没有父文件夹，文件夹还有子文件列表和子文件夹列表。\n\n文件MyFile类代码如下：\n\n```java\npublic class MyFile {\n    //文件名称\n    private String name;\n    \n    //创建时间\n    private Date createtime;\n    \n    //文件大小\n    private int size;\n    \n    //上级目录\n    private MyFolder parent;\n    \n    public int getSize() {\n        return size;\n    }\n}\n```\n\n文件夹MyFolder类的代码如下：\n\n```java\npublic class MyFolder {\n    //文件夹名称\n    private String name;\n    \n    //创建时间\n    private Date createtime;\n    \n    //上级文件夹\n    private MyFolder parent;\n    \n    //包含的文件\n    private MyFile[] files;\n    \n    //包含的子文件夹\n    private MyFolder[] subFolders;\n    \n    public int totalSize() {\n        int totalSize = 0;\n        if (files != null) {\n            for(MyFile file : files) {\n                totalSize+=file.getSize(); \n            }\n        }\n        if(subFolders != null) {\n            for(MyFolder folder : subFolders) {\n                totalSize+=folder.totalSize(); //计算子文件夹的size\n            }\n        }\n        \n        return totalSize;\n    }\n}\n```\n\nMyFile引用了MyFolder，MyFolder也引用了MyFile，两者组合互相引用。\n","slug":"类的组合","published":1,"updated":"2021-09-15T07:24:02.996Z","_id":"ckszp1bjb00000guiczys6xp4","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>基础类</strong></p>\n<p><strong>String</strong>是Java API中的一个类，表示多个字符。它内部是一个char的数组，提供了若干方法用于方便操作字符串。</p>\n<p>String可以用一个字符串常量初始化，必须是双引号。</p>\n<p>​    </p>\n<p><strong>Date</strong>是Java API中的一个类，表示日期和时间。它内部是一个long类型的值，提供了若干方法用于操作日期和时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date now = <span class=\"keyword\">new</span> Date();</span><br></pre></td></tr></table></figure>\n\n<p>如上面代码，用无参的构造方法创建一个Date对象，这个对象就表示当前时间。</p>\n<p>​    </p>\n<p>​    </p>\n<p><strong>图形类</strong></p>\n<p>先扩展一下《类的定义》一章中的Point类，为它添加一个“计算改点到另一个点的距离”的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distance</span><span class=\"params\">(Point p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.sqrt(Math.pow(x-p.getX(),<span class=\"number\">2</span>)+</span><br><span class=\"line\">                     Math.pow(y-p.getY(),<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设计一个表示<strong>线 - Line</strong>的类，其中类的属性含有Point类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point end;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Line</span><span class=\"params\">(Point start,Point end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">length</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start.distance(end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Line由两个Point组成，在创建Line时需要两个Point。</p>\n<p>使用这个类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Point start = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    Point end = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Line line = <span class=\"keyword\">new</span> Line(start,end);</span><br><span class=\"line\">    System.out.println(Line.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>​    </p>\n<p><strong>电商概念</strong></p>\n<p>尝试用类描述一下电商系统中的一些基本概念。</p>\n<p>电商系统中最基本的有产品、用户和订单：</p>\n<ul>\n<li><p>产品：有产品唯一Id、名称、描述、图片、价格等属性。</p>\n</li>\n<li><p>用户：有用户名、密码等属性。</p>\n</li>\n<li><p>订单：有订单号、下单用户、选购产品列表及数量、下单时间、收货人、收货地址、联系电话、订单状态等属性。</p>\n</li>\n</ul>\n<p>产品Product类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品图片链接</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String pictureUrl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品描述</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String description;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品价格</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> price;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户User类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>订单条目OrderItem类来描述单个产品及选购的数量，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//购买产品</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Product product;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//购买数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> quantity;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrderItem</span><span class=\"params\">(Product product,<span class=\"keyword\">int</span> quantity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.product = productl;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.quantity = quantity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//合计价格</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">computePrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> product.getPrice()*quantity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是包含全部属性的订单Order类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//订单号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//购买用户</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> User user;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//购买产品列表及数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderItem[] items;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//下单时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createtime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//收货人</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String receiver;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//收货地址</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String address;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//联系电话</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//订单状态</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String status;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">computeTotalPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> totalPrice = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(items != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(OrderItem item : items) &#123;</span><br><span class=\"line\">                totalPrice+=item.computePrice(); <span class=\"comment\">//计算总金额</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Order类引用了User类，以及一个订单条目的数组items，定义了一个计算总价的方法。</p>\n<p>​    </p>\n<p>​    </p>\n<p><strong>引用自己的类</strong></p>\n<p>一个类定义中还可以引用它自己。</p>\n<p>比如想要描述人以及人之间的血缘关系，用Person类表示一个人，它的实例成员包括其父母孩子，这些成员也都是Person类型。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//父亲</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person father;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//母亲</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person mother;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//孩子数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person[] children;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Person daZhongMa = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;大仲马&quot;</span>);</span><br><span class=\"line\">    Person xiaoZhongMa = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;小仲马&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    xiaoZhongMa.setFather(daZhongMa);</span><br><span class=\"line\">    daZhongMa.setChildren(<span class=\"keyword\">new</span> Person[]&#123;xiaoZhongMa&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    System.out.println(xiaoZhongMa.getFather().getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码先创建了大仲马，然后创建了小仲马，接着调用xiaozhongma的setFather()和dazhongma的setChildren()，设置了父子关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">栈-地址</th>\n<th align=\"center\">栈-内容</th>\n<th align=\"center\">堆-地址</th>\n<th align=\"center\">堆-内容</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">小仲马</td>\n<td align=\"center\">xiaoZhongMa.name</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1004</td>\n<td align=\"center\">0x1010</td>\n<td align=\"center\">xiaoZhongMa.father</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1008</td>\n<td align=\"center\">null</td>\n<td align=\"center\">xiaoZhongMa.mother</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x100C</td>\n<td align=\"center\">null</td>\n<td align=\"center\">xiaoZhongMa.children</td>\n</tr>\n<tr>\n<td align=\"center\">0x8008</td>\n<td align=\"center\">0x1010</td>\n<td align=\"center\">0x1010</td>\n<td align=\"center\">大仲马</td>\n<td align=\"center\">daZhongMa.name</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1014</td>\n<td align=\"center\">null</td>\n<td align=\"center\">daZhongMa.father</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1018</td>\n<td align=\"center\">null</td>\n<td align=\"center\">daZhongMa.mother</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x101C</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">daZhongMa.children</td>\n</tr>\n</tbody></table>\n<p>​    </p>\n<p>​    </p>\n<p><strong>互相引用的类</strong></p>\n<p>定义两个类MyFile和MyFolder，分别表示文件和文件夹。</p>\n<p>文件和文件夹都有名称、创建时间、父文件夹，根文件夹没有父文件夹，文件夹还有子文件列表和子文件夹列表。</p>\n<p>文件MyFile类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFile</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文件名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createtime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//文件大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//上级目录</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFolder parent;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>文件夹MyFolder类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFolder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文件夹名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createtime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//上级文件夹</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFolder parent;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//包含的文件</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFile[] files;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//包含的子文件夹</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFolder[] subFolders;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">totalSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (files != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(MyFile file : files) &#123;</span><br><span class=\"line\">                totalSize+=file.getSize(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(subFolders != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(MyFolder folder : subFolders) &#123;</span><br><span class=\"line\">                totalSize+=folder.totalSize(); <span class=\"comment\">//计算子文件夹的size</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>MyFile引用了MyFolder，MyFolder也引用了MyFile，两者组合互相引用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>基础类</strong></p>\n<p><strong>String</strong>是Java API中的一个类，表示多个字符。它内部是一个char的数组，提供了若干方法用于方便操作字符串。</p>\n<p>String可以用一个字符串常量初始化，必须是双引号。</p>\n<p>​    </p>\n<p><strong>Date</strong>是Java API中的一个类，表示日期和时间。它内部是一个long类型的值，提供了若干方法用于操作日期和时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date now = <span class=\"keyword\">new</span> Date();</span><br></pre></td></tr></table></figure>\n\n<p>如上面代码，用无参的构造方法创建一个Date对象，这个对象就表示当前时间。</p>\n<p>​    </p>\n<p>​    </p>\n<p><strong>图形类</strong></p>\n<p>先扩展一下《类的定义》一章中的Point类，为它添加一个“计算改点到另一个点的距离”的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distance</span><span class=\"params\">(Point p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.sqrt(Math.pow(x-p.getX(),<span class=\"number\">2</span>)+</span><br><span class=\"line\">                     Math.pow(y-p.getY(),<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设计一个表示<strong>线 - Line</strong>的类，其中类的属性含有Point类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point end;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Line</span><span class=\"params\">(Point start,Point end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">length</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start.distance(end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Line由两个Point组成，在创建Line时需要两个Point。</p>\n<p>使用这个类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Point start = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    Point end = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Line line = <span class=\"keyword\">new</span> Line(start,end);</span><br><span class=\"line\">    System.out.println(Line.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>​    </p>\n<p><strong>电商概念</strong></p>\n<p>尝试用类描述一下电商系统中的一些基本概念。</p>\n<p>电商系统中最基本的有产品、用户和订单：</p>\n<ul>\n<li><p>产品：有产品唯一Id、名称、描述、图片、价格等属性。</p>\n</li>\n<li><p>用户：有用户名、密码等属性。</p>\n</li>\n<li><p>订单：有订单号、下单用户、选购产品列表及数量、下单时间、收货人、收货地址、联系电话、订单状态等属性。</p>\n</li>\n</ul>\n<p>产品Product类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品图片链接</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String pictureUrl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品描述</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String description;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产品价格</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> price;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户User类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>订单条目OrderItem类来描述单个产品及选购的数量，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//购买产品</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Product product;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//购买数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> quantity;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrderItem</span><span class=\"params\">(Product product,<span class=\"keyword\">int</span> quantity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.product = productl;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.quantity = quantity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//合计价格</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">computePrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> product.getPrice()*quantity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是包含全部属性的订单Order类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//订单号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//购买用户</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> User user;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//购买产品列表及数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderItem[] items;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//下单时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createtime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//收货人</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String receiver;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//收货地址</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String address;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//联系电话</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//订单状态</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String status;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">computeTotalPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> totalPrice = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(items != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(OrderItem item : items) &#123;</span><br><span class=\"line\">                totalPrice+=item.computePrice(); <span class=\"comment\">//计算总金额</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Order类引用了User类，以及一个订单条目的数组items，定义了一个计算总价的方法。</p>\n<p>​    </p>\n<p>​    </p>\n<p><strong>引用自己的类</strong></p>\n<p>一个类定义中还可以引用它自己。</p>\n<p>比如想要描述人以及人之间的血缘关系，用Person类表示一个人，它的实例成员包括其父母孩子，这些成员也都是Person类型。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//父亲</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person father;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//母亲</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person mother;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//孩子数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person[] children;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Person daZhongMa = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;大仲马&quot;</span>);</span><br><span class=\"line\">    Person xiaoZhongMa = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;小仲马&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    xiaoZhongMa.setFather(daZhongMa);</span><br><span class=\"line\">    daZhongMa.setChildren(<span class=\"keyword\">new</span> Person[]&#123;xiaoZhongMa&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    System.out.println(xiaoZhongMa.getFather().getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码先创建了大仲马，然后创建了小仲马，接着调用xiaozhongma的setFather()和dazhongma的setChildren()，设置了父子关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">栈-地址</th>\n<th align=\"center\">栈-内容</th>\n<th align=\"center\">堆-地址</th>\n<th align=\"center\">堆-内容</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0x8000</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">小仲马</td>\n<td align=\"center\">xiaoZhongMa.name</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1004</td>\n<td align=\"center\">0x1010</td>\n<td align=\"center\">xiaoZhongMa.father</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1008</td>\n<td align=\"center\">null</td>\n<td align=\"center\">xiaoZhongMa.mother</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x100C</td>\n<td align=\"center\">null</td>\n<td align=\"center\">xiaoZhongMa.children</td>\n</tr>\n<tr>\n<td align=\"center\">0x8008</td>\n<td align=\"center\">0x1010</td>\n<td align=\"center\">0x1010</td>\n<td align=\"center\">大仲马</td>\n<td align=\"center\">daZhongMa.name</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1014</td>\n<td align=\"center\">null</td>\n<td align=\"center\">daZhongMa.father</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x1018</td>\n<td align=\"center\">null</td>\n<td align=\"center\">daZhongMa.mother</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">0x101C</td>\n<td align=\"center\">0x1000</td>\n<td align=\"center\">daZhongMa.children</td>\n</tr>\n</tbody></table>\n<p>​    </p>\n<p>​    </p>\n<p><strong>互相引用的类</strong></p>\n<p>定义两个类MyFile和MyFolder，分别表示文件和文件夹。</p>\n<p>文件和文件夹都有名称、创建时间、父文件夹，根文件夹没有父文件夹，文件夹还有子文件列表和子文件夹列表。</p>\n<p>文件MyFile类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFile</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文件名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createtime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//文件大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//上级目录</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFolder parent;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>文件夹MyFolder类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFolder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文件夹名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createtime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//上级文件夹</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFolder parent;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//包含的文件</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFile[] files;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//包含的子文件夹</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyFolder[] subFolders;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">totalSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (files != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(MyFile file : files) &#123;</span><br><span class=\"line\">                totalSize+=file.getSize(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(subFolders != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(MyFolder folder : subFolders) &#123;</span><br><span class=\"line\">                totalSize+=folder.totalSize(); <span class=\"comment\">//计算子文件夹的size</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>MyFile引用了MyFolder，MyFolder也引用了MyFile，两者组合互相引用。</p>\n"},{"title":"类的继承","date":"2021-08-31T08:52:28.000Z","_content":"\n计算机程序经常使用类之间的**继承**关系来表示对象之间的分类关系。\n\n在继承关系中，有父类(基类)和子类(派生类)。比如动物类Animal和狗类Dog，Animal是父类，Dog是子类。\n\n子类继承了父类的属性和行为，父类有的属性和行为，子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。\n\n​    \n\n​    \n\n**Object**\n\n在Java中，所有类都有一个父类，就是Object。\n\nObject没有定义属性，但定义了一些方法，如下方代码：\n\n```java\nequals(Object obj):boolean -Object\ngetClass():Class<?> -Object\nhashCode():int -Object\nnotify():void -Object\nnotifyAll():void -Object\ntoString():String -Object\nwait():void -Object\nwait(long timeout):void -Object\nwait(long timeout,int nanos):void -Object   \n```\n\n以上方法可以被所有类直接使用。\n\n\n\n子类可以重写父类的方法，以反应自己的不同实现。\n\n方法前面放一个**@Override**，代表是重写的方法。\n\n下图是Object的toString()方法， 返回的是类名和内存地址(hashcode)。\n\n![Object类的toString方法.png](https://i.loli.net/2021/08/31/QBUKg2wRHlvM5NE.png)\n\n下图经过重写toString()方法，返回的是m。\n\n![重写的toString方法.png](https://i.loli.net/2021/08/31/N7vyYrUCqiPsToe.png)\n\n​    \n\nJava使用**extends**关键字标明继承关系，一个类最多只能有一个父类。\n\n子类不能直接访问父类的私有属性和方法。\n\n除了私有的属性和方法外，子类继承了父类的其他属性和方法。\n\n假设父类Animal类如下代码:\n\n```java\n//父类：动物类\npublic class Animal {\n\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n包含私有属性name和age，公共方法setName和setAge。\n\n子类Cat类不能直接调用name和age，但可以调用setName和setAge。代码如下：\n\n```java\n//子类：猫类\npublic class Cat extends Animal {\n\n    private String owner;\n\n    public Cat(String owner,int age,String name) {\n        this.owner = owner;\n        this.setAge(age);\n        super.setName(name); //super关键字\n    }\n\n\n    public static void main(String[] args) {\n        Cat cat = new Cat(\"me\",1,\"shaded\");\n    }\n}\n```\n\n\n\n**super**关键字指代父类，可用于调用父类构造方法,访问父类方法和变量。\n\n\n\n","source":"_posts/类的继承.md","raw":"---\ntitle: 类的继承\ndate: 2021-08-31 16:52:28\ntags: \n - java\n - class\n - extends\ncategories: java\n---\n\n计算机程序经常使用类之间的**继承**关系来表示对象之间的分类关系。\n\n在继承关系中，有父类(基类)和子类(派生类)。比如动物类Animal和狗类Dog，Animal是父类，Dog是子类。\n\n子类继承了父类的属性和行为，父类有的属性和行为，子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。\n\n​    \n\n​    \n\n**Object**\n\n在Java中，所有类都有一个父类，就是Object。\n\nObject没有定义属性，但定义了一些方法，如下方代码：\n\n```java\nequals(Object obj):boolean -Object\ngetClass():Class<?> -Object\nhashCode():int -Object\nnotify():void -Object\nnotifyAll():void -Object\ntoString():String -Object\nwait():void -Object\nwait(long timeout):void -Object\nwait(long timeout,int nanos):void -Object   \n```\n\n以上方法可以被所有类直接使用。\n\n\n\n子类可以重写父类的方法，以反应自己的不同实现。\n\n方法前面放一个**@Override**，代表是重写的方法。\n\n下图是Object的toString()方法， 返回的是类名和内存地址(hashcode)。\n\n![Object类的toString方法.png](https://i.loli.net/2021/08/31/QBUKg2wRHlvM5NE.png)\n\n下图经过重写toString()方法，返回的是m。\n\n![重写的toString方法.png](https://i.loli.net/2021/08/31/N7vyYrUCqiPsToe.png)\n\n​    \n\nJava使用**extends**关键字标明继承关系，一个类最多只能有一个父类。\n\n子类不能直接访问父类的私有属性和方法。\n\n除了私有的属性和方法外，子类继承了父类的其他属性和方法。\n\n假设父类Animal类如下代码:\n\n```java\n//父类：动物类\npublic class Animal {\n\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n包含私有属性name和age，公共方法setName和setAge。\n\n子类Cat类不能直接调用name和age，但可以调用setName和setAge。代码如下：\n\n```java\n//子类：猫类\npublic class Cat extends Animal {\n\n    private String owner;\n\n    public Cat(String owner,int age,String name) {\n        this.owner = owner;\n        this.setAge(age);\n        super.setName(name); //super关键字\n    }\n\n\n    public static void main(String[] args) {\n        Cat cat = new Cat(\"me\",1,\"shaded\");\n    }\n}\n```\n\n\n\n**super**关键字指代父类，可用于调用父类构造方法,访问父类方法和变量。\n\n\n\n","slug":"类的继承","published":1,"updated":"2021-09-02T08:30:45.625Z","_id":"ckszv9dew0000kkuiba6ganbd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>计算机程序经常使用类之间的<strong>继承</strong>关系来表示对象之间的分类关系。</p>\n<p>在继承关系中，有父类(基类)和子类(派生类)。比如动物类Animal和狗类Dog，Animal是父类，Dog是子类。</p>\n<p>子类继承了父类的属性和行为，父类有的属性和行为，子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。</p>\n<p>​    </p>\n<p>​    </p>\n<p><strong>Object</strong></p>\n<p>在Java中，所有类都有一个父类，就是Object。</p>\n<p>Object没有定义属性，但定义了一些方法，如下方代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">equals(Object obj):<span class=\"keyword\">boolean</span> -<span class=\"function\">Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">getClass</span><span class=\"params\">()</span>:Class&lt;?&gt; -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">hashCode</span><span class=\"params\">()</span>:<span class=\"keyword\">int</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">notify</span><span class=\"params\">()</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">notifyAll</span><span class=\"params\">()</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">toString</span><span class=\"params\">()</span>:String -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">wait</span><span class=\"params\">()</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout,<span class=\"keyword\">int</span> nanos)</span>:<span class=\"keyword\">void</span> -Object   </span></span><br></pre></td></tr></table></figure>\n\n<p>以上方法可以被所有类直接使用。</p>\n<p>子类可以重写父类的方法，以反应自己的不同实现。</p>\n<p>方法前面放一个**@Override**，代表是重写的方法。</p>\n<p>下图是Object的toString()方法， 返回的是类名和内存地址(hashcode)。</p>\n<p><img src=\"https://i.loli.net/2021/08/31/QBUKg2wRHlvM5NE.png\" alt=\"Object类的toString方法.png\"></p>\n<p>下图经过重写toString()方法，返回的是m。</p>\n<p><img src=\"https://i.loli.net/2021/08/31/N7vyYrUCqiPsToe.png\" alt=\"重写的toString方法.png\"></p>\n<p>​    </p>\n<p>Java使用<strong>extends</strong>关键字标明继承关系，一个类最多只能有一个父类。</p>\n<p>子类不能直接访问父类的私有属性和方法。</p>\n<p>除了私有的属性和方法外，子类继承了父类的其他属性和方法。</p>\n<p>假设父类Animal类如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类：动物类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包含私有属性name和age，公共方法setName和setAge。</p>\n<p>子类Cat类不能直接调用name和age，但可以调用setName和setAge。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类：猫类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">(String owner,<span class=\"keyword\">int</span> age,String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.owner = owner;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setAge(age);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(name); <span class=\"comment\">//super关键字</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Cat cat = <span class=\"keyword\">new</span> Cat(<span class=\"string\">&quot;me&quot;</span>,<span class=\"number\">1</span>,<span class=\"string\">&quot;shaded&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>super</strong>关键字指代父类，可用于调用父类构造方法,访问父类方法和变量。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>计算机程序经常使用类之间的<strong>继承</strong>关系来表示对象之间的分类关系。</p>\n<p>在继承关系中，有父类(基类)和子类(派生类)。比如动物类Animal和狗类Dog，Animal是父类，Dog是子类。</p>\n<p>子类继承了父类的属性和行为，父类有的属性和行为，子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。</p>\n<p>​    </p>\n<p>​    </p>\n<p><strong>Object</strong></p>\n<p>在Java中，所有类都有一个父类，就是Object。</p>\n<p>Object没有定义属性，但定义了一些方法，如下方代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">equals(Object obj):<span class=\"keyword\">boolean</span> -<span class=\"function\">Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">getClass</span><span class=\"params\">()</span>:Class&lt;?&gt; -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">hashCode</span><span class=\"params\">()</span>:<span class=\"keyword\">int</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">notify</span><span class=\"params\">()</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">notifyAll</span><span class=\"params\">()</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">toString</span><span class=\"params\">()</span>:String -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">wait</span><span class=\"params\">()</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span>:<span class=\"keyword\">void</span> -Object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout,<span class=\"keyword\">int</span> nanos)</span>:<span class=\"keyword\">void</span> -Object   </span></span><br></pre></td></tr></table></figure>\n\n<p>以上方法可以被所有类直接使用。</p>\n<p>子类可以重写父类的方法，以反应自己的不同实现。</p>\n<p>方法前面放一个**@Override**，代表是重写的方法。</p>\n<p>下图是Object的toString()方法， 返回的是类名和内存地址(hashcode)。</p>\n<p><img src=\"https://i.loli.net/2021/08/31/QBUKg2wRHlvM5NE.png\" alt=\"Object类的toString方法.png\"></p>\n<p>下图经过重写toString()方法，返回的是m。</p>\n<p><img src=\"https://i.loli.net/2021/08/31/N7vyYrUCqiPsToe.png\" alt=\"重写的toString方法.png\"></p>\n<p>​    </p>\n<p>Java使用<strong>extends</strong>关键字标明继承关系，一个类最多只能有一个父类。</p>\n<p>子类不能直接访问父类的私有属性和方法。</p>\n<p>除了私有的属性和方法外，子类继承了父类的其他属性和方法。</p>\n<p>假设父类Animal类如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类：动物类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包含私有属性name和age，公共方法setName和setAge。</p>\n<p>子类Cat类不能直接调用name和age，但可以调用setName和setAge。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类：猫类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">(String owner,<span class=\"keyword\">int</span> age,String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.owner = owner;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setAge(age);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(name); <span class=\"comment\">//super关键字</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Cat cat = <span class=\"keyword\">new</span> Cat(<span class=\"string\">&quot;me&quot;</span>,<span class=\"number\">1</span>,<span class=\"string\">&quot;shaded&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>super</strong>关键字指代父类，可用于调用父类构造方法,访问父类方法和变量。</p>\n"},{"title":"从图形处理类看继承和多态","date":"2021-08-31T11:00:31.000Z","_content":"\n![各类图形.jpg](https://i.loli.net/2021/08/31/hcLzn9FmegXV2G4.jpg)\n\n上图有一些基本的图形。接下来，用以下类来定义图形：\n\n- 父类Shape，表示图形\n\n- 类Circle，表示圆\n\n- 类Line，表示直线\n\n- 类ArrowLine，表示带箭头的直线\n\n​    \n\n图形Shape类有一个表示颜色的属性，和一个表示绘制的方法，代码如下：\n\n```java\n//父类：图形类\npublic class Shape {\n\n    private static final String DEFAULT_COLOR = \"black\";\n    private String color;\n\n    public Shape() {\n        this(DEFAULT_COLOR);\n    }\n\n    public Shape(String color) {\n        this.color = color;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public void draw() {\n        System.out.println(\"draw shape\");\n    }\n}\n```\n\n​    \n\n圆circle类继承自Shape，但包括了Shape没有的中心点和半径属性，以及额外的方法area，用于计算面积。\n\n此外又重写了draw方法。\n\n代码如下：\n\n```java\npublic class Circle extends Shape {\n    //中心点\n    private Point center;\n    //半径\n    private double r;\n\n    public Circle(Point center,double r) {\n        this.center = center;\n        this.r = r;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"draw circle at \"+center.toString()+\" with r \"\n        +r+\", using color : \"+getColor());\n    }\n\n    public double area() {\n        return Math.PI*r*r;\n    }\n}\n```\n\n​    \n\n直线Line类继承Shape类，它有两个点，有一个获取长度的方法，并且重写了draw方法。\n\n代码如下：\n\n```java\npublic class Line extends Shape {\n    private Point start;\n    private Point end;\n\n    public Line(Point start,Point end,String color) {\n        super(color);\n        this.start = start;\n        this.end = end;\n    }\n\n    public double length() {\n        return start.distance(end);\n    }\n\n    public Point getStart() {\n        return start;\n    }\n\n    public Point getEnd() {\n        return end;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"draw line from \"+ start.toString() + \" to \"\n        +end.toString()+\",using color \"+super.getColor());\n    }\n}\n```\n\n​    \n\n带箭头直线ArrowLine类继承自Line类，多了表示两端是否有箭头的两个属性，也重写了draw方法。\n\n代码如下：\n\n```java\npublic class ArrowLine extends Line{\n    //起点是否有箭头\n    private boolean startArrow;\n    //终点是否有箭头\n    private boolean endArrow;\n\n    public ArrowLine(Point start,Point end,String color,\n                     boolean startArrow,boolean endArrow) {\n        super(start,end,color);\n        this.startArrow = startArrow;\n        this.endArrow = endArrow;\n    }\n\n    @Override\n    public void draw() {\n        super.draw();\n        if (startArrow) {\n            System.out.println(\"draw start arrow\");\n        }\n        if (endArrow) {\n            System.out.println(\"draw end arrow\");\n        }\n    }\n}\n```\n\nsuper.draw();表示调用父类的draw()方法。\n\n​    \n\n使用继承的一个好处是可以统一处理不同子类型的对象。\n\n比如说，设计一个图形管理ShapeManager类，它负责管理画板上的所有图形对象并负责绘制。\n\n```java\npublic class ShapeManager {\n    //图形最大个数为100\n    private static final int MAX_NUM = 100;\n    private Shape[] shapes = new Shape[MAX_NUM];\n    private int shapeNum = 0;\n\n    public void addShape(Shape shape) {\n        if (shapeNum < MAX_NUM) {\n            shapes[shapeNum++] = shape;\n        }\n    }\n\n    public void draw() {\n        for (int i=0;i<shapeNum;i++) {\n            shapes[i].draw();\n        }\n    }\n}\n```\n\n如上方代码，ShapeManager使用一个数组保存所有的shape，在draw方法中调用每个shape的draw方法。\n\n​     \n\n接下来使用ShapeManager：\n\n```java\npublic static void main(String[] args) {\n   ShapeManager manager = new ShapeManager();\n\n   manager.addShape(new Circle(new Point(4,4),3)); //添加圆形\n   manager.addShape(new Line(new Point(2,3),new Point(3,4),\"green\")); //添加直线\n   manager.addShape(new ArrowLine(new Point(1,2),new Point(5,5),\"black\",false,false)); //添加箭头线\n\n   manager.draw();\n}\n```\n\n新建了三个图形，分别是一个圆、直线、箭头线，然后加到ShapeManager中，再调用manager的draw方法。\n\n在addShape方法中，参数Shape shape，声明的类型是Shape，而实际的类型则分别是Circle、Line、ArrowLine。子类对象赋值给父类引用变量，叫做**向上转型**，转型=转换类型，向上转型=转换为父类类型。\n\n变量Shape可以引用任何Shape子类类型的对象，称为**多态**，即**一种类型的变量，可引用多种实际类型对象**。\n\n对于变量shape，它有两个类型，类型Shape，我们称之为shape的**静态类型**；类型Circle/Line/ArrowLine，我们称之为shape的**动态类型**。\n\n在ShapeManager的draw方法中，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的**动态绑定**。\n\n​    \n\n为什么要有多态和动态绑定呢？创建对象的代码 (ShapeManager以外的代码）和操作对象的代码(ShapeManager本身的代码），经常不在一起，操作对象的代码往往只知道对象是某种父类型，也往往只需要知道它是某种父类型就可以了。\n\n**多态和动态绑定是计算机程序中的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为。**\n\n","source":"_posts/从图形处理类看继承和多态.md","raw":"---\ntitle: 从图形处理类看继承和多态\ndate: 2021-08-31 19:00:31\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n![各类图形.jpg](https://i.loli.net/2021/08/31/hcLzn9FmegXV2G4.jpg)\n\n上图有一些基本的图形。接下来，用以下类来定义图形：\n\n- 父类Shape，表示图形\n\n- 类Circle，表示圆\n\n- 类Line，表示直线\n\n- 类ArrowLine，表示带箭头的直线\n\n​    \n\n图形Shape类有一个表示颜色的属性，和一个表示绘制的方法，代码如下：\n\n```java\n//父类：图形类\npublic class Shape {\n\n    private static final String DEFAULT_COLOR = \"black\";\n    private String color;\n\n    public Shape() {\n        this(DEFAULT_COLOR);\n    }\n\n    public Shape(String color) {\n        this.color = color;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public void draw() {\n        System.out.println(\"draw shape\");\n    }\n}\n```\n\n​    \n\n圆circle类继承自Shape，但包括了Shape没有的中心点和半径属性，以及额外的方法area，用于计算面积。\n\n此外又重写了draw方法。\n\n代码如下：\n\n```java\npublic class Circle extends Shape {\n    //中心点\n    private Point center;\n    //半径\n    private double r;\n\n    public Circle(Point center,double r) {\n        this.center = center;\n        this.r = r;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"draw circle at \"+center.toString()+\" with r \"\n        +r+\", using color : \"+getColor());\n    }\n\n    public double area() {\n        return Math.PI*r*r;\n    }\n}\n```\n\n​    \n\n直线Line类继承Shape类，它有两个点，有一个获取长度的方法，并且重写了draw方法。\n\n代码如下：\n\n```java\npublic class Line extends Shape {\n    private Point start;\n    private Point end;\n\n    public Line(Point start,Point end,String color) {\n        super(color);\n        this.start = start;\n        this.end = end;\n    }\n\n    public double length() {\n        return start.distance(end);\n    }\n\n    public Point getStart() {\n        return start;\n    }\n\n    public Point getEnd() {\n        return end;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"draw line from \"+ start.toString() + \" to \"\n        +end.toString()+\",using color \"+super.getColor());\n    }\n}\n```\n\n​    \n\n带箭头直线ArrowLine类继承自Line类，多了表示两端是否有箭头的两个属性，也重写了draw方法。\n\n代码如下：\n\n```java\npublic class ArrowLine extends Line{\n    //起点是否有箭头\n    private boolean startArrow;\n    //终点是否有箭头\n    private boolean endArrow;\n\n    public ArrowLine(Point start,Point end,String color,\n                     boolean startArrow,boolean endArrow) {\n        super(start,end,color);\n        this.startArrow = startArrow;\n        this.endArrow = endArrow;\n    }\n\n    @Override\n    public void draw() {\n        super.draw();\n        if (startArrow) {\n            System.out.println(\"draw start arrow\");\n        }\n        if (endArrow) {\n            System.out.println(\"draw end arrow\");\n        }\n    }\n}\n```\n\nsuper.draw();表示调用父类的draw()方法。\n\n​    \n\n使用继承的一个好处是可以统一处理不同子类型的对象。\n\n比如说，设计一个图形管理ShapeManager类，它负责管理画板上的所有图形对象并负责绘制。\n\n```java\npublic class ShapeManager {\n    //图形最大个数为100\n    private static final int MAX_NUM = 100;\n    private Shape[] shapes = new Shape[MAX_NUM];\n    private int shapeNum = 0;\n\n    public void addShape(Shape shape) {\n        if (shapeNum < MAX_NUM) {\n            shapes[shapeNum++] = shape;\n        }\n    }\n\n    public void draw() {\n        for (int i=0;i<shapeNum;i++) {\n            shapes[i].draw();\n        }\n    }\n}\n```\n\n如上方代码，ShapeManager使用一个数组保存所有的shape，在draw方法中调用每个shape的draw方法。\n\n​     \n\n接下来使用ShapeManager：\n\n```java\npublic static void main(String[] args) {\n   ShapeManager manager = new ShapeManager();\n\n   manager.addShape(new Circle(new Point(4,4),3)); //添加圆形\n   manager.addShape(new Line(new Point(2,3),new Point(3,4),\"green\")); //添加直线\n   manager.addShape(new ArrowLine(new Point(1,2),new Point(5,5),\"black\",false,false)); //添加箭头线\n\n   manager.draw();\n}\n```\n\n新建了三个图形，分别是一个圆、直线、箭头线，然后加到ShapeManager中，再调用manager的draw方法。\n\n在addShape方法中，参数Shape shape，声明的类型是Shape，而实际的类型则分别是Circle、Line、ArrowLine。子类对象赋值给父类引用变量，叫做**向上转型**，转型=转换类型，向上转型=转换为父类类型。\n\n变量Shape可以引用任何Shape子类类型的对象，称为**多态**，即**一种类型的变量，可引用多种实际类型对象**。\n\n对于变量shape，它有两个类型，类型Shape，我们称之为shape的**静态类型**；类型Circle/Line/ArrowLine，我们称之为shape的**动态类型**。\n\n在ShapeManager的draw方法中，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的**动态绑定**。\n\n​    \n\n为什么要有多态和动态绑定呢？创建对象的代码 (ShapeManager以外的代码）和操作对象的代码(ShapeManager本身的代码），经常不在一起，操作对象的代码往往只知道对象是某种父类型，也往往只需要知道它是某种父类型就可以了。\n\n**多态和动态绑定是计算机程序中的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为。**\n\n","slug":"从图形处理类看继承和多态","published":1,"updated":"2021-09-02T08:30:59.868Z","_id":"ckt2ckbft0000y0ui9ugbaa2g","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://i.loli.net/2021/08/31/hcLzn9FmegXV2G4.jpg\" alt=\"各类图形.jpg\"></p>\n<p>上图有一些基本的图形。接下来，用以下类来定义图形：</p>\n<ul>\n<li><p>父类Shape，表示图形</p>\n</li>\n<li><p>类Circle，表示圆</p>\n</li>\n<li><p>类Line，表示直线</p>\n</li>\n<li><p>类ArrowLine，表示带箭头的直线</p>\n</li>\n</ul>\n<p>​    </p>\n<p>图形Shape类有一个表示颜色的属性，和一个表示绘制的方法，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类：图形类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_COLOR = <span class=\"string\">&quot;black&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Shape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(DEFAULT_COLOR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Shape</span><span class=\"params\">(String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getColor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;draw shape&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>圆circle类继承自Shape，但包括了Shape没有的中心点和半径属性，以及额外的方法area，用于计算面积。</p>\n<p>此外又重写了draw方法。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//中心点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point center;</span><br><span class=\"line\">    <span class=\"comment\">//半径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Circle</span><span class=\"params\">(Point center,<span class=\"keyword\">double</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.center = center;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.r = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;draw circle at &quot;</span>+center.toString()+<span class=\"string\">&quot; with r &quot;</span></span><br><span class=\"line\">        +r+<span class=\"string\">&quot;, using color : &quot;</span>+getColor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">area</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.PI*r*r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>直线Line类继承Shape类，它有两个点，有一个获取长度的方法，并且重写了draw方法。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Line</span><span class=\"params\">(Point start,Point end,String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(color);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">length</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start.distance(end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">getStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">getEnd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;draw line from &quot;</span>+ start.toString() + <span class=\"string\">&quot; to &quot;</span></span><br><span class=\"line\">        +end.toString()+<span class=\"string\">&quot;,using color &quot;</span>+<span class=\"keyword\">super</span>.getColor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>带箭头直线ArrowLine类继承自Line类，多了表示两端是否有箭头的两个属性，也重写了draw方法。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrowLine</span> <span class=\"keyword\">extends</span> <span class=\"title\">Line</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//起点是否有箭头</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> startArrow;</span><br><span class=\"line\">    <span class=\"comment\">//终点是否有箭头</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> endArrow;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrowLine</span><span class=\"params\">(Point start,Point end,String color,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">boolean</span> startArrow,<span class=\"keyword\">boolean</span> endArrow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(start,end,color);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.startArrow = startArrow;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.endArrow = endArrow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.draw();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startArrow) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;draw start arrow&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (endArrow) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;draw end arrow&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>super.draw();表示调用父类的draw()方法。</p>\n<p>​    </p>\n<p>使用继承的一个好处是可以统一处理不同子类型的对象。</p>\n<p>比如说，设计一个图形管理ShapeManager类，它负责管理画板上的所有图形对象并负责绘制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//图形最大个数为100</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_NUM = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Shape[] shapes = <span class=\"keyword\">new</span> Shape[MAX_NUM];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> shapeNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addShape</span><span class=\"params\">(Shape shape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shapeNum &lt; MAX_NUM) &#123;</span><br><span class=\"line\">            shapes[shapeNum++] = shape;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;shapeNum;i++) &#123;</span><br><span class=\"line\">            shapes[i].draw();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上方代码，ShapeManager使用一个数组保存所有的shape，在draw方法中调用每个shape的draw方法。</p>\n<p>​     </p>\n<p>接下来使用ShapeManager：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   ShapeManager manager = <span class=\"keyword\">new</span> ShapeManager();</span><br><span class=\"line\"></span><br><span class=\"line\">   manager.addShape(<span class=\"keyword\">new</span> Circle(<span class=\"keyword\">new</span> Point(<span class=\"number\">4</span>,<span class=\"number\">4</span>),<span class=\"number\">3</span>)); <span class=\"comment\">//添加圆形</span></span><br><span class=\"line\">   manager.addShape(<span class=\"keyword\">new</span> Line(<span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>),<span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"string\">&quot;green&quot;</span>)); <span class=\"comment\">//添加直线</span></span><br><span class=\"line\">   manager.addShape(<span class=\"keyword\">new</span> ArrowLine(<span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>),<span class=\"keyword\">new</span> Point(<span class=\"number\">5</span>,<span class=\"number\">5</span>),<span class=\"string\">&quot;black&quot;</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>)); <span class=\"comment\">//添加箭头线</span></span><br><span class=\"line\"></span><br><span class=\"line\">   manager.draw();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建了三个图形，分别是一个圆、直线、箭头线，然后加到ShapeManager中，再调用manager的draw方法。</p>\n<p>在addShape方法中，参数Shape shape，声明的类型是Shape，而实际的类型则分别是Circle、Line、ArrowLine。子类对象赋值给父类引用变量，叫做<strong>向上转型</strong>，转型=转换类型，向上转型=转换为父类类型。</p>\n<p>变量Shape可以引用任何Shape子类类型的对象，称为<strong>多态</strong>，即<strong>一种类型的变量，可引用多种实际类型对象</strong>。</p>\n<p>对于变量shape，它有两个类型，类型Shape，我们称之为shape的<strong>静态类型</strong>；类型Circle/Line/ArrowLine，我们称之为shape的<strong>动态类型</strong>。</p>\n<p>在ShapeManager的draw方法中，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的<strong>动态绑定</strong>。</p>\n<p>​    </p>\n<p>为什么要有多态和动态绑定呢？创建对象的代码 (ShapeManager以外的代码）和操作对象的代码(ShapeManager本身的代码），经常不在一起，操作对象的代码往往只知道对象是某种父类型，也往往只需要知道它是某种父类型就可以了。</p>\n<p><strong>多态和动态绑定是计算机程序中的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://i.loli.net/2021/08/31/hcLzn9FmegXV2G4.jpg\" alt=\"各类图形.jpg\"></p>\n<p>上图有一些基本的图形。接下来，用以下类来定义图形：</p>\n<ul>\n<li><p>父类Shape，表示图形</p>\n</li>\n<li><p>类Circle，表示圆</p>\n</li>\n<li><p>类Line，表示直线</p>\n</li>\n<li><p>类ArrowLine，表示带箭头的直线</p>\n</li>\n</ul>\n<p>​    </p>\n<p>图形Shape类有一个表示颜色的属性，和一个表示绘制的方法，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类：图形类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_COLOR = <span class=\"string\">&quot;black&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Shape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(DEFAULT_COLOR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Shape</span><span class=\"params\">(String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getColor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;draw shape&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>圆circle类继承自Shape，但包括了Shape没有的中心点和半径属性，以及额外的方法area，用于计算面积。</p>\n<p>此外又重写了draw方法。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//中心点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point center;</span><br><span class=\"line\">    <span class=\"comment\">//半径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Circle</span><span class=\"params\">(Point center,<span class=\"keyword\">double</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.center = center;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.r = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;draw circle at &quot;</span>+center.toString()+<span class=\"string\">&quot; with r &quot;</span></span><br><span class=\"line\">        +r+<span class=\"string\">&quot;, using color : &quot;</span>+getColor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">area</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.PI*r*r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>直线Line类继承Shape类，它有两个点，有一个获取长度的方法，并且重写了draw方法。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Line</span><span class=\"params\">(Point start,Point end,String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(color);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">length</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start.distance(end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">getStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">getEnd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;draw line from &quot;</span>+ start.toString() + <span class=\"string\">&quot; to &quot;</span></span><br><span class=\"line\">        +end.toString()+<span class=\"string\">&quot;,using color &quot;</span>+<span class=\"keyword\">super</span>.getColor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>带箭头直线ArrowLine类继承自Line类，多了表示两端是否有箭头的两个属性，也重写了draw方法。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrowLine</span> <span class=\"keyword\">extends</span> <span class=\"title\">Line</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//起点是否有箭头</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> startArrow;</span><br><span class=\"line\">    <span class=\"comment\">//终点是否有箭头</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> endArrow;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrowLine</span><span class=\"params\">(Point start,Point end,String color,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">boolean</span> startArrow,<span class=\"keyword\">boolean</span> endArrow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(start,end,color);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.startArrow = startArrow;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.endArrow = endArrow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.draw();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startArrow) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;draw start arrow&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (endArrow) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;draw end arrow&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>super.draw();表示调用父类的draw()方法。</p>\n<p>​    </p>\n<p>使用继承的一个好处是可以统一处理不同子类型的对象。</p>\n<p>比如说，设计一个图形管理ShapeManager类，它负责管理画板上的所有图形对象并负责绘制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//图形最大个数为100</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_NUM = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Shape[] shapes = <span class=\"keyword\">new</span> Shape[MAX_NUM];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> shapeNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addShape</span><span class=\"params\">(Shape shape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shapeNum &lt; MAX_NUM) &#123;</span><br><span class=\"line\">            shapes[shapeNum++] = shape;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;shapeNum;i++) &#123;</span><br><span class=\"line\">            shapes[i].draw();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上方代码，ShapeManager使用一个数组保存所有的shape，在draw方法中调用每个shape的draw方法。</p>\n<p>​     </p>\n<p>接下来使用ShapeManager：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   ShapeManager manager = <span class=\"keyword\">new</span> ShapeManager();</span><br><span class=\"line\"></span><br><span class=\"line\">   manager.addShape(<span class=\"keyword\">new</span> Circle(<span class=\"keyword\">new</span> Point(<span class=\"number\">4</span>,<span class=\"number\">4</span>),<span class=\"number\">3</span>)); <span class=\"comment\">//添加圆形</span></span><br><span class=\"line\">   manager.addShape(<span class=\"keyword\">new</span> Line(<span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>),<span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"string\">&quot;green&quot;</span>)); <span class=\"comment\">//添加直线</span></span><br><span class=\"line\">   manager.addShape(<span class=\"keyword\">new</span> ArrowLine(<span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>),<span class=\"keyword\">new</span> Point(<span class=\"number\">5</span>,<span class=\"number\">5</span>),<span class=\"string\">&quot;black&quot;</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>)); <span class=\"comment\">//添加箭头线</span></span><br><span class=\"line\"></span><br><span class=\"line\">   manager.draw();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建了三个图形，分别是一个圆、直线、箭头线，然后加到ShapeManager中，再调用manager的draw方法。</p>\n<p>在addShape方法中，参数Shape shape，声明的类型是Shape，而实际的类型则分别是Circle、Line、ArrowLine。子类对象赋值给父类引用变量，叫做<strong>向上转型</strong>，转型=转换类型，向上转型=转换为父类类型。</p>\n<p>变量Shape可以引用任何Shape子类类型的对象，称为<strong>多态</strong>，即<strong>一种类型的变量，可引用多种实际类型对象</strong>。</p>\n<p>对于变量shape，它有两个类型，类型Shape，我们称之为shape的<strong>静态类型</strong>；类型Circle/Line/ArrowLine，我们称之为shape的<strong>动态类型</strong>。</p>\n<p>在ShapeManager的draw方法中，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的<strong>动态绑定</strong>。</p>\n<p>​    </p>\n<p>为什么要有多态和动态绑定呢？创建对象的代码 (ShapeManager以外的代码）和操作对象的代码(ShapeManager本身的代码），经常不在一起，操作对象的代码往往只知道对象是某种父类型，也往往只需要知道它是某种父类型就可以了。</p>\n<p><strong>多态和动态绑定是计算机程序中的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为。</strong></p>\n"},{"title":"继承的细节--重名与静态绑定","date":"2021-09-02T10:44:48.000Z","_content":"\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定 <font color=blue>now!</font>\n- 重载和重写\n- 父子类型转换\n- 继承访问权限（protected）\n- 可见性重写\n- 防止继承（final）\n  \n\n​    \n\n**重名**\n\n对于private变量和方法，它们只能在类内被访问，访问的也永远是当前类的对象。\n\n​    \n\n对于public变量和方法，在类内访问的是当前类的，但子类可以通过super.明确指定访问父类的。\n\n在类外，则要看访问变量的静态类型，静态类型是父类，则访问父类的变量和方法；静态类型是子类，则访问子类的变量和方法。\n\n​    \n\n接下来举个栗子。父类Base代码如下：\n\n```java\n//父类\npublic class Base {\n    public static String s = \"static_base\";\n    public String m = \"base\";\n\n    public static void staticTest() {\n        System.out.println(\"base static: \"+s);\n    }\n}\n```\n\nBase类定义了一个public静态变量s，一个public实例变量m、一个静态方法staticTest。\n\n子类Child代码如下：\n\n```java\npublic class Child extends Base {\n    public static String s = \"child_base\";\n    public String m = \"child\";\n    \n    public static void staticTest() {\n        System.out.println(\"child static: \"+s);\n    }\n}\n```\n\n子类定义了和父类重名的变量m、s和方法staticTest。\n\n对于一个子类对象，它就有了两份变量和方法。在子类内部访问的时候，访问的是子类的。子类变量和方法隐藏了父类对应的变量和方法。\n\n​     \n\n调用代码如下：\n\n```java\npublic static void main(String[] args) {\n    Child c = new Child();\n    Base b = c;\n    \n    System.out.println(b.s);\n    System.out.println(b.m);\n    b.staticTest();\n    \n    System.out.println(c.s);\n    System.out.println(c.m);\n    c.staticTest();\n}\n```\n\n创建一个子类对象new Child()，然后将该对象分别赋值给子类引用变量c和父类引用变量b。\n\n再通过b和c分别引用变量和方法。\n\n输出结果为：\n\n```java\nstatic_base\nbase\nbase static: static_base\nchild_base\nchild\nchild static: child_base\n```\n\n通过b(静态类型Base)访问时，访问的是Base的变量和方法。通过c(静态类型Child)访问时，访问的是Child的变量和方法。\n\n这叫做**静态绑定**，即访问绑定到变量的静态类型。\n\n**实例变量、静态变量、private方法，都是静态绑定的。**\n\n","source":"_posts/继承的细节-重名与静态绑定.md","raw":"---\ntitle: 继承的细节--重名与静态绑定\ndate: 2021-09-02 18:44:48\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定 <font color=blue>now!</font>\n- 重载和重写\n- 父子类型转换\n- 继承访问权限（protected）\n- 可见性重写\n- 防止继承（final）\n  \n\n​    \n\n**重名**\n\n对于private变量和方法，它们只能在类内被访问，访问的也永远是当前类的对象。\n\n​    \n\n对于public变量和方法，在类内访问的是当前类的，但子类可以通过super.明确指定访问父类的。\n\n在类外，则要看访问变量的静态类型，静态类型是父类，则访问父类的变量和方法；静态类型是子类，则访问子类的变量和方法。\n\n​    \n\n接下来举个栗子。父类Base代码如下：\n\n```java\n//父类\npublic class Base {\n    public static String s = \"static_base\";\n    public String m = \"base\";\n\n    public static void staticTest() {\n        System.out.println(\"base static: \"+s);\n    }\n}\n```\n\nBase类定义了一个public静态变量s，一个public实例变量m、一个静态方法staticTest。\n\n子类Child代码如下：\n\n```java\npublic class Child extends Base {\n    public static String s = \"child_base\";\n    public String m = \"child\";\n    \n    public static void staticTest() {\n        System.out.println(\"child static: \"+s);\n    }\n}\n```\n\n子类定义了和父类重名的变量m、s和方法staticTest。\n\n对于一个子类对象，它就有了两份变量和方法。在子类内部访问的时候，访问的是子类的。子类变量和方法隐藏了父类对应的变量和方法。\n\n​     \n\n调用代码如下：\n\n```java\npublic static void main(String[] args) {\n    Child c = new Child();\n    Base b = c;\n    \n    System.out.println(b.s);\n    System.out.println(b.m);\n    b.staticTest();\n    \n    System.out.println(c.s);\n    System.out.println(c.m);\n    c.staticTest();\n}\n```\n\n创建一个子类对象new Child()，然后将该对象分别赋值给子类引用变量c和父类引用变量b。\n\n再通过b和c分别引用变量和方法。\n\n输出结果为：\n\n```java\nstatic_base\nbase\nbase static: static_base\nchild_base\nchild\nchild static: child_base\n```\n\n通过b(静态类型Base)访问时，访问的是Base的变量和方法。通过c(静态类型Child)访问时，访问的是Child的变量和方法。\n\n这叫做**静态绑定**，即访问绑定到变量的静态类型。\n\n**实例变量、静态变量、private方法，都是静态绑定的。**\n\n","slug":"继承的细节-重名与静态绑定","published":1,"updated":"2021-09-26T11:46:24.838Z","_id":"ckt2wa01y0000a0ui3083f1dt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定 <font color=blue>now!</font></li>\n<li>重载和重写</li>\n<li>父子类型转换</li>\n<li>继承访问权限（protected）</li>\n<li>可见性重写</li>\n<li>防止继承（final）</li>\n</ul>\n<p>​    </p>\n<p><strong>重名</strong></p>\n<p>对于private变量和方法，它们只能在类内被访问，访问的也永远是当前类的对象。</p>\n<p>​    </p>\n<p>对于public变量和方法，在类内访问的是当前类的，但子类可以通过super.明确指定访问父类的。</p>\n<p>在类外，则要看访问变量的静态类型，静态类型是父类，则访问父类的变量和方法；静态类型是子类，则访问子类的变量和方法。</p>\n<p>​    </p>\n<p>接下来举个栗子。父类Base代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String s = <span class=\"string\">&quot;static_base&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String m = <span class=\"string\">&quot;base&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base static: &quot;</span>+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Base类定义了一个public静态变量s，一个public实例变量m、一个静态方法staticTest。</p>\n<p>子类Child代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String s = <span class=\"string\">&quot;child_base&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String m = <span class=\"string\">&quot;child&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;child static: &quot;</span>+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类定义了和父类重名的变量m、s和方法staticTest。</p>\n<p>对于一个子类对象，它就有了两份变量和方法。在子类内部访问的时候，访问的是子类的。子类变量和方法隐藏了父类对应的变量和方法。</p>\n<p>​     </p>\n<p>调用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Child c = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    Base b = c;</span><br><span class=\"line\">    </span><br><span class=\"line\">    System.out.println(b.s);</span><br><span class=\"line\">    System.out.println(b.m);</span><br><span class=\"line\">    b.staticTest();</span><br><span class=\"line\">    </span><br><span class=\"line\">    System.out.println(c.s);</span><br><span class=\"line\">    System.out.println(c.m);</span><br><span class=\"line\">    c.staticTest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个子类对象new Child()，然后将该对象分别赋值给子类引用变量c和父类引用变量b。</p>\n<p>再通过b和c分别引用变量和方法。</p>\n<p>输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static_base</span><br><span class=\"line\">base</span><br><span class=\"line\">base <span class=\"keyword\">static</span>: static_base</span><br><span class=\"line\">child_base</span><br><span class=\"line\">child</span><br><span class=\"line\">child <span class=\"keyword\">static</span>: child_base</span><br></pre></td></tr></table></figure>\n\n<p>通过b(静态类型Base)访问时，访问的是Base的变量和方法。通过c(静态类型Child)访问时，访问的是Child的变量和方法。</p>\n<p>这叫做<strong>静态绑定</strong>，即访问绑定到变量的静态类型。</p>\n<p><strong>实例变量、静态变量、private方法，都是静态绑定的。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定 <font color=blue>now!</font></li>\n<li>重载和重写</li>\n<li>父子类型转换</li>\n<li>继承访问权限（protected）</li>\n<li>可见性重写</li>\n<li>防止继承（final）</li>\n</ul>\n<p>​    </p>\n<p><strong>重名</strong></p>\n<p>对于private变量和方法，它们只能在类内被访问，访问的也永远是当前类的对象。</p>\n<p>​    </p>\n<p>对于public变量和方法，在类内访问的是当前类的，但子类可以通过super.明确指定访问父类的。</p>\n<p>在类外，则要看访问变量的静态类型，静态类型是父类，则访问父类的变量和方法；静态类型是子类，则访问子类的变量和方法。</p>\n<p>​    </p>\n<p>接下来举个栗子。父类Base代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String s = <span class=\"string\">&quot;static_base&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String m = <span class=\"string\">&quot;base&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base static: &quot;</span>+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Base类定义了一个public静态变量s，一个public实例变量m、一个静态方法staticTest。</p>\n<p>子类Child代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String s = <span class=\"string\">&quot;child_base&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String m = <span class=\"string\">&quot;child&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;child static: &quot;</span>+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类定义了和父类重名的变量m、s和方法staticTest。</p>\n<p>对于一个子类对象，它就有了两份变量和方法。在子类内部访问的时候，访问的是子类的。子类变量和方法隐藏了父类对应的变量和方法。</p>\n<p>​     </p>\n<p>调用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Child c = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    Base b = c;</span><br><span class=\"line\">    </span><br><span class=\"line\">    System.out.println(b.s);</span><br><span class=\"line\">    System.out.println(b.m);</span><br><span class=\"line\">    b.staticTest();</span><br><span class=\"line\">    </span><br><span class=\"line\">    System.out.println(c.s);</span><br><span class=\"line\">    System.out.println(c.m);</span><br><span class=\"line\">    c.staticTest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个子类对象new Child()，然后将该对象分别赋值给子类引用变量c和父类引用变量b。</p>\n<p>再通过b和c分别引用变量和方法。</p>\n<p>输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static_base</span><br><span class=\"line\">base</span><br><span class=\"line\">base <span class=\"keyword\">static</span>: static_base</span><br><span class=\"line\">child_base</span><br><span class=\"line\">child</span><br><span class=\"line\">child <span class=\"keyword\">static</span>: child_base</span><br></pre></td></tr></table></figure>\n\n<p>通过b(静态类型Base)访问时，访问的是Base的变量和方法。通过c(静态类型Child)访问时，访问的是Child的变量和方法。</p>\n<p>这叫做<strong>静态绑定</strong>，即访问绑定到变量的静态类型。</p>\n<p><strong>实例变量、静态变量、private方法，都是静态绑定的。</strong></p>\n"},{"title":"继承的细节--重载和重写","date":"2021-09-02T12:19:31.000Z","_content":"\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n\n- 重名与静态绑定\n\n- 重载和重写 <font color=blue>now!</font>\n\n- 父子类型转换\n\n- 继承访问权限（protected）\n\n- 可见性重写\n\n- 防止继承（final）\n\n​    \n\n**重载和重写**\n\n重载=方法名称相同，但参数签名不同（参数个数或类型或顺序不同）。\n\n重写= 子类重写父类相同参数签名的方法。\n\n​    \n\n举一个栗子，父类代码如下：\n\n```java\npublic class Base {\n    public int sum(int a,int b) {\n        System.out.println(\"base_int_int\");\n        return a+b;\n    }\n}\n```\n\n父类定义了sum(int a,int b)方法。\n\n子类代码如下：\n\n```java\npublic class Child extends Base{\n   public long sum(long a,long b) {\n       System.out.println(\"child_long_long\");\n       return a+b;\n   }\n}\n```\n\n子类定义了sum(long a,long b)方法。\n\n​    \n\n调用代码如下：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Child child = new Child();\n        int a = 2;\n        int b = 3;\n        child.sum(a,b);\n    }\n}\n```\n\n虽然每个sum方法都是兼容的，int类型可以自动转型为long，当只有一个方法的时候，那个方法就会被调用。\n\n但现在有多个方法可用，子类的sum方法参数类型虽然兼容但是不完全匹配，而父类的sum方法参数类型是完全匹配的。\n\n所以父类的sum方法被调用了，输出结果为：\n\n```java\nbase_int_int\n```\n\n​    \n\n如果父类将其中一个int参数改为long参数，代码如下：\n\n```java\npublic class Base {\n    public long sum(int a,long b) {\n        System.out.println(\"base_int_long\");\n        return a+b;\n    }\n}\n```\n\n再运行程序，调用的依然是父类的sum函数，代码如下：\n\n```java\nbase_int_long\n```\n\n虽然子类和父类的两个方法的参数类型都不完全匹配，但是相比之下，还是父类的sum方法更匹配一些，至少有一个int参数。\n\n​    \n\n现在修改一下子类代码，让它的参数类型和父类一致：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Base base = new Child();//静态类型是Base，动态类型是Child\n        int a = 2;\n        int b = 3;\n        base.sum(a,b);\n    }\n}\n```\n\n输出结果为：\n\n```java\nchild_int_long\n```\n\n说明这一回调用的是子类的sum函数。\n\n​    \n\n从上面的这些栗子中，我们可以得知——**当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的。换句话说，寻找在所有重载函数中最匹配的。然后才看变量的动态类型，进行动态绑定。**\n\n\n\n","source":"_posts/继承的细节-重载和重写.md","raw":"---\ntitle: 继承的细节--重载和重写\ndate: 2021-09-02 20:19:31\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n\n- 重名与静态绑定\n\n- 重载和重写 <font color=blue>now!</font>\n\n- 父子类型转换\n\n- 继承访问权限（protected）\n\n- 可见性重写\n\n- 防止继承（final）\n\n​    \n\n**重载和重写**\n\n重载=方法名称相同，但参数签名不同（参数个数或类型或顺序不同）。\n\n重写= 子类重写父类相同参数签名的方法。\n\n​    \n\n举一个栗子，父类代码如下：\n\n```java\npublic class Base {\n    public int sum(int a,int b) {\n        System.out.println(\"base_int_int\");\n        return a+b;\n    }\n}\n```\n\n父类定义了sum(int a,int b)方法。\n\n子类代码如下：\n\n```java\npublic class Child extends Base{\n   public long sum(long a,long b) {\n       System.out.println(\"child_long_long\");\n       return a+b;\n   }\n}\n```\n\n子类定义了sum(long a,long b)方法。\n\n​    \n\n调用代码如下：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Child child = new Child();\n        int a = 2;\n        int b = 3;\n        child.sum(a,b);\n    }\n}\n```\n\n虽然每个sum方法都是兼容的，int类型可以自动转型为long，当只有一个方法的时候，那个方法就会被调用。\n\n但现在有多个方法可用，子类的sum方法参数类型虽然兼容但是不完全匹配，而父类的sum方法参数类型是完全匹配的。\n\n所以父类的sum方法被调用了，输出结果为：\n\n```java\nbase_int_int\n```\n\n​    \n\n如果父类将其中一个int参数改为long参数，代码如下：\n\n```java\npublic class Base {\n    public long sum(int a,long b) {\n        System.out.println(\"base_int_long\");\n        return a+b;\n    }\n}\n```\n\n再运行程序，调用的依然是父类的sum函数，代码如下：\n\n```java\nbase_int_long\n```\n\n虽然子类和父类的两个方法的参数类型都不完全匹配，但是相比之下，还是父类的sum方法更匹配一些，至少有一个int参数。\n\n​    \n\n现在修改一下子类代码，让它的参数类型和父类一致：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Base base = new Child();//静态类型是Base，动态类型是Child\n        int a = 2;\n        int b = 3;\n        base.sum(a,b);\n    }\n}\n```\n\n输出结果为：\n\n```java\nchild_int_long\n```\n\n说明这一回调用的是子类的sum函数。\n\n​    \n\n从上面的这些栗子中，我们可以得知——**当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的。换句话说，寻找在所有重载函数中最匹配的。然后才看变量的动态类型，进行动态绑定。**\n\n\n\n","slug":"继承的细节-重载和重写","published":1,"updated":"2021-09-03T03:56:18.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt3ts0d10000f8uicz2x7fyn","content":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li><p>构造方法  </p>\n</li>\n<li><p>重名与静态绑定</p>\n</li>\n<li><p>重载和重写 <font color=blue>now!</font></p>\n</li>\n<li><p>父子类型转换</p>\n</li>\n<li><p>继承访问权限（protected）</p>\n</li>\n<li><p>可见性重写</p>\n</li>\n<li><p>防止继承（final）</p>\n</li>\n</ul>\n<p>​    </p>\n<p><strong>重载和重写</strong></p>\n<p>重载=方法名称相同，但参数签名不同（参数个数或类型或顺序不同）。</p>\n<p>重写= 子类重写父类相同参数签名的方法。</p>\n<p>​    </p>\n<p>举一个栗子，父类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base_int_int&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>父类定义了sum(int a,int b)方法。</p>\n<p>子类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">long</span> a,<span class=\"keyword\">long</span> b)</span> </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;child_long_long&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类定义了sum(long a,long b)方法。</p>\n<p>​    </p>\n<p>调用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Child child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">        child.sum(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然每个sum方法都是兼容的，int类型可以自动转型为long，当只有一个方法的时候，那个方法就会被调用。</p>\n<p>但现在有多个方法可用，子类的sum方法参数类型虽然兼容但是不完全匹配，而父类的sum方法参数类型是完全匹配的。</p>\n<p>所以父类的sum方法被调用了，输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_int_int</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>如果父类将其中一个int参数改为long参数，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">long</span> b)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base_int_long&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再运行程序，调用的依然是父类的sum函数，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_int_long</span><br></pre></td></tr></table></figure>\n\n<p>虽然子类和父类的两个方法的参数类型都不完全匹配，但是相比之下，还是父类的sum方法更匹配一些，至少有一个int参数。</p>\n<p>​    </p>\n<p>现在修改一下子类代码，让它的参数类型和父类一致：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Base base = <span class=\"keyword\">new</span> Child();<span class=\"comment\">//静态类型是Base，动态类型是Child</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">        base.sum(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_int_long</span><br></pre></td></tr></table></figure>\n\n<p>说明这一回调用的是子类的sum函数。</p>\n<p>​    </p>\n<p>从上面的这些栗子中，我们可以得知——<strong>当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的。换句话说，寻找在所有重载函数中最匹配的。然后才看变量的动态类型，进行动态绑定。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li><p>构造方法  </p>\n</li>\n<li><p>重名与静态绑定</p>\n</li>\n<li><p>重载和重写 <font color=blue>now!</font></p>\n</li>\n<li><p>父子类型转换</p>\n</li>\n<li><p>继承访问权限（protected）</p>\n</li>\n<li><p>可见性重写</p>\n</li>\n<li><p>防止继承（final）</p>\n</li>\n</ul>\n<p>​    </p>\n<p><strong>重载和重写</strong></p>\n<p>重载=方法名称相同，但参数签名不同（参数个数或类型或顺序不同）。</p>\n<p>重写= 子类重写父类相同参数签名的方法。</p>\n<p>​    </p>\n<p>举一个栗子，父类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base_int_int&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>父类定义了sum(int a,int b)方法。</p>\n<p>子类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">long</span> a,<span class=\"keyword\">long</span> b)</span> </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;child_long_long&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类定义了sum(long a,long b)方法。</p>\n<p>​    </p>\n<p>调用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Child child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">        child.sum(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然每个sum方法都是兼容的，int类型可以自动转型为long，当只有一个方法的时候，那个方法就会被调用。</p>\n<p>但现在有多个方法可用，子类的sum方法参数类型虽然兼容但是不完全匹配，而父类的sum方法参数类型是完全匹配的。</p>\n<p>所以父类的sum方法被调用了，输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_int_int</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>如果父类将其中一个int参数改为long参数，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">long</span> b)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base_int_long&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再运行程序，调用的依然是父类的sum函数，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_int_long</span><br></pre></td></tr></table></figure>\n\n<p>虽然子类和父类的两个方法的参数类型都不完全匹配，但是相比之下，还是父类的sum方法更匹配一些，至少有一个int参数。</p>\n<p>​    </p>\n<p>现在修改一下子类代码，让它的参数类型和父类一致：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Base base = <span class=\"keyword\">new</span> Child();<span class=\"comment\">//静态类型是Base，动态类型是Child</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">        base.sum(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_int_long</span><br></pre></td></tr></table></figure>\n\n<p>说明这一回调用的是子类的sum函数。</p>\n<p>​    </p>\n<p>从上面的这些栗子中，我们可以得知——<strong>当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的。换句话说，寻找在所有重载函数中最匹配的。然后才看变量的动态类型，进行动态绑定。</strong></p>\n"},{"title":"继承的细节--父子类型转换","date":"2021-09-03T04:00:31.000Z","_content":"\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定 \n- 重载和重写\n- 父子类型转换 <font color=blue>now!</font>\n- 继承访问权限（protected）\n- 可见性重写\n- 防止继承（final）\n\n​    \n\n根据《从图形处理类看继承和多态》一章可知，子类型的对象可以赋值给父类型的引用变量。\n\n但父类型的变量不一定能成功赋值给子类型的变量，**向下转型**不一定成功。\n\n栗子如下：\n\n```java\nBase base = new Child();\nChild child = (Child)base;\n```\n\nChild child = (Child)base就是将变量base的类型强制转换为Child并赋值为child。\n因为base的动态类型就是child，所以向下转型没问题。\n\n```java\nBase base = new Base();\nChild child = (Child)base;\n```\n\n上面代码，在运行时会抛出错误，错误为类型转换异常。\n\n​    \n\n**一个父类的变量，能否转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。**\n\n​    \n\n给定一个父类的变量，通过**instanceof**关键字，能知道它到底是不是某个子类的对象，从而安全的进行类型转换。\n\n```java\npublic static boolean canCast(Base b) {\n   return b instanceof Child; \n}\n```\n\ncanCast函数返回Base类型变量b是否可以转换为Child类型。\n\ninstanceof前面是变量，后面是类，返回值为true时表示变量引用的对象是该类或其子类的对象，false则反之。\n\n\n\n","source":"_posts/继承的细节-父子类型转换.md","raw":"---\ntitle: 继承的细节--父子类型转换\ndate: 2021-09-03 12:00:31\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定 \n- 重载和重写\n- 父子类型转换 <font color=blue>now!</font>\n- 继承访问权限（protected）\n- 可见性重写\n- 防止继承（final）\n\n​    \n\n根据《从图形处理类看继承和多态》一章可知，子类型的对象可以赋值给父类型的引用变量。\n\n但父类型的变量不一定能成功赋值给子类型的变量，**向下转型**不一定成功。\n\n栗子如下：\n\n```java\nBase base = new Child();\nChild child = (Child)base;\n```\n\nChild child = (Child)base就是将变量base的类型强制转换为Child并赋值为child。\n因为base的动态类型就是child，所以向下转型没问题。\n\n```java\nBase base = new Base();\nChild child = (Child)base;\n```\n\n上面代码，在运行时会抛出错误，错误为类型转换异常。\n\n​    \n\n**一个父类的变量，能否转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。**\n\n​    \n\n给定一个父类的变量，通过**instanceof**关键字，能知道它到底是不是某个子类的对象，从而安全的进行类型转换。\n\n```java\npublic static boolean canCast(Base b) {\n   return b instanceof Child; \n}\n```\n\ncanCast函数返回Base类型变量b是否可以转换为Child类型。\n\ninstanceof前面是变量，后面是类，返回值为true时表示变量引用的对象是该类或其子类的对象，false则反之。\n\n\n\n","slug":"继承的细节-父子类型转换","published":1,"updated":"2021-09-03T10:37:47.996Z","_id":"ckt45mpjt0000t0uif9vkfyzv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定 </li>\n<li>重载和重写</li>\n<li>父子类型转换 <font color=blue>now!</font></li>\n<li>继承访问权限（protected）</li>\n<li>可见性重写</li>\n<li>防止继承（final）</li>\n</ul>\n<p>​    </p>\n<p>根据《从图形处理类看继承和多态》一章可知，子类型的对象可以赋值给父类型的引用变量。</p>\n<p>但父类型的变量不一定能成功赋值给子类型的变量，<strong>向下转型</strong>不一定成功。</p>\n<p>栗子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base base = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">Child child = (Child)base;</span><br></pre></td></tr></table></figure>\n\n<p>Child child = (Child)base就是将变量base的类型强制转换为Child并赋值为child。<br>因为base的动态类型就是child，所以向下转型没问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base base = <span class=\"keyword\">new</span> Base();</span><br><span class=\"line\">Child child = (Child)base;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，在运行时会抛出错误，错误为类型转换异常。</p>\n<p>​    </p>\n<p><strong>一个父类的变量，能否转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。</strong></p>\n<p>​    </p>\n<p>给定一个父类的变量，通过<strong>instanceof</strong>关键字，能知道它到底是不是某个子类的对象，从而安全的进行类型转换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canCast</span><span class=\"params\">(Base b)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> b <span class=\"keyword\">instanceof</span> Child; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>canCast函数返回Base类型变量b是否可以转换为Child类型。</p>\n<p>instanceof前面是变量，后面是类，返回值为true时表示变量引用的对象是该类或其子类的对象，false则反之。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定 </li>\n<li>重载和重写</li>\n<li>父子类型转换 <font color=blue>now!</font></li>\n<li>继承访问权限（protected）</li>\n<li>可见性重写</li>\n<li>防止继承（final）</li>\n</ul>\n<p>​    </p>\n<p>根据《从图形处理类看继承和多态》一章可知，子类型的对象可以赋值给父类型的引用变量。</p>\n<p>但父类型的变量不一定能成功赋值给子类型的变量，<strong>向下转型</strong>不一定成功。</p>\n<p>栗子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base base = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">Child child = (Child)base;</span><br></pre></td></tr></table></figure>\n\n<p>Child child = (Child)base就是将变量base的类型强制转换为Child并赋值为child。<br>因为base的动态类型就是child，所以向下转型没问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base base = <span class=\"keyword\">new</span> Base();</span><br><span class=\"line\">Child child = (Child)base;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，在运行时会抛出错误，错误为类型转换异常。</p>\n<p>​    </p>\n<p><strong>一个父类的变量，能否转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。</strong></p>\n<p>​    </p>\n<p>给定一个父类的变量，通过<strong>instanceof</strong>关键字，能知道它到底是不是某个子类的对象，从而安全的进行类型转换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canCast</span><span class=\"params\">(Base b)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> b <span class=\"keyword\">instanceof</span> Child; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>canCast函数返回Base类型变量b是否可以转换为Child类型。</p>\n<p>instanceof前面是变量，后面是类，返回值为true时表示变量引用的对象是该类或其子类的对象，false则反之。</p>\n"},{"title":"继承的细节--protected","date":"2021-09-03T11:08:43.000Z","_content":"\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定 \n- 重载和重写\n- 父子类型转换 \n- 继承访问权限（protected） <font color=blue>now!</font>\n- 可见性重写\n- 防止继承（final）\n\n​    \n\n除了public/private之外，还有一种可见性介于中间的修饰符**protected**。\n\nprotected表示虽然不能被外部操作访问，但可被子类访问，还可被同一个包中的其他类访问（不管其他类是否是该类的子类）。\n\n​    \n\n举个栗子，基类Base代码如下：\n\n```java\npublic class Base {\n    protected int currentStep;\n\n    protected void step1() {\n    }\n\n    protected void step2() {\n    }\n\n    public void action() {\n        this.currentStep = 1;\n        step1();\n        this.currentStep = 2;\n        step2();\n    }\n}\n```\n\n含有protected修饰符的是变量currentStep和方法step1、step2，还对外提供了方法action。\n\n子类一般不重写action，只重写step1和step2。同时，子类可以直接访问currentStep查看进行到了哪一步。\n\n子类Child的代码如下：\n\n```java\npublic class Child extends Base{\n   protected void step1 () {\n       System.out.println(\"child step \"+this.currentStep);\n   }\n\n   protected void step2 () {\n       System.out.println(\"child step \"+this.currentStep);\n   }\n}\n```\n\n使用子类的main方法代码如下：\n\n```java\npublic static void main(String[] args) {\n   Child child = new Child();\n   child.action();\n}\n```\n\n输出结果为：\n\n```java\nchild step 1\nchild step 2\n```\n\n子类通过重写protected方法step1和step2，来修改对外的行为。\n\n​    \n\n这种思路和设计在设计模式中被称之为**模板方法**，action就是一个模板方法，它定义了实现的模板，而具体实现由子类提供。\n\n模板方法在很多框架中由广泛的应用，这是使用protected的一个常用场景。\n\n\n\n","source":"_posts/继承的细节-protected.md","raw":"---\ntitle: 继承的细节--protected\ndate: 2021-09-03 19:08:43\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定 \n- 重载和重写\n- 父子类型转换 \n- 继承访问权限（protected） <font color=blue>now!</font>\n- 可见性重写\n- 防止继承（final）\n\n​    \n\n除了public/private之外，还有一种可见性介于中间的修饰符**protected**。\n\nprotected表示虽然不能被外部操作访问，但可被子类访问，还可被同一个包中的其他类访问（不管其他类是否是该类的子类）。\n\n​    \n\n举个栗子，基类Base代码如下：\n\n```java\npublic class Base {\n    protected int currentStep;\n\n    protected void step1() {\n    }\n\n    protected void step2() {\n    }\n\n    public void action() {\n        this.currentStep = 1;\n        step1();\n        this.currentStep = 2;\n        step2();\n    }\n}\n```\n\n含有protected修饰符的是变量currentStep和方法step1、step2，还对外提供了方法action。\n\n子类一般不重写action，只重写step1和step2。同时，子类可以直接访问currentStep查看进行到了哪一步。\n\n子类Child的代码如下：\n\n```java\npublic class Child extends Base{\n   protected void step1 () {\n       System.out.println(\"child step \"+this.currentStep);\n   }\n\n   protected void step2 () {\n       System.out.println(\"child step \"+this.currentStep);\n   }\n}\n```\n\n使用子类的main方法代码如下：\n\n```java\npublic static void main(String[] args) {\n   Child child = new Child();\n   child.action();\n}\n```\n\n输出结果为：\n\n```java\nchild step 1\nchild step 2\n```\n\n子类通过重写protected方法step1和step2，来修改对外的行为。\n\n​    \n\n这种思路和设计在设计模式中被称之为**模板方法**，action就是一个模板方法，它定义了实现的模板，而具体实现由子类提供。\n\n模板方法在很多框架中由广泛的应用，这是使用protected的一个常用场景。\n\n\n\n","slug":"继承的细节-protected","published":1,"updated":"2021-09-15T08:34:58.842Z","_id":"cktcss5l40000ncui9n99dtt7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定 </li>\n<li>重载和重写</li>\n<li>父子类型转换 </li>\n<li>继承访问权限（protected） <font color=blue>now!</font></li>\n<li>可见性重写</li>\n<li>防止继承（final）</li>\n</ul>\n<p>​    </p>\n<p>除了public/private之外，还有一种可见性介于中间的修饰符<strong>protected</strong>。</p>\n<p>protected表示虽然不能被外部操作访问，但可被子类访问，还可被同一个包中的其他类访问（不管其他类是否是该类的子类）。</p>\n<p>​    </p>\n<p>举个栗子，基类Base代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> currentStep;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">action</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.currentStep = <span class=\"number\">1</span>;</span><br><span class=\"line\">        step1();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.currentStep = <span class=\"number\">2</span>;</span><br><span class=\"line\">        step2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>含有protected修饰符的是变量currentStep和方法step1、step2，还对外提供了方法action。</p>\n<p>子类一般不重写action，只重写step1和step2。同时，子类可以直接访问currentStep查看进行到了哪一步。</p>\n<p>子类Child的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step1</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;child step &quot;</span>+<span class=\"keyword\">this</span>.currentStep);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step2</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;child step &quot;</span>+<span class=\"keyword\">this</span>.currentStep);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用子类的main方法代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   Child child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">   child.action();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child step <span class=\"number\">1</span></span><br><span class=\"line\">child step <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>子类通过重写protected方法step1和step2，来修改对外的行为。</p>\n<p>​    </p>\n<p>这种思路和设计在设计模式中被称之为<strong>模板方法</strong>，action就是一个模板方法，它定义了实现的模板，而具体实现由子类提供。</p>\n<p>模板方法在很多框架中由广泛的应用，这是使用protected的一个常用场景。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定 </li>\n<li>重载和重写</li>\n<li>父子类型转换 </li>\n<li>继承访问权限（protected） <font color=blue>now!</font></li>\n<li>可见性重写</li>\n<li>防止继承（final）</li>\n</ul>\n<p>​    </p>\n<p>除了public/private之外，还有一种可见性介于中间的修饰符<strong>protected</strong>。</p>\n<p>protected表示虽然不能被外部操作访问，但可被子类访问，还可被同一个包中的其他类访问（不管其他类是否是该类的子类）。</p>\n<p>​    </p>\n<p>举个栗子，基类Base代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> currentStep;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">action</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.currentStep = <span class=\"number\">1</span>;</span><br><span class=\"line\">        step1();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.currentStep = <span class=\"number\">2</span>;</span><br><span class=\"line\">        step2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>含有protected修饰符的是变量currentStep和方法step1、step2，还对外提供了方法action。</p>\n<p>子类一般不重写action，只重写step1和step2。同时，子类可以直接访问currentStep查看进行到了哪一步。</p>\n<p>子类Child的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step1</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;child step &quot;</span>+<span class=\"keyword\">this</span>.currentStep);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step2</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;child step &quot;</span>+<span class=\"keyword\">this</span>.currentStep);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用子类的main方法代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   Child child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">   child.action();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child step <span class=\"number\">1</span></span><br><span class=\"line\">child step <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>子类通过重写protected方法step1和step2，来修改对外的行为。</p>\n<p>​    </p>\n<p>这种思路和设计在设计模式中被称之为<strong>模板方法</strong>，action就是一个模板方法，它定义了实现的模板，而具体实现由子类提供。</p>\n<p>模板方法在很多框架中由广泛的应用，这是使用protected的一个常用场景。</p>\n"},{"title":"继承的细节--构造方法","date":"2021-09-02T08:01:07.000Z","_content":"\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  <font color=blue>now!</font>\n\n- 重名与静态绑定\n\n- 重载和重写\n\n- 父子类型转换\n\n- 继承访问权限（protected）\n\n- 可见性重写\n\n- 防止继承（final）\n\n​    \n\n​    \n\n**构造方法**\n\n子类可以通过super(...)调用父类的构造方法。如果子类没有通过super(...)调用，则会自动调用父类的默认构造方法。\n\n如果父类没有默认构造方法，如下所示：\n\n```java\n//父类\npublic class Base {\n    private String member;\n    public Base(String member) {\n        this.member = member;\n    }\n}\n```\n\n上方代码中的类只有一个带参数的构造函数，没有默认构造方法。\n\n这个时候，它的任何子类都必须在构造方法中通过super(...)调用Base的带参数的构造方法。\n\n如下所示，否则Java会提示编译错误。\n\n```java\n//子类\npublic class Child extends Base{\n    public Child(String member) {\n        super(member);\t//调用Base的带参构造方法\n    }\n}\n```\n\n​    \n\n​    \n\n**避免父类的构造方法调用可重写的方法**\n\n如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果。\n\n父类代码如下：\n\n```java\n//父类\npublic class Base {\n    public Base() {\n        test(); //构造函数中调用test方法\n    }\n\n    public void test() {\n    }\n}\n```\n\n子类代码如下：\n\n```java\n//子类\npublic class Child extends Base{\n    private int a = 123;\n\n    public Child() {\n    }\n\n    public void test() {\n        System.out.println(a);\n    }\n}\n```\n\n子类有一个实例变量a，a初始赋值为123。子类重写了test方法，要输出a的值。\n\n使用代码如下：\n\n```java\npublic static void main(String[] args) {\n    Child c = new Child();\n    c.test();\n}\n```\n\n输出结果：\n\n```java\n0\n123\n```\n\n第一次输出0，是在new过程中输出的。\n\nnew过程中，首先初始化父类Base，父类构造方法调用test()，test被子类重写了，就会调用子类的test方法。\n\n子类方法访问子类实例变量a，这个时候子类的实例变量的赋值语句和构造方法还没有执行，所以输出的默认值是0。\n\n​    \n\n通过上面的例子，可以得出结论——**在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法**。\n\n","source":"_posts/继承的细节-构造方法.md","raw":"---\ntitle: 继承的细节--构造方法\ndate: 2021-09-02 16:01:07\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  <font color=blue>now!</font>\n\n- 重名与静态绑定\n\n- 重载和重写\n\n- 父子类型转换\n\n- 继承访问权限（protected）\n\n- 可见性重写\n\n- 防止继承（final）\n\n​    \n\n​    \n\n**构造方法**\n\n子类可以通过super(...)调用父类的构造方法。如果子类没有通过super(...)调用，则会自动调用父类的默认构造方法。\n\n如果父类没有默认构造方法，如下所示：\n\n```java\n//父类\npublic class Base {\n    private String member;\n    public Base(String member) {\n        this.member = member;\n    }\n}\n```\n\n上方代码中的类只有一个带参数的构造函数，没有默认构造方法。\n\n这个时候，它的任何子类都必须在构造方法中通过super(...)调用Base的带参数的构造方法。\n\n如下所示，否则Java会提示编译错误。\n\n```java\n//子类\npublic class Child extends Base{\n    public Child(String member) {\n        super(member);\t//调用Base的带参构造方法\n    }\n}\n```\n\n​    \n\n​    \n\n**避免父类的构造方法调用可重写的方法**\n\n如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果。\n\n父类代码如下：\n\n```java\n//父类\npublic class Base {\n    public Base() {\n        test(); //构造函数中调用test方法\n    }\n\n    public void test() {\n    }\n}\n```\n\n子类代码如下：\n\n```java\n//子类\npublic class Child extends Base{\n    private int a = 123;\n\n    public Child() {\n    }\n\n    public void test() {\n        System.out.println(a);\n    }\n}\n```\n\n子类有一个实例变量a，a初始赋值为123。子类重写了test方法，要输出a的值。\n\n使用代码如下：\n\n```java\npublic static void main(String[] args) {\n    Child c = new Child();\n    c.test();\n}\n```\n\n输出结果：\n\n```java\n0\n123\n```\n\n第一次输出0，是在new过程中输出的。\n\nnew过程中，首先初始化父类Base，父类构造方法调用test()，test被子类重写了，就会调用子类的test方法。\n\n子类方法访问子类实例变量a，这个时候子类的实例变量的赋值语句和构造方法还没有执行，所以输出的默认值是0。\n\n​    \n\n通过上面的例子，可以得出结论——**在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法**。\n\n","slug":"继承的细节-构造方法","published":1,"updated":"2021-09-02T10:12:58.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktihggxv000044ui0t2eajcj","content":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li><p>构造方法  <font color=blue>now!</font></p>\n</li>\n<li><p>重名与静态绑定</p>\n</li>\n<li><p>重载和重写</p>\n</li>\n<li><p>父子类型转换</p>\n</li>\n<li><p>继承访问权限（protected）</p>\n</li>\n<li><p>可见性重写</p>\n</li>\n<li><p>防止继承（final）</p>\n</li>\n</ul>\n<p>​    </p>\n<p>​    </p>\n<p><strong>构造方法</strong></p>\n<p>子类可以通过super(…)调用父类的构造方法。如果子类没有通过super(…)调用，则会自动调用父类的默认构造方法。</p>\n<p>如果父类没有默认构造方法，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String member;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">(String member)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.member = member;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上方代码中的类只有一个带参数的构造函数，没有默认构造方法。</p>\n<p>这个时候，它的任何子类都必须在构造方法中通过super(…)调用Base的带参数的构造方法。</p>\n<p>如下所示，否则Java会提示编译错误。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">(String member)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(member);\t<span class=\"comment\">//调用Base的带参构造方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>​    </p>\n<p><strong>避免父类的构造方法调用可重写的方法</strong></p>\n<p>如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果。</p>\n<p>父类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        test(); <span class=\"comment\">//构造函数中调用test方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类有一个实例变量a，a初始赋值为123。子类重写了test方法，要输出a的值。</p>\n<p>使用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Child c = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    c.test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n\n<p>第一次输出0，是在new过程中输出的。</p>\n<p>new过程中，首先初始化父类Base，父类构造方法调用test()，test被子类重写了，就会调用子类的test方法。</p>\n<p>子类方法访问子类实例变量a，这个时候子类的实例变量的赋值语句和构造方法还没有执行，所以输出的默认值是0。</p>\n<p>​    </p>\n<p>通过上面的例子，可以得出结论——<strong>在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li><p>构造方法  <font color=blue>now!</font></p>\n</li>\n<li><p>重名与静态绑定</p>\n</li>\n<li><p>重载和重写</p>\n</li>\n<li><p>父子类型转换</p>\n</li>\n<li><p>继承访问权限（protected）</p>\n</li>\n<li><p>可见性重写</p>\n</li>\n<li><p>防止继承（final）</p>\n</li>\n</ul>\n<p>​    </p>\n<p>​    </p>\n<p><strong>构造方法</strong></p>\n<p>子类可以通过super(…)调用父类的构造方法。如果子类没有通过super(…)调用，则会自动调用父类的默认构造方法。</p>\n<p>如果父类没有默认构造方法，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String member;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">(String member)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.member = member;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上方代码中的类只有一个带参数的构造函数，没有默认构造方法。</p>\n<p>这个时候，它的任何子类都必须在构造方法中通过super(…)调用Base的带参数的构造方法。</p>\n<p>如下所示，否则Java会提示编译错误。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">(String member)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(member);\t<span class=\"comment\">//调用Base的带参构造方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>​    </p>\n<p><strong>避免父类的构造方法调用可重写的方法</strong></p>\n<p>如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果。</p>\n<p>父类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        test(); <span class=\"comment\">//构造函数中调用test方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类有一个实例变量a，a初始赋值为123。子类重写了test方法，要输出a的值。</p>\n<p>使用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Child c = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    c.test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n\n<p>第一次输出0，是在new过程中输出的。</p>\n<p>new过程中，首先初始化父类Base，父类构造方法调用test()，test被子类重写了，就会调用子类的test方法。</p>\n<p>子类方法访问子类实例变量a，这个时候子类的实例变量的赋值语句和构造方法还没有执行，所以输出的默认值是0。</p>\n<p>​    </p>\n<p>通过上面的例子，可以得出结论——<strong>在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法</strong>。</p>\n"},{"title":"继承的细节--可见性重写","date":"2021-09-13T10:34:22.000Z","_content":"\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n\n- 重名与静态绑定 \n\n- 重载和重写\n\n- 父子类型转换 \n\n- 继承访问权限（protected）\n\n- 可见性重写 <font color=blue>now!</font>\n\n- 防止继承（final）\n\n    \n\n\n**重写时，子类方法不能降低父类方法的可见性**。\n\n如果父类是public，则子类也必须是public。\n\n如果父类是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性，但不能降低。\n\n\n\n子类必须支持父类所有对外的行为，所以不能降低可见性；子类可以增加父类的行为，所以能提升可见性。\n\n","source":"_posts/继承的细节-可见性重写.md","raw":"---\ntitle: 继承的细节--可见性重写\ndate: 2021-09-13 18:34:22\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n\n- 重名与静态绑定 \n\n- 重载和重写\n\n- 父子类型转换 \n\n- 继承访问权限（protected）\n\n- 可见性重写 <font color=blue>now!</font>\n\n- 防止继承（final）\n\n    \n\n\n**重写时，子类方法不能降低父类方法的可见性**。\n\n如果父类是public，则子类也必须是public。\n\n如果父类是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性，但不能降低。\n\n\n\n子类必须支持父类所有对外的行为，所以不能降低可见性；子类可以增加父类的行为，所以能提升可见性。\n\n","slug":"继承的细节-可见性重写","published":1,"updated":"2021-09-13T10:44:07.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktiir3wc0000pkuiemp8b4z6","content":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li><p>构造方法  </p>\n</li>\n<li><p>重名与静态绑定 </p>\n</li>\n<li><p>重载和重写</p>\n</li>\n<li><p>父子类型转换 </p>\n</li>\n<li><p>继承访问权限（protected）</p>\n</li>\n<li><p>可见性重写 <font color=blue>now!</font></p>\n</li>\n<li><p>防止继承（final）</p>\n</li>\n</ul>\n<p><strong>重写时，子类方法不能降低父类方法的可见性</strong>。</p>\n<p>如果父类是public，则子类也必须是public。</p>\n<p>如果父类是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性，但不能降低。</p>\n<p>子类必须支持父类所有对外的行为，所以不能降低可见性；子类可以增加父类的行为，所以能提升可见性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li><p>构造方法  </p>\n</li>\n<li><p>重名与静态绑定 </p>\n</li>\n<li><p>重载和重写</p>\n</li>\n<li><p>父子类型转换 </p>\n</li>\n<li><p>继承访问权限（protected）</p>\n</li>\n<li><p>可见性重写 <font color=blue>now!</font></p>\n</li>\n<li><p>防止继承（final）</p>\n</li>\n</ul>\n<p><strong>重写时，子类方法不能降低父类方法的可见性</strong>。</p>\n<p>如果父类是public，则子类也必须是public。</p>\n<p>如果父类是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性，但不能降低。</p>\n<p>子类必须支持父类所有对外的行为，所以不能降低可见性；子类可以增加父类的行为，所以能提升可见性。</p>\n"},{"title":"继承的细节--防止继承","date":"2021-09-13T10:55:18.000Z","_content":"\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定\n- 重载和重写 \n- 父子类型转换\n- 继承访问权限（protected）\n- 可见性重写\n- 防止继承（final） <font color=blue>now!</font>\n\n\n\n**final**关键字可以防止类被继承。\n\n   \n\n一个java类，默认情况下都是可以被继承的。但加了final关键字之后就不能被继承了。\n\n```java\npublic final class Base {\n    \n}\n```\n\n上面代码中的Base类不能被继承。\n\n​    \n\n一个非final的类，类中的public/protected实例方法默认情况下都是可以被重写的。但加了final关键字后就不能被重写了。\n\n```java\npublic class Base {\n    public final void test() {\n        System.out.println(\"不能被重写\");\n    }\n}\n```\n\n上面代码中的test方法不能被重写。\n\n\n\n  \n\n\n\n","source":"_posts/继承的细节-防止继承.md","raw":"---\ntitle: 继承的细节--防止继承\ndate: 2021-09-13 18:55:18\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n继承和多态概念还有一些相关的细节，具体包括：\n\n- 构造方法  \n- 重名与静态绑定\n- 重载和重写 \n- 父子类型转换\n- 继承访问权限（protected）\n- 可见性重写\n- 防止继承（final） <font color=blue>now!</font>\n\n\n\n**final**关键字可以防止类被继承。\n\n   \n\n一个java类，默认情况下都是可以被继承的。但加了final关键字之后就不能被继承了。\n\n```java\npublic final class Base {\n    \n}\n```\n\n上面代码中的Base类不能被继承。\n\n​    \n\n一个非final的类，类中的public/protected实例方法默认情况下都是可以被重写的。但加了final关键字后就不能被重写了。\n\n```java\npublic class Base {\n    public final void test() {\n        System.out.println(\"不能被重写\");\n    }\n}\n```\n\n上面代码中的test方法不能被重写。\n\n\n\n  \n\n\n\n","slug":"继承的细节-防止继承","published":1,"updated":"2021-09-14T09:39:22.768Z","_id":"cktijcmix0000vouiga7eegpd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定</li>\n<li>重载和重写 </li>\n<li>父子类型转换</li>\n<li>继承访问权限（protected）</li>\n<li>可见性重写</li>\n<li>防止继承（final） <font color=blue>now!</font></li>\n</ul>\n<p><strong>final</strong>关键字可以防止类被继承。</p>\n<p>一个java类，默认情况下都是可以被继承的。但加了final关键字之后就不能被继承了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的Base类不能被继承。</p>\n<p>​    </p>\n<p>一个非final的类，类中的public/protected实例方法默认情况下都是可以被重写的。但加了final关键字后就不能被重写了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;不能被重写&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的test方法不能被重写。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>继承和多态概念还有一些相关的细节，具体包括：</p>\n<ul>\n<li>构造方法  </li>\n<li>重名与静态绑定</li>\n<li>重载和重写 </li>\n<li>父子类型转换</li>\n<li>继承访问权限（protected）</li>\n<li>可见性重写</li>\n<li>防止继承（final） <font color=blue>now!</font></li>\n</ul>\n<p><strong>final</strong>关键字可以防止类被继承。</p>\n<p>一个java类，默认情况下都是可以被继承的。但加了final关键字之后就不能被继承了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的Base类不能被继承。</p>\n<p>​    </p>\n<p>一个非final的类，类中的public/protected实例方法默认情况下都是可以被重写的。但加了final关键字后就不能被重写了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;不能被重写&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的test方法不能被重写。</p>\n"},{"title":"继承实现的基本原理 （不是很懂的一章）","date":"2021-09-15T08:45:12.000Z","_content":"\n本节主要从概念上来介绍原理。\n\n​    \n\n首先创建一个基类Base，Base中包含实例变量instanceCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法、step方法和action方法。\n\n```java\npublic class Base {\n    public static int staticCode;\n    private int instanceCode;\n\n    static {\n        System.out.println(\"基类静态代码块，staticCode: \"+staticCode);\n        staticCode = 1;\n    }\n\n    {\n        System.out.println(\"基类实例代码块，actualCode: \"+instanceCode);\n        instanceCode = 1;\n    }\n\n    public Base() {\n        System.out.println(\"基类构造方法，actualCode: \"+instanceCode);\n        instanceCode = 2;\n    }\n\n    protected void step() {\n        System.out.println(\"base staticCode: \"+staticCode+\", actualCode: \"+instanceCode);\n    }\n\n    public void action() {\n        System.out.println(\"start\");\n        step();\n        System.out.println(\"end\");\n    }\n}\n```\n\n​     \n\n接下来设计出继承Base的子类Child，Child同样包含实例变量actualCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法，并且重写了step方法。\n\nChild类代码如下：\n\n```java\npublic class Child extends Base{\n    public static int staticCode;\n    private int instanceCode;\n\n    static {\n        System.out.println(\"子类静态代码块，staticCode: \"+staticCode);\n        staticCode = 10;\n    }\n\n    {\n        System.out.println(\"子类实例代码块，instanceCode: \"+instanceCode);\n    }\n\n    public Child() {\n        System.out.println(\"子类构造方法，instanceCode: \"+instanceCode);\n        instanceCode = 20;\n    }\n\n    @Override\n    protected void step() {\n        System.out.println(\"child staticCode: \"+staticCode+\", instanceCode: \"+instanceCode);\n    }\n}\n```\n\n​        \n\n使用这两个类的代码如下：\n\n```java\npublic static void main(String[] args) {\n   System.out.println(\"---- new Child()\");\n   Child child = new Child();\n\n   System.out.println(\"\\n---- child.action()\");\n   child.action();\n\n   Base base = child;\n   System.out.println(\"\\n---- base.action()\");\n   base.action();\n\n   System.out.println(\"\\n---- base.staticCode: \"+base.staticCode);\n   System.out.println(\"\\n---- child.staticCode: \"+child.staticCode);\n}\n```\n\n​    \n\nchild.action()的具体执行过程如下：\n\n1.查看child的对象类型，找到Child类型。在Child类型中寻找action方法，发现没有，于是到Base类中寻找。\n\n2.在Base类中找到了action方法，开始执行该方法。\n\n3.action先输出start，再从Child类型寻找step方法。\n\n4.在Child类型中找到了step方法，执行它，然后返回action方法\n\n5.继续执行action方法， 输出end\n\n**寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。**\n\nbase.action和child.action都是**动态绑定**，动态绑定实现的机制，就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。由于base和child指向的动态类型都是Child，所以执行结果一样。\n\n​    \n\n屏幕输入结果为：\n\n```java\n---- new Child()\n基类静态代码块，staticCode: 0\n子类静态代码块，staticCode: 0\n基类实例代码块，actualCode: 0\n基类构造方法，actualCode: 1\n子类实例代码块，instanceCode: 0\n子类构造方法，instanceCode: 0\n\n---- child.action()\nstart\nchild staticCode: 10, instanceCode: 20\nend\n\n---- base.action()\nstart\nchild staticCode: 10, instanceCode: 20\nend\n\n---- base.staticCode: 1\n\n---- child.staticCode: 10\n```\n\n​    \n\n**类的加载**\n\n在java中，类是动态加载的。\n\n第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载。如果没有，则加载其父类。\n\n​    \n\n一个类的信息，主要包括以下部分：\n\n- static变量\n\n- 类初始化代码\n\n- static方法\n\n- 实例变量\n\n- 实例初始化代码\n\n- 实例方法\n\n- 父类信息引用\n\n  \n\n类初始化代码包括：\n\n- 定义static变量时的赋值语句\n\n- static初始化代码块\n\n  \n\n实例初始化代码包括：\n\n- 定义实例变量时的赋值语句\n- 实例初始化代码块\n- 构造方法\n\n\n\n类加载过程包括：\n\n- 分配内存，保存类的信息\n\n- 给static变量赋默认值\n\n- 加载父类\n\n- 设置父子关系\n\n- 执行类初始化代码\n\n   \n\n类初始化代码，是先执行父类，再执行子类。\n\n父类执行时，子类static变量是有值的，为默认值。\n\n​    \n\n类的信息放在**内存区**，在java中称为**方法区**。\n\n![继承实现.jpg](https://i.loli.net/2021/09/17/ur9HsMUE4vA2niQ.jpg)\n\n如上图，class_init()表示类初始化代码，instance_init()表示实例初始化代码。实例初始化代码包括了实例初始化代码块和构造方法。\n\n​    \n\n对于上方的Base类和Child类，它们的内存布局就像图中的方法区。\n\n\n\n​    \n\n\n\n\n\n\n\n","source":"_posts/继承实现的基本原理.md","raw":"---\ntitle: 继承实现的基本原理 （不是很懂的一章）\ndate: 2021-09-15 16:45:12\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n本节主要从概念上来介绍原理。\n\n​    \n\n首先创建一个基类Base，Base中包含实例变量instanceCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法、step方法和action方法。\n\n```java\npublic class Base {\n    public static int staticCode;\n    private int instanceCode;\n\n    static {\n        System.out.println(\"基类静态代码块，staticCode: \"+staticCode);\n        staticCode = 1;\n    }\n\n    {\n        System.out.println(\"基类实例代码块，actualCode: \"+instanceCode);\n        instanceCode = 1;\n    }\n\n    public Base() {\n        System.out.println(\"基类构造方法，actualCode: \"+instanceCode);\n        instanceCode = 2;\n    }\n\n    protected void step() {\n        System.out.println(\"base staticCode: \"+staticCode+\", actualCode: \"+instanceCode);\n    }\n\n    public void action() {\n        System.out.println(\"start\");\n        step();\n        System.out.println(\"end\");\n    }\n}\n```\n\n​     \n\n接下来设计出继承Base的子类Child，Child同样包含实例变量actualCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法，并且重写了step方法。\n\nChild类代码如下：\n\n```java\npublic class Child extends Base{\n    public static int staticCode;\n    private int instanceCode;\n\n    static {\n        System.out.println(\"子类静态代码块，staticCode: \"+staticCode);\n        staticCode = 10;\n    }\n\n    {\n        System.out.println(\"子类实例代码块，instanceCode: \"+instanceCode);\n    }\n\n    public Child() {\n        System.out.println(\"子类构造方法，instanceCode: \"+instanceCode);\n        instanceCode = 20;\n    }\n\n    @Override\n    protected void step() {\n        System.out.println(\"child staticCode: \"+staticCode+\", instanceCode: \"+instanceCode);\n    }\n}\n```\n\n​        \n\n使用这两个类的代码如下：\n\n```java\npublic static void main(String[] args) {\n   System.out.println(\"---- new Child()\");\n   Child child = new Child();\n\n   System.out.println(\"\\n---- child.action()\");\n   child.action();\n\n   Base base = child;\n   System.out.println(\"\\n---- base.action()\");\n   base.action();\n\n   System.out.println(\"\\n---- base.staticCode: \"+base.staticCode);\n   System.out.println(\"\\n---- child.staticCode: \"+child.staticCode);\n}\n```\n\n​    \n\nchild.action()的具体执行过程如下：\n\n1.查看child的对象类型，找到Child类型。在Child类型中寻找action方法，发现没有，于是到Base类中寻找。\n\n2.在Base类中找到了action方法，开始执行该方法。\n\n3.action先输出start，再从Child类型寻找step方法。\n\n4.在Child类型中找到了step方法，执行它，然后返回action方法\n\n5.继续执行action方法， 输出end\n\n**寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。**\n\nbase.action和child.action都是**动态绑定**，动态绑定实现的机制，就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。由于base和child指向的动态类型都是Child，所以执行结果一样。\n\n​    \n\n屏幕输入结果为：\n\n```java\n---- new Child()\n基类静态代码块，staticCode: 0\n子类静态代码块，staticCode: 0\n基类实例代码块，actualCode: 0\n基类构造方法，actualCode: 1\n子类实例代码块，instanceCode: 0\n子类构造方法，instanceCode: 0\n\n---- child.action()\nstart\nchild staticCode: 10, instanceCode: 20\nend\n\n---- base.action()\nstart\nchild staticCode: 10, instanceCode: 20\nend\n\n---- base.staticCode: 1\n\n---- child.staticCode: 10\n```\n\n​    \n\n**类的加载**\n\n在java中，类是动态加载的。\n\n第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载。如果没有，则加载其父类。\n\n​    \n\n一个类的信息，主要包括以下部分：\n\n- static变量\n\n- 类初始化代码\n\n- static方法\n\n- 实例变量\n\n- 实例初始化代码\n\n- 实例方法\n\n- 父类信息引用\n\n  \n\n类初始化代码包括：\n\n- 定义static变量时的赋值语句\n\n- static初始化代码块\n\n  \n\n实例初始化代码包括：\n\n- 定义实例变量时的赋值语句\n- 实例初始化代码块\n- 构造方法\n\n\n\n类加载过程包括：\n\n- 分配内存，保存类的信息\n\n- 给static变量赋默认值\n\n- 加载父类\n\n- 设置父子关系\n\n- 执行类初始化代码\n\n   \n\n类初始化代码，是先执行父类，再执行子类。\n\n父类执行时，子类static变量是有值的，为默认值。\n\n​    \n\n类的信息放在**内存区**，在java中称为**方法区**。\n\n![继承实现.jpg](https://i.loli.net/2021/09/17/ur9HsMUE4vA2niQ.jpg)\n\n如上图，class_init()表示类初始化代码，instance_init()表示实例初始化代码。实例初始化代码包括了实例初始化代码块和构造方法。\n\n​    \n\n对于上方的Base类和Child类，它们的内存布局就像图中的方法区。\n\n\n\n​    \n\n\n\n\n\n\n\n","slug":"继承实现的基本原理","published":1,"updated":"2021-09-26T10:58:19.354Z","_id":"ckto9nscj0000psui5q1y75pl","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本节主要从概念上来介绍原理。</p>\n<p>​    </p>\n<p>首先创建一个基类Base，Base中包含实例变量instanceCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法、step方法和action方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> instanceCode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;基类静态代码块，staticCode: &quot;</span>+staticCode);</span><br><span class=\"line\">        staticCode = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;基类实例代码块，actualCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">        instanceCode = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;基类构造方法，actualCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">        instanceCode = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base staticCode: &quot;</span>+staticCode+<span class=\"string\">&quot;, actualCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">action</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">        step();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​     </p>\n<p>接下来设计出继承Base的子类Child，Child同样包含实例变量actualCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法，并且重写了step方法。</p>\n<p>Child类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> instanceCode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类静态代码块，staticCode: &quot;</span>+staticCode);</span><br><span class=\"line\">        staticCode = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类实例代码块，instanceCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类构造方法，instanceCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">        instanceCode = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;child staticCode: &quot;</span>+staticCode+<span class=\"string\">&quot;, instanceCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        </p>\n<p>使用这两个类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;---- new Child()&quot;</span>);</span><br><span class=\"line\">   Child child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- child.action()&quot;</span>);</span><br><span class=\"line\">   child.action();</span><br><span class=\"line\"></span><br><span class=\"line\">   Base base = child;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- base.action()&quot;</span>);</span><br><span class=\"line\">   base.action();</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- base.staticCode: &quot;</span>+base.staticCode);</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- child.staticCode: &quot;</span>+child.staticCode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>child.action()的具体执行过程如下：</p>\n<p>1.查看child的对象类型，找到Child类型。在Child类型中寻找action方法，发现没有，于是到Base类中寻找。</p>\n<p>2.在Base类中找到了action方法，开始执行该方法。</p>\n<p>3.action先输出start，再从Child类型寻找step方法。</p>\n<p>4.在Child类型中找到了step方法，执行它，然后返回action方法</p>\n<p>5.继续执行action方法， 输出end</p>\n<p><strong>寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。</strong></p>\n<p>base.action和child.action都是<strong>动态绑定</strong>，动态绑定实现的机制，就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。由于base和child指向的动态类型都是Child，所以执行结果一样。</p>\n<p>​    </p>\n<p>屏幕输入结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---- <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\">基类静态代码块，staticCode: <span class=\"number\">0</span></span><br><span class=\"line\">子类静态代码块，staticCode: <span class=\"number\">0</span></span><br><span class=\"line\">基类实例代码块，actualCode: <span class=\"number\">0</span></span><br><span class=\"line\">基类构造方法，actualCode: <span class=\"number\">1</span></span><br><span class=\"line\">子类实例代码块，instanceCode: <span class=\"number\">0</span></span><br><span class=\"line\">子类构造方法，instanceCode: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">---- child.action()</span><br><span class=\"line\">start</span><br><span class=\"line\">child staticCode: <span class=\"number\">10</span>, instanceCode: <span class=\"number\">20</span></span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">---- base.action()</span><br><span class=\"line\">start</span><br><span class=\"line\">child staticCode: <span class=\"number\">10</span>, instanceCode: <span class=\"number\">20</span></span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">---- base.staticCode: <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">---- child.staticCode: <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p><strong>类的加载</strong></p>\n<p>在java中，类是动态加载的。</p>\n<p>第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载。如果没有，则加载其父类。</p>\n<p>​    </p>\n<p>一个类的信息，主要包括以下部分：</p>\n<ul>\n<li><p>static变量</p>\n</li>\n<li><p>类初始化代码</p>\n</li>\n<li><p>static方法</p>\n</li>\n<li><p>实例变量</p>\n</li>\n<li><p>实例初始化代码</p>\n</li>\n<li><p>实例方法</p>\n</li>\n<li><p>父类信息引用</p>\n</li>\n</ul>\n<p>类初始化代码包括：</p>\n<ul>\n<li><p>定义static变量时的赋值语句</p>\n</li>\n<li><p>static初始化代码块</p>\n</li>\n</ul>\n<p>实例初始化代码包括：</p>\n<ul>\n<li>定义实例变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造方法</li>\n</ul>\n<p>类加载过程包括：</p>\n<ul>\n<li><p>分配内存，保存类的信息</p>\n</li>\n<li><p>给static变量赋默认值</p>\n</li>\n<li><p>加载父类</p>\n</li>\n<li><p>设置父子关系</p>\n</li>\n<li><p>执行类初始化代码</p>\n</li>\n</ul>\n<p>类初始化代码，是先执行父类，再执行子类。</p>\n<p>父类执行时，子类static变量是有值的，为默认值。</p>\n<p>​    </p>\n<p>类的信息放在<strong>内存区</strong>，在java中称为<strong>方法区</strong>。</p>\n<p><img src=\"https://i.loli.net/2021/09/17/ur9HsMUE4vA2niQ.jpg\" alt=\"继承实现.jpg\"></p>\n<p>如上图，class_init()表示类初始化代码，instance_init()表示实例初始化代码。实例初始化代码包括了实例初始化代码块和构造方法。</p>\n<p>​    </p>\n<p>对于上方的Base类和Child类，它们的内存布局就像图中的方法区。</p>\n<p>​    </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本节主要从概念上来介绍原理。</p>\n<p>​    </p>\n<p>首先创建一个基类Base，Base中包含实例变量instanceCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法、step方法和action方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> instanceCode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;基类静态代码块，staticCode: &quot;</span>+staticCode);</span><br><span class=\"line\">        staticCode = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;基类实例代码块，actualCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">        instanceCode = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;基类构造方法，actualCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">        instanceCode = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;base staticCode: &quot;</span>+staticCode+<span class=\"string\">&quot;, actualCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">action</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">        step();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​     </p>\n<p>接下来设计出继承Base的子类Child，Child同样包含实例变量actualCode、静态变量staticCode、一段静态初始化代码块、一段实例初始化代码块、一个构造方法，并且重写了step方法。</p>\n<p>Child类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> instanceCode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类静态代码块，staticCode: &quot;</span>+staticCode);</span><br><span class=\"line\">        staticCode = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类实例代码块，instanceCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类构造方法，instanceCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">        instanceCode = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">step</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;child staticCode: &quot;</span>+staticCode+<span class=\"string\">&quot;, instanceCode: &quot;</span>+instanceCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        </p>\n<p>使用这两个类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;---- new Child()&quot;</span>);</span><br><span class=\"line\">   Child child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- child.action()&quot;</span>);</span><br><span class=\"line\">   child.action();</span><br><span class=\"line\"></span><br><span class=\"line\">   Base base = child;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- base.action()&quot;</span>);</span><br><span class=\"line\">   base.action();</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- base.staticCode: &quot;</span>+base.staticCode);</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;\\n---- child.staticCode: &quot;</span>+child.staticCode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>child.action()的具体执行过程如下：</p>\n<p>1.查看child的对象类型，找到Child类型。在Child类型中寻找action方法，发现没有，于是到Base类中寻找。</p>\n<p>2.在Base类中找到了action方法，开始执行该方法。</p>\n<p>3.action先输出start，再从Child类型寻找step方法。</p>\n<p>4.在Child类型中找到了step方法，执行它，然后返回action方法</p>\n<p>5.继续执行action方法， 输出end</p>\n<p><strong>寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。</strong></p>\n<p>base.action和child.action都是<strong>动态绑定</strong>，动态绑定实现的机制，就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。由于base和child指向的动态类型都是Child，所以执行结果一样。</p>\n<p>​    </p>\n<p>屏幕输入结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---- <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\">基类静态代码块，staticCode: <span class=\"number\">0</span></span><br><span class=\"line\">子类静态代码块，staticCode: <span class=\"number\">0</span></span><br><span class=\"line\">基类实例代码块，actualCode: <span class=\"number\">0</span></span><br><span class=\"line\">基类构造方法，actualCode: <span class=\"number\">1</span></span><br><span class=\"line\">子类实例代码块，instanceCode: <span class=\"number\">0</span></span><br><span class=\"line\">子类构造方法，instanceCode: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">---- child.action()</span><br><span class=\"line\">start</span><br><span class=\"line\">child staticCode: <span class=\"number\">10</span>, instanceCode: <span class=\"number\">20</span></span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">---- base.action()</span><br><span class=\"line\">start</span><br><span class=\"line\">child staticCode: <span class=\"number\">10</span>, instanceCode: <span class=\"number\">20</span></span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">---- base.staticCode: <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">---- child.staticCode: <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p><strong>类的加载</strong></p>\n<p>在java中，类是动态加载的。</p>\n<p>第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载。如果没有，则加载其父类。</p>\n<p>​    </p>\n<p>一个类的信息，主要包括以下部分：</p>\n<ul>\n<li><p>static变量</p>\n</li>\n<li><p>类初始化代码</p>\n</li>\n<li><p>static方法</p>\n</li>\n<li><p>实例变量</p>\n</li>\n<li><p>实例初始化代码</p>\n</li>\n<li><p>实例方法</p>\n</li>\n<li><p>父类信息引用</p>\n</li>\n</ul>\n<p>类初始化代码包括：</p>\n<ul>\n<li><p>定义static变量时的赋值语句</p>\n</li>\n<li><p>static初始化代码块</p>\n</li>\n</ul>\n<p>实例初始化代码包括：</p>\n<ul>\n<li>定义实例变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造方法</li>\n</ul>\n<p>类加载过程包括：</p>\n<ul>\n<li><p>分配内存，保存类的信息</p>\n</li>\n<li><p>给static变量赋默认值</p>\n</li>\n<li><p>加载父类</p>\n</li>\n<li><p>设置父子关系</p>\n</li>\n<li><p>执行类初始化代码</p>\n</li>\n</ul>\n<p>类初始化代码，是先执行父类，再执行子类。</p>\n<p>父类执行时，子类static变量是有值的，为默认值。</p>\n<p>​    </p>\n<p>类的信息放在<strong>内存区</strong>，在java中称为<strong>方法区</strong>。</p>\n<p><img src=\"https://i.loli.net/2021/09/17/ur9HsMUE4vA2niQ.jpg\" alt=\"继承实现.jpg\"></p>\n<p>如上图，class_init()表示类初始化代码，instance_init()表示实例初始化代码。实例初始化代码包括了实例初始化代码块和构造方法。</p>\n<p>​    </p>\n<p>对于上方的Base类和Child类，它们的内存布局就像图中的方法区。</p>\n<p>​    </p>\n"},{"title":"虚方法表","date":"2021-09-17T12:25:48.000Z","_content":"\n如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。\n\n大多数系统使用一种称为**虚方法表**的方法来优化调用的效率。\n\n![虚方法表.jpg](https://i.loli.net/2021/09/17/YFbxOS6PBJDyp3q.jpg)\n\n**虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。**\n\n​    \n\n虚方法表在类加载的时候生成，当通过对象动态绑定方法的时候，只需要查找这个表就可以了，不需要挨个查找每个父类。\n\n","source":"_posts/虚方法表.md","raw":"---\ntitle: 虚方法表\ndate: 2021-09-17 20:25:48\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n\n如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。\n\n大多数系统使用一种称为**虚方法表**的方法来优化调用的效率。\n\n![虚方法表.jpg](https://i.loli.net/2021/09/17/YFbxOS6PBJDyp3q.jpg)\n\n**虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。**\n\n​    \n\n虚方法表在类加载的时候生成，当通过对象动态绑定方法的时候，只需要查找这个表就可以了，不需要挨个查找每个父类。\n\n","slug":"虚方法表","published":1,"updated":"2021-09-26T11:46:29.596Z","_id":"cktpp9ve4000088ui40mj3fog","comments":1,"layout":"post","photos":[],"link":"","content":"<p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。</p>\n<p>大多数系统使用一种称为<strong>虚方法表</strong>的方法来优化调用的效率。</p>\n<p><img src=\"https://i.loli.net/2021/09/17/YFbxOS6PBJDyp3q.jpg\" alt=\"虚方法表.jpg\"></p>\n<p><strong>虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。</strong></p>\n<p>​    </p>\n<p>虚方法表在类加载的时候生成，当通过对象动态绑定方法的时候，只需要查找这个表就可以了，不需要挨个查找每个父类。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。</p>\n<p>大多数系统使用一种称为<strong>虚方法表</strong>的方法来优化调用的效率。</p>\n<p><img src=\"https://i.loli.net/2021/09/17/YFbxOS6PBJDyp3q.jpg\" alt=\"虚方法表.jpg\"></p>\n<p><strong>虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。</strong></p>\n<p>​    </p>\n<p>虚方法表在类加载的时候生成，当通过对象动态绑定方法的时候，只需要查找这个表就可以了，不需要挨个查找每个父类。</p>\n"},{"title":"破坏封装的继承是一把双刃剑","date":"2021-09-27T06:54:05.000Z","_content":"**封装：隐藏实现细节。**\n\n继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。\n\n​    \n\n对于子类而言，通过继承实现，是没有安全保障的，父类修改内部实现细节，它的功能就可能会被破坏。\n\n对于父类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n​    \n\n**正确使用继承**\n\n编写子类时，需要注意的是：\n\n1.重写方法不要改变预期的行为。\n\n2.阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的调用关系。\n\n3.在基类修改的情况下，阅读其修改说明，相应修改子类。\n\n​    \n\n编写基类时，需要注意的是：\n\n1.使用继承反应真正的“is-a”关系，只将真正公共的部分放到基类。\n\n2.对不希望被重写的公开方法添加**final**修饰符。\n\n3.写文档，说明可重写方法的实现机制，为子类提供倡导，告诉子类应该如何重写。\n\n4.在基类修改可能影响子类时，写修改说明。\n\n","source":"_posts/破坏封装的继承是一把双刃剑.md","raw":"---\ntitle: 破坏封装的继承是一把双刃剑\ndate: 2021-09-27 14:54:05\ntags:\n - java\n - class\n - extends\ncategories: java\n---\n**封装：隐藏实现细节。**\n\n继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。\n\n​    \n\n对于子类而言，通过继承实现，是没有安全保障的，父类修改内部实现细节，它的功能就可能会被破坏。\n\n对于父类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n​    \n\n**正确使用继承**\n\n编写子类时，需要注意的是：\n\n1.重写方法不要改变预期的行为。\n\n2.阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的调用关系。\n\n3.在基类修改的情况下，阅读其修改说明，相应修改子类。\n\n​    \n\n编写基类时，需要注意的是：\n\n1.使用继承反应真正的“is-a”关系，只将真正公共的部分放到基类。\n\n2.对不希望被重写的公开方法添加**final**修饰符。\n\n3.写文档，说明可重写方法的实现机制，为子类提供倡导，告诉子类应该如何重写。\n\n4.在基类修改可能影响子类时，写修改说明。\n\n","slug":"破坏封装的继承是一把双刃剑","published":1,"updated":"2021-09-27T08:21:48.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku2dtxbs0000foui7i1i2zcm","content":"<p><strong>封装：隐藏实现细节。</strong></p>\n<p>继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。</p>\n<p>​    </p>\n<p>对于子类而言，通过继承实现，是没有安全保障的，父类修改内部实现细节，它的功能就可能会被破坏。</p>\n<p>对于父类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</p>\n<p>​    </p>\n<p><strong>正确使用继承</strong></p>\n<p>编写子类时，需要注意的是：</p>\n<p>1.重写方法不要改变预期的行为。</p>\n<p>2.阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的调用关系。</p>\n<p>3.在基类修改的情况下，阅读其修改说明，相应修改子类。</p>\n<p>​    </p>\n<p>编写基类时，需要注意的是：</p>\n<p>1.使用继承反应真正的“is-a”关系，只将真正公共的部分放到基类。</p>\n<p>2.对不希望被重写的公开方法添加<strong>final</strong>修饰符。</p>\n<p>3.写文档，说明可重写方法的实现机制，为子类提供倡导，告诉子类应该如何重写。</p>\n<p>4.在基类修改可能影响子类时，写修改说明。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>封装：隐藏实现细节。</strong></p>\n<p>继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。</p>\n<p>​    </p>\n<p>对于子类而言，通过继承实现，是没有安全保障的，父类修改内部实现细节，它的功能就可能会被破坏。</p>\n<p>对于父类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</p>\n<p>​    </p>\n<p><strong>正确使用继承</strong></p>\n<p>编写子类时，需要注意的是：</p>\n<p>1.重写方法不要改变预期的行为。</p>\n<p>2.阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的调用关系。</p>\n<p>3.在基类修改的情况下，阅读其修改说明，相应修改子类。</p>\n<p>​    </p>\n<p>编写基类时，需要注意的是：</p>\n<p>1.使用继承反应真正的“is-a”关系，只将真正公共的部分放到基类。</p>\n<p>2.对不希望被重写的公开方法添加<strong>final</strong>修饰符。</p>\n<p>3.写文档，说明可重写方法的实现机制，为子类提供倡导，告诉子类应该如何重写。</p>\n<p>4.在基类修改可能影响子类时，写修改说明。</p>\n"},{"title":"接口的本质","date":"2021-09-27T08:27:56.000Z","_content":"\n很多时候 ，我们实际上关心的，**不是对象的类型，而是对象的能力**。\n\n比如要将冷水加热，只要得到热水即可。至于是用电磁炉还是燃气灶还是电热壶加热，并不重要。重要的是对象是否有加热水的能力。\n\n​     \n\nJava使用**接口**这个概念来表示能力。\n\n接口声明了一组能力，但它自己并没有实现这个能力，它只是一个约定。\n\n它涉及交互两方对象，一方需要实现这个接口，另一方使用这个接口，但双方对象并不直接互相依赖，它们只是通过接口间接交互。\n\n![通过接口间接交互](https://i.loli.net/2021/09/27/otRMdc2ki15fnSz.png)\n\n​    \n\n**定义接口**\n\n首先定义一个用来比较的接口，叫MyComparable。\n\n```java\npublic interface MyComparable {\n    int compareTo(Object other);\t//比较自己和other，返回-1表示自己更小，0表示相同，1表示自己更大。\n}\n```\n\n**interface**关键字声明接口，修饰符一般都是public。\n\nMyComparable接口定义里，声明了一个方法compareTo，但没有定义方法体，**接口都不实现方法**。接口方法不需要加修饰符，加与不加都是public的，不能是别的修饰符。\n\n接口与类不同，它的方法没有实现代码。接口还需要至少两个参与者，一个需要实现接口，另一个使用接口。\n\n​    \n\n**实现接口**\n\n类可以实现接口，表示类的对象具有接口所表示的能力。\n\n假设让Point类计算出到原点的距离，再将距离进行比较。\n\n```java\npublic class Point implements MyComparable{\n    private int x;\n    private int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distance(){\n        return Math.sqrt(x*x+y*y);\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\"+x+\",\"+y+\")\";\n    }\n\n    //实现MyComparable接口\n    @Override\n    public int compareTo(Object other) {\n        if (!(other instanceof Point)) {\t//判断other是否是Point类型的实例\n            throw new IllegalArgumentException(); //非法参数异常\n        }\n        Point otherPoint = (Point)other;\n        double delta = distance() - otherPoint.distance();\n        if(delta < 0) {\n            return -1;\n        }else if (delta > 0) {\n            return 1;\n        }else {\n            return 0;\n        }\n    }\n}\n```\n\njava使用**implements**关键字表示实现接口，前面是类名，后面是接口名。\n\njava的普通类实现接口，必须要实现接口中声明的每一个方法。\n\n​    \n\n**一个类可以实现多个接口**，表明类的对象具备多种能力，**各个接口之间以逗号分隔**，语法如下：\n\n```java\npublic class Test implements Interface1, Interface2 {\n    ...\n}\n```\n\n​    \n\n​    \n\n**使用接口**\n\n与类不同，**接口不能new**，不能直接创建一个接口对象，对象只能通过类来创建。但可以**声明接口类型的变量，引用实现了接口的类对象**。\n\n例如：\n\n```java\n//声明MyComparable类型的变量，引用Point对象。\nMyComparable p1 = new Point(2,3);\nMyComparable p2 = new Point(1,2);\nSystem.out.println(p1.compareTo(p2));\n```\n\np1和p2是MyComparable类型的变量，但引用了Point类型的对象，之所以能赋值是因为Point实现了MyComparable接口。\n\n如果一个类型实现了多个接口，那这种类型的对象就可以被赋值给任一接口类型的变量。\n\np1和p2能且只能调用MyComparable接口的方法。实际执行时，执行的是具体实现类的代码。\n\n","source":"_posts/接口的本质.md","raw":"---\ntitle: 接口的本质\ndate: 2021-09-27 16:27:56\ntags:\n - java\n - class\n - interface\ncategories: java\n---\n\n很多时候 ，我们实际上关心的，**不是对象的类型，而是对象的能力**。\n\n比如要将冷水加热，只要得到热水即可。至于是用电磁炉还是燃气灶还是电热壶加热，并不重要。重要的是对象是否有加热水的能力。\n\n​     \n\nJava使用**接口**这个概念来表示能力。\n\n接口声明了一组能力，但它自己并没有实现这个能力，它只是一个约定。\n\n它涉及交互两方对象，一方需要实现这个接口，另一方使用这个接口，但双方对象并不直接互相依赖，它们只是通过接口间接交互。\n\n![通过接口间接交互](https://i.loli.net/2021/09/27/otRMdc2ki15fnSz.png)\n\n​    \n\n**定义接口**\n\n首先定义一个用来比较的接口，叫MyComparable。\n\n```java\npublic interface MyComparable {\n    int compareTo(Object other);\t//比较自己和other，返回-1表示自己更小，0表示相同，1表示自己更大。\n}\n```\n\n**interface**关键字声明接口，修饰符一般都是public。\n\nMyComparable接口定义里，声明了一个方法compareTo，但没有定义方法体，**接口都不实现方法**。接口方法不需要加修饰符，加与不加都是public的，不能是别的修饰符。\n\n接口与类不同，它的方法没有实现代码。接口还需要至少两个参与者，一个需要实现接口，另一个使用接口。\n\n​    \n\n**实现接口**\n\n类可以实现接口，表示类的对象具有接口所表示的能力。\n\n假设让Point类计算出到原点的距离，再将距离进行比较。\n\n```java\npublic class Point implements MyComparable{\n    private int x;\n    private int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distance(){\n        return Math.sqrt(x*x+y*y);\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\"+x+\",\"+y+\")\";\n    }\n\n    //实现MyComparable接口\n    @Override\n    public int compareTo(Object other) {\n        if (!(other instanceof Point)) {\t//判断other是否是Point类型的实例\n            throw new IllegalArgumentException(); //非法参数异常\n        }\n        Point otherPoint = (Point)other;\n        double delta = distance() - otherPoint.distance();\n        if(delta < 0) {\n            return -1;\n        }else if (delta > 0) {\n            return 1;\n        }else {\n            return 0;\n        }\n    }\n}\n```\n\njava使用**implements**关键字表示实现接口，前面是类名，后面是接口名。\n\njava的普通类实现接口，必须要实现接口中声明的每一个方法。\n\n​    \n\n**一个类可以实现多个接口**，表明类的对象具备多种能力，**各个接口之间以逗号分隔**，语法如下：\n\n```java\npublic class Test implements Interface1, Interface2 {\n    ...\n}\n```\n\n​    \n\n​    \n\n**使用接口**\n\n与类不同，**接口不能new**，不能直接创建一个接口对象，对象只能通过类来创建。但可以**声明接口类型的变量，引用实现了接口的类对象**。\n\n例如：\n\n```java\n//声明MyComparable类型的变量，引用Point对象。\nMyComparable p1 = new Point(2,3);\nMyComparable p2 = new Point(1,2);\nSystem.out.println(p1.compareTo(p2));\n```\n\np1和p2是MyComparable类型的变量，但引用了Point类型的对象，之所以能赋值是因为Point实现了MyComparable接口。\n\n如果一个类型实现了多个接口，那这种类型的对象就可以被赋值给任一接口类型的变量。\n\np1和p2能且只能调用MyComparable接口的方法。实际执行时，执行的是具体实现类的代码。\n\n","slug":"接口的本质","published":1,"updated":"2021-09-27T10:35:34.728Z","_id":"cku2f2qcw0000wkui6b8c706h","comments":1,"layout":"post","photos":[],"link":"","content":"<p>很多时候 ，我们实际上关心的，<strong>不是对象的类型，而是对象的能力</strong>。</p>\n<p>比如要将冷水加热，只要得到热水即可。至于是用电磁炉还是燃气灶还是电热壶加热，并不重要。重要的是对象是否有加热水的能力。</p>\n<p>​     </p>\n<p>Java使用<strong>接口</strong>这个概念来表示能力。</p>\n<p>接口声明了一组能力，但它自己并没有实现这个能力，它只是一个约定。</p>\n<p>它涉及交互两方对象，一方需要实现这个接口，另一方使用这个接口，但双方对象并不直接互相依赖，它们只是通过接口间接交互。</p>\n<p><img src=\"https://i.loli.net/2021/09/27/otRMdc2ki15fnSz.png\" alt=\"通过接口间接交互\"></p>\n<p>​    </p>\n<p><strong>定义接口</strong></p>\n<p>首先定义一个用来比较的接口，叫MyComparable。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyComparable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Object other)</span></span>;\t<span class=\"comment\">//比较自己和other，返回-1表示自己更小，0表示相同，1表示自己更大。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>interface</strong>关键字声明接口，修饰符一般都是public。</p>\n<p>MyComparable接口定义里，声明了一个方法compareTo，但没有定义方法体，<strong>接口都不实现方法</strong>。接口方法不需要加修饰符，加与不加都是public的，不能是别的修饰符。</p>\n<p>接口与类不同，它的方法没有实现代码。接口还需要至少两个参与者，一个需要实现接口，另一个使用接口。</p>\n<p>​    </p>\n<p><strong>实现接口</strong></p>\n<p>类可以实现接口，表示类的对象具有接口所表示的能力。</p>\n<p>假设让Point类计算出到原点的距离，再将距离进行比较。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">MyComparable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(x*x+y*y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span>+x+<span class=\"string\">&quot;,&quot;</span>+y+<span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//实现MyComparable接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Object other)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(other <span class=\"keyword\">instanceof</span> Point)) &#123;\t<span class=\"comment\">//判断other是否是Point类型的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(); <span class=\"comment\">//非法参数异常</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Point otherPoint = (Point)other;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> delta = distance() - otherPoint.distance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delta &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>java使用<strong>implements</strong>关键字表示实现接口，前面是类名，后面是接口名。</p>\n<p>java的普通类实现接口，必须要实现接口中声明的每一个方法。</p>\n<p>​    </p>\n<p><strong>一个类可以实现多个接口</strong>，表明类的对象具备多种能力，<strong>各个接口之间以逗号分隔</strong>，语法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">Interface1</span>, <span class=\"title\">Interface2</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>​    </p>\n<p><strong>使用接口</strong></p>\n<p>与类不同，<strong>接口不能new</strong>，不能直接创建一个接口对象，对象只能通过类来创建。但可以<strong>声明接口类型的变量，引用实现了接口的类对象</strong>。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明MyComparable类型的变量，引用Point对象。</span></span><br><span class=\"line\">MyComparable p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">MyComparable p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(p1.compareTo(p2));</span><br></pre></td></tr></table></figure>\n\n<p>p1和p2是MyComparable类型的变量，但引用了Point类型的对象，之所以能赋值是因为Point实现了MyComparable接口。</p>\n<p>如果一个类型实现了多个接口，那这种类型的对象就可以被赋值给任一接口类型的变量。</p>\n<p>p1和p2能且只能调用MyComparable接口的方法。实际执行时，执行的是具体实现类的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很多时候 ，我们实际上关心的，<strong>不是对象的类型，而是对象的能力</strong>。</p>\n<p>比如要将冷水加热，只要得到热水即可。至于是用电磁炉还是燃气灶还是电热壶加热，并不重要。重要的是对象是否有加热水的能力。</p>\n<p>​     </p>\n<p>Java使用<strong>接口</strong>这个概念来表示能力。</p>\n<p>接口声明了一组能力，但它自己并没有实现这个能力，它只是一个约定。</p>\n<p>它涉及交互两方对象，一方需要实现这个接口，另一方使用这个接口，但双方对象并不直接互相依赖，它们只是通过接口间接交互。</p>\n<p><img src=\"https://i.loli.net/2021/09/27/otRMdc2ki15fnSz.png\" alt=\"通过接口间接交互\"></p>\n<p>​    </p>\n<p><strong>定义接口</strong></p>\n<p>首先定义一个用来比较的接口，叫MyComparable。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyComparable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Object other)</span></span>;\t<span class=\"comment\">//比较自己和other，返回-1表示自己更小，0表示相同，1表示自己更大。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>interface</strong>关键字声明接口，修饰符一般都是public。</p>\n<p>MyComparable接口定义里，声明了一个方法compareTo，但没有定义方法体，<strong>接口都不实现方法</strong>。接口方法不需要加修饰符，加与不加都是public的，不能是别的修饰符。</p>\n<p>接口与类不同，它的方法没有实现代码。接口还需要至少两个参与者，一个需要实现接口，另一个使用接口。</p>\n<p>​    </p>\n<p><strong>实现接口</strong></p>\n<p>类可以实现接口，表示类的对象具有接口所表示的能力。</p>\n<p>假设让Point类计算出到原点的距离，再将距离进行比较。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">MyComparable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(x*x+y*y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span>+x+<span class=\"string\">&quot;,&quot;</span>+y+<span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//实现MyComparable接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Object other)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(other <span class=\"keyword\">instanceof</span> Point)) &#123;\t<span class=\"comment\">//判断other是否是Point类型的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(); <span class=\"comment\">//非法参数异常</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Point otherPoint = (Point)other;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> delta = distance() - otherPoint.distance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delta &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>java使用<strong>implements</strong>关键字表示实现接口，前面是类名，后面是接口名。</p>\n<p>java的普通类实现接口，必须要实现接口中声明的每一个方法。</p>\n<p>​    </p>\n<p><strong>一个类可以实现多个接口</strong>，表明类的对象具备多种能力，<strong>各个接口之间以逗号分隔</strong>，语法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">Interface1</span>, <span class=\"title\">Interface2</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>​    </p>\n<p><strong>使用接口</strong></p>\n<p>与类不同，<strong>接口不能new</strong>，不能直接创建一个接口对象，对象只能通过类来创建。但可以<strong>声明接口类型的变量，引用实现了接口的类对象</strong>。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明MyComparable类型的变量，引用Point对象。</span></span><br><span class=\"line\">MyComparable p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">MyComparable p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(p1.compareTo(p2));</span><br></pre></td></tr></table></figure>\n\n<p>p1和p2是MyComparable类型的变量，但引用了Point类型的对象，之所以能赋值是因为Point实现了MyComparable接口。</p>\n<p>如果一个类型实现了多个接口，那这种类型的对象就可以被赋值给任一接口类型的变量。</p>\n<p>p1和p2能且只能调用MyComparable接口的方法。实际执行时，执行的是具体实现类的代码。</p>\n"},{"title":"针对接口而非具体类型的编程","date":"2021-09-27T10:38:00.000Z","_content":"在一些程序中，代码并不知道具体的类型，才是接口发挥威力的地方。\n\n举个栗子，一个使用MyComparable接口的类CompUtil，代码如下：\n\n```java\npublic class CompUtil {\n    //找出最大值\n    public static Object max(MyComparable[] objs) {\n        //objs为空\n        if (objs == null || objs.length == 0) {\n            return null;\n        }\n        MyComparable max = objs[0];\n        for (int i=1;i<objs.length;i++) {\n            if (max.compareTo(objs[i]) < 0) {\n                max = objs[i];\n            }\n        }\n        return max;\n    }\n    //从小到大排序\n    public static void sort(MyComparable[] objs) {\n        for (int i=0;i<objs.length;i++) {\n            int min = i;\n            for (int j=i+1;j<objs.length;j++) {\n                if (objs[j].compareTo(objs[min])<0) {\n                    min = j;\n                }\n            }\n            if (min!=i) {\n                MyComparable temp = objs[i];\n                objs[i] = objs[min];\n                objs[min] = temp;\n            }\n        }\n    }\n}\n```\n\nCompUtil类提供了两个方法，max获取传入数组中的最大值，sort对数组进行升序排序，参数都是MyComparable类型的的数组。\n\n这个类是针对MyComparable接口编程，它并不知道具体的类型是什么，也并不关心，但却可以对任意实现了MyComparable接口的类型进行操作。\n\n​    \n\n接下来对Point类型进行操作：\n\n```java\nPoint[] points = new Point[] {\n      new Point(2,3),\n      new Point(3,4),\n      new Point(1,2)\n};\n\nSystem.out.println(\"max: \" + CompUtil.max(points));\nCompUtil.sort(points);\nSystem.out.println(\"sort: \" + Arrays.toString(points));\n```\n\npoints可以作为MyComparable[]类型的参数。实际上，可以针对任何实现了MyComparable接口的类型数组进行操作。\n\n​    \n\n**针对接口而非具体类型进行编程，是计算机程序的一种重要思维方式。**\n\n接口的优点：\n\n1.代码复用。同一套代码可以处理多种不同类型的对象，只要这些对象都有相同的能力。\n\n2.降低了耦合，提高了灵活性。使用接口的代码依赖的是接口本身，而非实现接口的具体类型。\n\n\n\n\n\n","source":"_posts/针对接口而非具体类型的编程.md","raw":"---\ntitle: 针对接口而非具体类型的编程\ndate: 2021-09-27 18:38:00\ntags:\n - java\n - class\n - interface\ncategories: java\n---\n在一些程序中，代码并不知道具体的类型，才是接口发挥威力的地方。\n\n举个栗子，一个使用MyComparable接口的类CompUtil，代码如下：\n\n```java\npublic class CompUtil {\n    //找出最大值\n    public static Object max(MyComparable[] objs) {\n        //objs为空\n        if (objs == null || objs.length == 0) {\n            return null;\n        }\n        MyComparable max = objs[0];\n        for (int i=1;i<objs.length;i++) {\n            if (max.compareTo(objs[i]) < 0) {\n                max = objs[i];\n            }\n        }\n        return max;\n    }\n    //从小到大排序\n    public static void sort(MyComparable[] objs) {\n        for (int i=0;i<objs.length;i++) {\n            int min = i;\n            for (int j=i+1;j<objs.length;j++) {\n                if (objs[j].compareTo(objs[min])<0) {\n                    min = j;\n                }\n            }\n            if (min!=i) {\n                MyComparable temp = objs[i];\n                objs[i] = objs[min];\n                objs[min] = temp;\n            }\n        }\n    }\n}\n```\n\nCompUtil类提供了两个方法，max获取传入数组中的最大值，sort对数组进行升序排序，参数都是MyComparable类型的的数组。\n\n这个类是针对MyComparable接口编程，它并不知道具体的类型是什么，也并不关心，但却可以对任意实现了MyComparable接口的类型进行操作。\n\n​    \n\n接下来对Point类型进行操作：\n\n```java\nPoint[] points = new Point[] {\n      new Point(2,3),\n      new Point(3,4),\n      new Point(1,2)\n};\n\nSystem.out.println(\"max: \" + CompUtil.max(points));\nCompUtil.sort(points);\nSystem.out.println(\"sort: \" + Arrays.toString(points));\n```\n\npoints可以作为MyComparable[]类型的参数。实际上，可以针对任何实现了MyComparable接口的类型数组进行操作。\n\n​    \n\n**针对接口而非具体类型进行编程，是计算机程序的一种重要思维方式。**\n\n接口的优点：\n\n1.代码复用。同一套代码可以处理多种不同类型的对象，只要这些对象都有相同的能力。\n\n2.降低了耦合，提高了灵活性。使用接口的代码依赖的是接口本身，而非实现接口的具体类型。\n\n\n\n\n\n","slug":"针对接口而非具体类型的编程","published":1,"updated":"2021-09-28T03:05:30.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3hz0gp0000b4uih4j696yp","content":"<p>在一些程序中，代码并不知道具体的类型，才是接口发挥威力的地方。</p>\n<p>举个栗子，一个使用MyComparable接口的类CompUtil，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找出最大值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">max</span><span class=\"params\">(MyComparable[] objs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//objs为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (objs == <span class=\"keyword\">null</span> || objs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MyComparable max = objs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;objs.length;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (max.compareTo(objs[i]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                max = objs[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//从小到大排序</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(MyComparable[] objs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;objs.length;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;objs.length;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (objs[j].compareTo(objs[min])&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    min = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min!=i) &#123;</span><br><span class=\"line\">                MyComparable temp = objs[i];</span><br><span class=\"line\">                objs[i] = objs[min];</span><br><span class=\"line\">                objs[min] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CompUtil类提供了两个方法，max获取传入数组中的最大值，sort对数组进行升序排序，参数都是MyComparable类型的的数组。</p>\n<p>这个类是针对MyComparable接口编程，它并不知道具体的类型是什么，也并不关心，但却可以对任意实现了MyComparable接口的类型进行操作。</p>\n<p>​    </p>\n<p>接下来对Point类型进行操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point[] points = <span class=\"keyword\">new</span> Point[] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>),</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">4</span>),</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;max: &quot;</span> + CompUtil.max(points));</span><br><span class=\"line\">CompUtil.sort(points);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;sort: &quot;</span> + Arrays.toString(points));</span><br></pre></td></tr></table></figure>\n\n<p>points可以作为MyComparable[]类型的参数。实际上，可以针对任何实现了MyComparable接口的类型数组进行操作。</p>\n<p>​    </p>\n<p><strong>针对接口而非具体类型进行编程，是计算机程序的一种重要思维方式。</strong></p>\n<p>接口的优点：</p>\n<p>1.代码复用。同一套代码可以处理多种不同类型的对象，只要这些对象都有相同的能力。</p>\n<p>2.降低了耦合，提高了灵活性。使用接口的代码依赖的是接口本身，而非实现接口的具体类型。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一些程序中，代码并不知道具体的类型，才是接口发挥威力的地方。</p>\n<p>举个栗子，一个使用MyComparable接口的类CompUtil，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找出最大值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">max</span><span class=\"params\">(MyComparable[] objs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//objs为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (objs == <span class=\"keyword\">null</span> || objs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MyComparable max = objs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;objs.length;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (max.compareTo(objs[i]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                max = objs[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//从小到大排序</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(MyComparable[] objs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;objs.length;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;objs.length;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (objs[j].compareTo(objs[min])&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    min = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min!=i) &#123;</span><br><span class=\"line\">                MyComparable temp = objs[i];</span><br><span class=\"line\">                objs[i] = objs[min];</span><br><span class=\"line\">                objs[min] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CompUtil类提供了两个方法，max获取传入数组中的最大值，sort对数组进行升序排序，参数都是MyComparable类型的的数组。</p>\n<p>这个类是针对MyComparable接口编程，它并不知道具体的类型是什么，也并不关心，但却可以对任意实现了MyComparable接口的类型进行操作。</p>\n<p>​    </p>\n<p>接下来对Point类型进行操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point[] points = <span class=\"keyword\">new</span> Point[] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>),</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">4</span>),</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;max: &quot;</span> + CompUtil.max(points));</span><br><span class=\"line\">CompUtil.sort(points);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;sort: &quot;</span> + Arrays.toString(points));</span><br></pre></td></tr></table></figure>\n\n<p>points可以作为MyComparable[]类型的参数。实际上，可以针对任何实现了MyComparable接口的类型数组进行操作。</p>\n<p>​    </p>\n<p><strong>针对接口而非具体类型进行编程，是计算机程序的一种重要思维方式。</strong></p>\n<p>接口的优点：</p>\n<p>1.代码复用。同一套代码可以处理多种不同类型的对象，只要这些对象都有相同的能力。</p>\n<p>2.降低了耦合，提高了灵活性。使用接口的代码依赖的是接口本身，而非实现接口的具体类型。</p>\n"},{"title":"接口的细节","date":"2021-09-28T03:06:31.000Z","_content":"\n接口的四项细节：\n\n- 接口中的变量\n\n- 接口的继承\n\n- 类的继承与接口\n\n- instanceof\n\n​    \n\n**接口中的变量**\n\n接口中可以定义变量：\n\n```java\npublic interface Interface1 {\n    public static final int a =0;\n}\n```\n\n变量a可以通过“接口名.变量名”的方式使用，如Interface1.a。\n\n​    \n\n**接口的继承**\n\n接口可以继承别的接口，继承的基本概念与类一样。\n\n与类不同的是，**接口可以有多个父接口**。\n\n```java\npublic interface IBase1 {\n    void method1();\n}\n\npublic interface IBase2 {\n    void method2();\n}\n\npublic interface IChild extends IBase1,IBase2{\n}\n```\n\n接口的继承同样使用**extends**关键字，多个父接口之间以逗号分割。\n\n​    \n\n**类的继承与接口**\n\n类的继承与接口可以共存——类可以在继承基类的情况下，同时实现一个或多个接口。\n\n```java\npublic class Child extends Base implements IChild {\n    ...\n}\n```\n\n**entends要放在implements之前**。\n\n​    \n\n**instanceof**\n\n与类一样，接口也可以使用instanceof关键字，用来判断一个对象是否实现了某接口。\n\n```java\nPoint point = new Point(2,3);\nif (point instanceof MyComparable) {\n    System.out.println(\"comparable\");\n}\n```\n\n\n\n\n\n  \n\n","source":"_posts/接口的细节.md","raw":"---\ntitle: 接口的细节\ndate: 2021-09-28 11:06:31\ntags:\n - java\n - class\n - interface\ncategories: java\n---\n\n接口的四项细节：\n\n- 接口中的变量\n\n- 接口的继承\n\n- 类的继承与接口\n\n- instanceof\n\n​    \n\n**接口中的变量**\n\n接口中可以定义变量：\n\n```java\npublic interface Interface1 {\n    public static final int a =0;\n}\n```\n\n变量a可以通过“接口名.变量名”的方式使用，如Interface1.a。\n\n​    \n\n**接口的继承**\n\n接口可以继承别的接口，继承的基本概念与类一样。\n\n与类不同的是，**接口可以有多个父接口**。\n\n```java\npublic interface IBase1 {\n    void method1();\n}\n\npublic interface IBase2 {\n    void method2();\n}\n\npublic interface IChild extends IBase1,IBase2{\n}\n```\n\n接口的继承同样使用**extends**关键字，多个父接口之间以逗号分割。\n\n​    \n\n**类的继承与接口**\n\n类的继承与接口可以共存——类可以在继承基类的情况下，同时实现一个或多个接口。\n\n```java\npublic class Child extends Base implements IChild {\n    ...\n}\n```\n\n**entends要放在implements之前**。\n\n​    \n\n**instanceof**\n\n与类一样，接口也可以使用instanceof关键字，用来判断一个对象是否实现了某接口。\n\n```java\nPoint point = new Point(2,3);\nif (point instanceof MyComparable) {\n    System.out.println(\"comparable\");\n}\n```\n\n\n\n\n\n  \n\n","slug":"接口的细节","published":1,"updated":"2021-09-28T06:21:09.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3oyo5w0000jsui4qpbcdtx","content":"<p>接口的四项细节：</p>\n<ul>\n<li><p>接口中的变量</p>\n</li>\n<li><p>接口的继承</p>\n</li>\n<li><p>类的继承与接口</p>\n</li>\n<li><p>instanceof</p>\n</li>\n</ul>\n<p>​    </p>\n<p><strong>接口中的变量</strong></p>\n<p>接口中可以定义变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Interface1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> a =<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>变量a可以通过“接口名.变量名”的方式使用，如Interface1.a。</p>\n<p>​    </p>\n<p><strong>接口的继承</strong></p>\n<p>接口可以继承别的接口，继承的基本概念与类一样。</p>\n<p>与类不同的是，<strong>接口可以有多个父接口</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBase1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBase2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IChild</span> <span class=\"keyword\">extends</span> <span class=\"title\">IBase1</span>,<span class=\"title\">IBase2</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口的继承同样使用<strong>extends</strong>关键字，多个父接口之间以逗号分割。</p>\n<p>​    </p>\n<p><strong>类的继承与接口</strong></p>\n<p>类的继承与接口可以共存——类可以在继承基类的情况下，同时实现一个或多个接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> <span class=\"keyword\">implements</span> <span class=\"title\">IChild</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>entends要放在implements之前</strong>。</p>\n<p>​    </p>\n<p><strong>instanceof</strong></p>\n<p>与类一样，接口也可以使用instanceof关键字，用来判断一个对象是否实现了某接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (point <span class=\"keyword\">instanceof</span> MyComparable) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;comparable&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>接口的四项细节：</p>\n<ul>\n<li><p>接口中的变量</p>\n</li>\n<li><p>接口的继承</p>\n</li>\n<li><p>类的继承与接口</p>\n</li>\n<li><p>instanceof</p>\n</li>\n</ul>\n<p>​    </p>\n<p><strong>接口中的变量</strong></p>\n<p>接口中可以定义变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Interface1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> a =<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>变量a可以通过“接口名.变量名”的方式使用，如Interface1.a。</p>\n<p>​    </p>\n<p><strong>接口的继承</strong></p>\n<p>接口可以继承别的接口，继承的基本概念与类一样。</p>\n<p>与类不同的是，<strong>接口可以有多个父接口</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBase1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBase2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IChild</span> <span class=\"keyword\">extends</span> <span class=\"title\">IBase1</span>,<span class=\"title\">IBase2</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口的继承同样使用<strong>extends</strong>关键字，多个父接口之间以逗号分割。</p>\n<p>​    </p>\n<p><strong>类的继承与接口</strong></p>\n<p>类的继承与接口可以共存——类可以在继承基类的情况下，同时实现一个或多个接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> <span class=\"keyword\">implements</span> <span class=\"title\">IChild</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>entends要放在implements之前</strong>。</p>\n<p>​    </p>\n<p><strong>instanceof</strong></p>\n<p>与类一样，接口也可以使用instanceof关键字，用来判断一个对象是否实现了某接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (point <span class=\"keyword\">instanceof</span> MyComparable) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;comparable&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"使用接口替代继承","date":"2021-09-28T06:24:17.000Z","_content":"使用组合替代继承，可以复用代码，但不能统一处理。使用接口，针对接口编程，可以实现统一处理不同类型的对象，但接口没有代码实现，无法复用代码。\n\n**将组合和接口结合起来**，就既可以统一处理，也可以复用代码了。\n\n举个栗子：\n\n先增加一个接口IAdd：\n\n```java\npublic interface IAdd {\n    void add(int number);\n    void addAll(int[] numbers);\n}\n```\n\n修改Base类代码，让它实现IAdd接口，代码基本不变：\n\n```java\npublic class Base implements IAdd {\n    private static final int MAX_NUM = 1000;\n    private int[] arr = new int[MAX_NUM];\n    private int count;\n\n    public void add(int number) {\n        if (count < MAX_NUM) {\n            arr[count++] = number;\n        }\n    }\n\n    public void addAll(int[] numbers) {\n        for (int num : numbers) {\n            add(num);\n        }\n    }\n}\n```\n\n修改Child类代码，也是实现IAdd接口，代码基本不变：\n\n```java\npublic class Child implements IAdd{\n    private Base base;\n    private long sum;\n\n    public Child() {\n        base = new Base();\n    }\n\n    public void add(int number) {\n        base.add(number);\n        sum+=number;\n    }\n\n    public void addAll(int[] numbers) {\n        base.addAll(numbers);\n        for (int i=0;i<numbers.length;i++) {\n            sum+=numbers[i];\n        }\n    }\n\n    public long getSum() {\n        return sum;\n    }\n}\n```\n\n","source":"_posts/使用接口替代继承.md","raw":"---\ntitle: 使用接口替代继承\ndate: 2021-09-28 14:24:17\ntags:\n - java\n - class\n - interface\ncategories: java\n---\n使用组合替代继承，可以复用代码，但不能统一处理。使用接口，针对接口编程，可以实现统一处理不同类型的对象，但接口没有代码实现，无法复用代码。\n\n**将组合和接口结合起来**，就既可以统一处理，也可以复用代码了。\n\n举个栗子：\n\n先增加一个接口IAdd：\n\n```java\npublic interface IAdd {\n    void add(int number);\n    void addAll(int[] numbers);\n}\n```\n\n修改Base类代码，让它实现IAdd接口，代码基本不变：\n\n```java\npublic class Base implements IAdd {\n    private static final int MAX_NUM = 1000;\n    private int[] arr = new int[MAX_NUM];\n    private int count;\n\n    public void add(int number) {\n        if (count < MAX_NUM) {\n            arr[count++] = number;\n        }\n    }\n\n    public void addAll(int[] numbers) {\n        for (int num : numbers) {\n            add(num);\n        }\n    }\n}\n```\n\n修改Child类代码，也是实现IAdd接口，代码基本不变：\n\n```java\npublic class Child implements IAdd{\n    private Base base;\n    private long sum;\n\n    public Child() {\n        base = new Base();\n    }\n\n    public void add(int number) {\n        base.add(number);\n        sum+=number;\n    }\n\n    public void addAll(int[] numbers) {\n        base.addAll(numbers);\n        for (int i=0;i<numbers.length;i++) {\n            sum+=numbers[i];\n        }\n    }\n\n    public long getSum() {\n        return sum;\n    }\n}\n```\n\n","slug":"使用接口替代继承","published":1,"updated":"2021-09-28T07:23:48.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3r74m00000v8ui1t5h0xqe","content":"<p>使用组合替代继承，可以复用代码，但不能统一处理。使用接口，针对接口编程，可以实现统一处理不同类型的对象，但接口没有代码实现，无法复用代码。</p>\n<p><strong>将组合和接口结合起来</strong>，就既可以统一处理，也可以复用代码了。</p>\n<p>举个栗子：</p>\n<p>先增加一个接口IAdd：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAdd</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改Base类代码，让它实现IAdd接口，代码基本不变：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> <span class=\"keyword\">implements</span> <span class=\"title\">IAdd</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_NUM = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[MAX_NUM];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt; MAX_NUM) &#123;</span><br><span class=\"line\">            arr[count++] = number;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : numbers) &#123;</span><br><span class=\"line\">            add(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改Child类代码，也是实现IAdd接口，代码基本不变：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">IAdd</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Base base;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        base = <span class=\"keyword\">new</span> Base();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        base.add(number);</span><br><span class=\"line\">        sum+=number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        base.addAll(numbers);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numbers.length;i++) &#123;</span><br><span class=\"line\">            sum+=numbers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getSum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>使用组合替代继承，可以复用代码，但不能统一处理。使用接口，针对接口编程，可以实现统一处理不同类型的对象，但接口没有代码实现，无法复用代码。</p>\n<p><strong>将组合和接口结合起来</strong>，就既可以统一处理，也可以复用代码了。</p>\n<p>举个栗子：</p>\n<p>先增加一个接口IAdd：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAdd</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改Base类代码，让它实现IAdd接口，代码基本不变：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> <span class=\"keyword\">implements</span> <span class=\"title\">IAdd</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_NUM = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[MAX_NUM];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt; MAX_NUM) &#123;</span><br><span class=\"line\">            arr[count++] = number;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : numbers) &#123;</span><br><span class=\"line\">            add(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改Child类代码，也是实现IAdd接口，代码基本不变：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">IAdd</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Base base;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        base = <span class=\"keyword\">new</span> Base();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        base.add(number);</span><br><span class=\"line\">        sum+=number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        base.addAll(numbers);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numbers.length;i++) &#123;</span><br><span class=\"line\">            sum+=numbers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getSum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"抽象方法和抽象类","date":"2021-09-28T07:30:56.000Z","_content":"\n抽象类：没有直接对应的对象，表达的是抽象概念，一般是具体类的比较上层的父类。\n\n比如，猫是具体对象，动物则是抽象概念；芒果是具体对象，图形是抽象概念。\n\n​    \n\n**抽象方法和抽象类**\n\n抽象方法和抽象类都是用**abstract**关键字来声明。\n\n```java\npublic abstract class Shape {\n    //...其他代码\n    public abstract void draw();\n}\n```\n\n**定义了抽象方法的类必须被声明为抽象类，但抽象类可以没有抽象方法**。\n\n抽象类可以定义具体方法、实例变量等。\n\n抽象类与具体类的核心区别：**抽象类不能创建对象**，比如不能使用new Shape()，而具体类可以。\n\n​    \n\n抽象类不能创建对象，要创建对象，必须使用它的具体子类。\n\n一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。\n\nCircle类的实现代码，如下所示：\n\n```java\npublic class Circle extends Shape {\n    //...其他代码\n    @Override\n    public void draw() {\n        //....\n    }\n}\n```\n\nCircle实现了draw()方法。\n\n​    \n\n与接口类似，抽象类虽然不能使用new，但可以声明抽象类的变量，引用抽象类具体子类的对象。\n\n如下所示：\n\n```java\nShape shape = new Circle();\nshape.draw();\n```\n\nshape是抽象类Shape类型的变量，引用了具体子类Circle的对象，调用draw方法将调用Circle的draw代码。\n\n​    \n","source":"_posts/抽象方法和抽象类.md","raw":"---\ntitle: 抽象方法和抽象类\ndate: 2021-09-28 15:30:56\ntags:\n - java\n - class\n - abstract\ncategories: java\n---\n\n抽象类：没有直接对应的对象，表达的是抽象概念，一般是具体类的比较上层的父类。\n\n比如，猫是具体对象，动物则是抽象概念；芒果是具体对象，图形是抽象概念。\n\n​    \n\n**抽象方法和抽象类**\n\n抽象方法和抽象类都是用**abstract**关键字来声明。\n\n```java\npublic abstract class Shape {\n    //...其他代码\n    public abstract void draw();\n}\n```\n\n**定义了抽象方法的类必须被声明为抽象类，但抽象类可以没有抽象方法**。\n\n抽象类可以定义具体方法、实例变量等。\n\n抽象类与具体类的核心区别：**抽象类不能创建对象**，比如不能使用new Shape()，而具体类可以。\n\n​    \n\n抽象类不能创建对象，要创建对象，必须使用它的具体子类。\n\n一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。\n\nCircle类的实现代码，如下所示：\n\n```java\npublic class Circle extends Shape {\n    //...其他代码\n    @Override\n    public void draw() {\n        //....\n    }\n}\n```\n\nCircle实现了draw()方法。\n\n​    \n\n与接口类似，抽象类虽然不能使用new，但可以声明抽象类的变量，引用抽象类具体子类的对象。\n\n如下所示：\n\n```java\nShape shape = new Circle();\nshape.draw();\n```\n\nshape是抽象类Shape类型的变量，引用了具体子类Circle的对象，调用draw方法将调用Circle的draw代码。\n\n​    \n","slug":"抽象方法和抽象类","published":1,"updated":"2021-09-28T08:28:23.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3tj3m000007guies6icq98","content":"<p>抽象类：没有直接对应的对象，表达的是抽象概念，一般是具体类的比较上层的父类。</p>\n<p>比如，猫是具体对象，动物则是抽象概念；芒果是具体对象，图形是抽象概念。</p>\n<p>​    </p>\n<p><strong>抽象方法和抽象类</strong></p>\n<p>抽象方法和抽象类都是用<strong>abstract</strong>关键字来声明。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...其他代码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>定义了抽象方法的类必须被声明为抽象类，但抽象类可以没有抽象方法</strong>。</p>\n<p>抽象类可以定义具体方法、实例变量等。</p>\n<p>抽象类与具体类的核心区别：<strong>抽象类不能创建对象</strong>，比如不能使用new Shape()，而具体类可以。</p>\n<p>​    </p>\n<p>抽象类不能创建对象，要创建对象，必须使用它的具体子类。</p>\n<p>一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。</p>\n<p>Circle类的实现代码，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...其他代码</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Circle实现了draw()方法。</p>\n<p>​    </p>\n<p>与接口类似，抽象类虽然不能使用new，但可以声明抽象类的变量，引用抽象类具体子类的对象。</p>\n<p>如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shape shape = <span class=\"keyword\">new</span> Circle();</span><br><span class=\"line\">shape.draw();</span><br></pre></td></tr></table></figure>\n\n<p>shape是抽象类Shape类型的变量，引用了具体子类Circle的对象，调用draw方法将调用Circle的draw代码。</p>\n<p>​    </p>\n","site":{"data":{}},"excerpt":"","more":"<p>抽象类：没有直接对应的对象，表达的是抽象概念，一般是具体类的比较上层的父类。</p>\n<p>比如，猫是具体对象，动物则是抽象概念；芒果是具体对象，图形是抽象概念。</p>\n<p>​    </p>\n<p><strong>抽象方法和抽象类</strong></p>\n<p>抽象方法和抽象类都是用<strong>abstract</strong>关键字来声明。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...其他代码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>定义了抽象方法的类必须被声明为抽象类，但抽象类可以没有抽象方法</strong>。</p>\n<p>抽象类可以定义具体方法、实例变量等。</p>\n<p>抽象类与具体类的核心区别：<strong>抽象类不能创建对象</strong>，比如不能使用new Shape()，而具体类可以。</p>\n<p>​    </p>\n<p>抽象类不能创建对象，要创建对象，必须使用它的具体子类。</p>\n<p>一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。</p>\n<p>Circle类的实现代码，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...其他代码</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Circle实现了draw()方法。</p>\n<p>​    </p>\n<p>与接口类似，抽象类虽然不能使用new，但可以声明抽象类的变量，引用抽象类具体子类的对象。</p>\n<p>如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shape shape = <span class=\"keyword\">new</span> Circle();</span><br><span class=\"line\">shape.draw();</span><br></pre></td></tr></table></figure>\n\n<p>shape是抽象类Shape类型的变量，引用了具体子类Circle的对象，调用draw方法将调用Circle的draw代码。</p>\n<p>​    </p>\n"},{"title":"抽象类和接口","date":"2021-09-28T08:30:45.000Z","_content":"抽象类和接口有类似之处，它们都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。\n\n但抽象类和接口根本上是不同的，一个类可以实现多个接口，但只能继承一个类。\n\n**抽象类和接口是配合关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类。**\n\n\n\n（感觉不会经常用的样子……）\n","source":"_posts/抽象类和接口.md","raw":"---\ntitle: 抽象类和接口\ndate: 2021-09-28 16:30:45\ntags:\n - java\n - class\n - abstract\n - interface\ncategories: java\n---\n抽象类和接口有类似之处，它们都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。\n\n但抽象类和接口根本上是不同的，一个类可以实现多个接口，但只能继承一个类。\n\n**抽象类和接口是配合关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类。**\n\n\n\n（感觉不会经常用的样子……）\n","slug":"抽象类和接口","published":1,"updated":"2021-09-28T09:23:12.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3vgqxj00008kui0344agcv","content":"<p>抽象类和接口有类似之处，它们都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。</p>\n<p>但抽象类和接口根本上是不同的，一个类可以实现多个接口，但只能继承一个类。</p>\n<p><strong>抽象类和接口是配合关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类。</strong></p>\n<p>（感觉不会经常用的样子……）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>抽象类和接口有类似之处，它们都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。</p>\n<p>但抽象类和接口根本上是不同的，一个类可以实现多个接口，但只能继承一个类。</p>\n<p><strong>抽象类和接口是配合关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类。</strong></p>\n<p>（感觉不会经常用的样子……）</p>\n"},{"title":"内部类的定义","date":"2021-09-28T09:53:29.000Z","_content":"一个类可以放在另一个类的内部，称为内部类。相对而言，包含它的类称为外部类。\n\n一般而言，**内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁**。\n\n内部类只是Java编译器的概念，对于java虚拟机而言，它是不知道内部类的。每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件。\n\n**内部类可以方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏，相关代码写在一起，写法也更为简洁。**\n\n​    \n\njava中主要有四种内部类：\n\n- 静态内部类\n- 成员内部类\n- 方法内部类\n- 匿名内部类\n\n","source":"_posts/内部类的定义.md","raw":"---\ntitle: 内部类的定义\ndate: 2021-09-28 17:53:29\ntags:\n - java\n - class\ncategories: java\n---\n一个类可以放在另一个类的内部，称为内部类。相对而言，包含它的类称为外部类。\n\n一般而言，**内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁**。\n\n内部类只是Java编译器的概念，对于java虚拟机而言，它是不知道内部类的。每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件。\n\n**内部类可以方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏，相关代码写在一起，写法也更为简洁。**\n\n​    \n\njava中主要有四种内部类：\n\n- 静态内部类\n- 成员内部类\n- 方法内部类\n- 匿名内部类\n\n","slug":"内部类的定义","published":1,"updated":"2021-09-29T02:48:23.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku4wsupr0000asuigaecb7ej","content":"<p>一个类可以放在另一个类的内部，称为内部类。相对而言，包含它的类称为外部类。</p>\n<p>一般而言，<strong>内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁</strong>。</p>\n<p>内部类只是Java编译器的概念，对于java虚拟机而言，它是不知道内部类的。每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件。</p>\n<p><strong>内部类可以方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏，相关代码写在一起，写法也更为简洁。</strong></p>\n<p>​    </p>\n<p>java中主要有四种内部类：</p>\n<ul>\n<li>静态内部类</li>\n<li>成员内部类</li>\n<li>方法内部类</li>\n<li>匿名内部类</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>一个类可以放在另一个类的内部，称为内部类。相对而言，包含它的类称为外部类。</p>\n<p>一般而言，<strong>内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁</strong>。</p>\n<p>内部类只是Java编译器的概念，对于java虚拟机而言，它是不知道内部类的。每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件。</p>\n<p><strong>内部类可以方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏，相关代码写在一起，写法也更为简洁。</strong></p>\n<p>​    </p>\n<p>java中主要有四种内部类：</p>\n<ul>\n<li>静态内部类</li>\n<li>成员内部类</li>\n<li>方法内部类</li>\n<li>匿名内部类</li>\n</ul>\n"},{"title":"程序打包","date":"2021-09-30T08:49:50.000Z","_content":"可见性范围从小到大是：\n\nprivate < 默认(包) < protected < public\n\n​    \n\n为方便使用第三方代码，也为了方便我们写的代码给其他人使用，所以需要对代码进行**打包**。\n\n打包的一般不是源代码，而是编译后的代码，打包将多个编译后的文件打包为一个文件，方便其他程序调用。\n\n在java中，编译后的一个或多个包的java class文件可以打包为一个文件，**java中打包命令为jar，打包后的文件后缀为.jar，一般称之为jar包**。\n\n​    \n\n打包方式：\n\n**首先到编译后的java class文件根目录，然后运行\"jar -cvf <包名>.jar <最上层报名>\"的命令打包**。\n\n","source":"_posts/程序打包.md","raw":"---\ntitle: 程序打包\ndate: 2021-09-30 16:49:50\ntags:\n - java\n - package\ncategories: java\n---\n可见性范围从小到大是：\n\nprivate < 默认(包) < protected < public\n\n​    \n\n为方便使用第三方代码，也为了方便我们写的代码给其他人使用，所以需要对代码进行**打包**。\n\n打包的一般不是源代码，而是编译后的代码，打包将多个编译后的文件打包为一个文件，方便其他程序调用。\n\n在java中，编译后的一个或多个包的java class文件可以打包为一个文件，**java中打包命令为jar，打包后的文件后缀为.jar，一般称之为jar包**。\n\n​    \n\n打包方式：\n\n**首先到编译后的java class文件根目录，然后运行\"jar -cvf <包名>.jar <最上层报名>\"的命令打包**。\n\n","slug":"程序打包","published":1,"updated":"2021-09-30T09:15:05.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku6q1yvr0000ooui8gug0p5x","content":"<p>可见性范围从小到大是：</p>\n<p>private &lt; 默认(包) &lt; protected &lt; public</p>\n<p>​    </p>\n<p>为方便使用第三方代码，也为了方便我们写的代码给其他人使用，所以需要对代码进行<strong>打包</strong>。</p>\n<p>打包的一般不是源代码，而是编译后的代码，打包将多个编译后的文件打包为一个文件，方便其他程序调用。</p>\n<p>在java中，编译后的一个或多个包的java class文件可以打包为一个文件，<strong>java中打包命令为jar，打包后的文件后缀为.jar，一般称之为jar包</strong>。</p>\n<p>​    </p>\n<p>打包方式：</p>\n<p><strong>首先到编译后的java class文件根目录，然后运行”jar -cvf &lt;包名&gt;.jar &lt;最上层报名&gt;”的命令打包</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>可见性范围从小到大是：</p>\n<p>private &lt; 默认(包) &lt; protected &lt; public</p>\n<p>​    </p>\n<p>为方便使用第三方代码，也为了方便我们写的代码给其他人使用，所以需要对代码进行<strong>打包</strong>。</p>\n<p>打包的一般不是源代码，而是编译后的代码，打包将多个编译后的文件打包为一个文件，方便其他程序调用。</p>\n<p>在java中，编译后的一个或多个包的java class文件可以打包为一个文件，<strong>java中打包命令为jar，打包后的文件后缀为.jar，一般称之为jar包</strong>。</p>\n<p>​    </p>\n<p>打包方式：</p>\n<p><strong>首先到编译后的java class文件根目录，然后运行”jar -cvf &lt;包名&gt;.jar &lt;最上层报名&gt;”的命令打包</strong>。</p>\n"},{"title":"程序的编译与连接","date":"2021-09-30T09:15:53.000Z","_content":"从java源代码到运行的程序，有**编译**和**连接**两个步骤。\n\n编译是**将源代码文件变成一种字节码**，后缀是.class的文件。一般由javac（编译器）命令完成编译。\n\n连接是在运行时动态执行的，.class文件不能直接运行，运行的是java虚拟机。虚拟机解析.class文件，**转换为机器能识别的二进制代码**，然后运行。所谓连接就是根据引用到的类加载相应的字节码并执行。\n\n\n\n","source":"_posts/程序的编译与连接.md","raw":"---\ntitle: 程序的编译与连接\ndate: 2021-09-30 17:15:53\ntags: java\ncategories: java\n---\n从java源代码到运行的程序，有**编译**和**连接**两个步骤。\n\n编译是**将源代码文件变成一种字节码**，后缀是.class的文件。一般由javac（编译器）命令完成编译。\n\n连接是在运行时动态执行的，.class文件不能直接运行，运行的是java虚拟机。虚拟机解析.class文件，**转换为机器能识别的二进制代码**，然后运行。所谓连接就是根据引用到的类加载相应的字节码并执行。\n\n\n\n","slug":"程序的编译与连接","published":1,"updated":"2021-09-30T09:38:12.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku6qvr450000f8uial32fseu","content":"<p>从java源代码到运行的程序，有<strong>编译</strong>和<strong>连接</strong>两个步骤。</p>\n<p>编译是<strong>将源代码文件变成一种字节码</strong>，后缀是.class的文件。一般由javac（编译器）命令完成编译。</p>\n<p>连接是在运行时动态执行的，.class文件不能直接运行，运行的是java虚拟机。虚拟机解析.class文件，<strong>转换为机器能识别的二进制代码</strong>，然后运行。所谓连接就是根据引用到的类加载相应的字节码并执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从java源代码到运行的程序，有<strong>编译</strong>和<strong>连接</strong>两个步骤。</p>\n<p>编译是<strong>将源代码文件变成一种字节码</strong>，后缀是.class的文件。一般由javac（编译器）命令完成编译。</p>\n<p>连接是在运行时动态执行的，.class文件不能直接运行，运行的是java虚拟机。虚拟机解析.class文件，<strong>转换为机器能识别的二进制代码</strong>，然后运行。所谓连接就是根据引用到的类加载相应的字节码并执行。</p>\n"},{"title":"枚举的基本用法","date":"2021-09-30T09:40:04.000Z","_content":"枚举是一种特殊的数据，它的取值是**有限**的，可以枚举出来的。\n\n\n\n**基本用法**\n\n举个栗子，为表示衣服的尺寸，需要定义一个枚举类型Size。Size包括三个尺寸，小/中/大。\n\n```java\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n```\n\n枚举使用enum关键字来定义，Size包括三个值，分别表示小、中、大。**值一般是大写的字母，多个值之间以逗号分隔**。\n\n枚举类型可以定义为一个单独的文件，也可以定义在其他类内部。\n\n​    \n\n使用Size：\n\n```java\nSize size = Size.MEDIUM;\n```\n\nSize size声明了一个变量size，它的类型是Size，size=Size.MEDIUM将枚举值MEDIUM赋值给size变量。\n\n```java\nSize size = Size.SMALL;\nSystem.out.println(size.toString());\t//输出SMALL\nSystem.out.println(size.name());\t//输出SMALL\n```\n\n枚举变量的toString方法返回其字面值（SMALL），所有枚举类型也有一个**name**方法，返回值与toString一样。\n\n​    \n\n**枚举值是有顺序的**，可以比较大小。\n\n枚举类型都有一个方法**int ordinal()**，表示枚举值在声明时的顺序，从0开始。\n\n枚举类型都实现了Java API中的Comparable接口，都可以通过方法compareTo与其他枚举值比较ordinal的大小。\n\n```java\nSize size = Size.SMALL;\nSystem.out.println(size.ordinal()); //输出0\nsize = Size.MEDIUM;\nSystem.out.println(size.ordinal()); //输出1\nSystem.out.println(Size.SMALL.compareTo(Size.MEDIUM));  //输出-1，表示SMALL小于MEDIUM\n```\n\n​    \n\n枚举类型都有一个静态的valueOf(String)方法，可以返回字符串对应的枚举值。\n\n```java\nSystem.out.println(Size.SMALL==Size.valueOf(\"SMALL\")); //输出true\n```\n\n枚举类型都有一个静态的values方法，返回一个包括所有枚举值的数组，顺序与声明时的顺序一致。\n\n```java\nfor(Size size : Size.values()) {\n\tSystem.out.println(size);\n}\n```\n\n屏幕输出三行，分别是SMALL，MEDIUM，LARGE。\n\n","source":"_posts/枚举的基本用法.md","raw":"---\ntitle: 枚举的基本用法\ndate: 2021-09-30 17:40:04\ntags:\n - enum\n - java\ncategories: java\n---\n枚举是一种特殊的数据，它的取值是**有限**的，可以枚举出来的。\n\n\n\n**基本用法**\n\n举个栗子，为表示衣服的尺寸，需要定义一个枚举类型Size。Size包括三个尺寸，小/中/大。\n\n```java\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n```\n\n枚举使用enum关键字来定义，Size包括三个值，分别表示小、中、大。**值一般是大写的字母，多个值之间以逗号分隔**。\n\n枚举类型可以定义为一个单独的文件，也可以定义在其他类内部。\n\n​    \n\n使用Size：\n\n```java\nSize size = Size.MEDIUM;\n```\n\nSize size声明了一个变量size，它的类型是Size，size=Size.MEDIUM将枚举值MEDIUM赋值给size变量。\n\n```java\nSize size = Size.SMALL;\nSystem.out.println(size.toString());\t//输出SMALL\nSystem.out.println(size.name());\t//输出SMALL\n```\n\n枚举变量的toString方法返回其字面值（SMALL），所有枚举类型也有一个**name**方法，返回值与toString一样。\n\n​    \n\n**枚举值是有顺序的**，可以比较大小。\n\n枚举类型都有一个方法**int ordinal()**，表示枚举值在声明时的顺序，从0开始。\n\n枚举类型都实现了Java API中的Comparable接口，都可以通过方法compareTo与其他枚举值比较ordinal的大小。\n\n```java\nSize size = Size.SMALL;\nSystem.out.println(size.ordinal()); //输出0\nsize = Size.MEDIUM;\nSystem.out.println(size.ordinal()); //输出1\nSystem.out.println(Size.SMALL.compareTo(Size.MEDIUM));  //输出-1，表示SMALL小于MEDIUM\n```\n\n​    \n\n枚举类型都有一个静态的valueOf(String)方法，可以返回字符串对应的枚举值。\n\n```java\nSystem.out.println(Size.SMALL==Size.valueOf(\"SMALL\")); //输出true\n```\n\n枚举类型都有一个静态的values方法，返回一个包括所有枚举值的数组，顺序与声明时的顺序一致。\n\n```java\nfor(Size size : Size.values()) {\n\tSystem.out.println(size);\n}\n```\n\n屏幕输出三行，分别是SMALL，MEDIUM，LARGE。\n\n","slug":"枚举的基本用法","published":1,"updated":"2021-10-12T09:08:54.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckunv4b49000080ui2k371hc0","content":"<p>枚举是一种特殊的数据，它的取值是<strong>有限</strong>的，可以枚举出来的。</p>\n<p><strong>基本用法</strong></p>\n<p>举个栗子，为表示衣服的尺寸，需要定义一个枚举类型Size。Size包括三个尺寸，小/中/大。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Size</span> </span>&#123;</span><br><span class=\"line\">    SMALL, MEDIUM, LARGE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举使用enum关键字来定义，Size包括三个值，分别表示小、中、大。<strong>值一般是大写的字母，多个值之间以逗号分隔</strong>。</p>\n<p>枚举类型可以定义为一个单独的文件，也可以定义在其他类内部。</p>\n<p>​    </p>\n<p>使用Size：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size size = Size.MEDIUM;</span><br></pre></td></tr></table></figure>\n\n<p>Size size声明了一个变量size，它的类型是Size，size=Size.MEDIUM将枚举值MEDIUM赋值给size变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size size = Size.SMALL;</span><br><span class=\"line\">System.out.println(size.toString());\t<span class=\"comment\">//输出SMALL</span></span><br><span class=\"line\">System.out.println(size.name());\t<span class=\"comment\">//输出SMALL</span></span><br></pre></td></tr></table></figure>\n\n<p>枚举变量的toString方法返回其字面值（SMALL），所有枚举类型也有一个<strong>name</strong>方法，返回值与toString一样。</p>\n<p>​    </p>\n<p><strong>枚举值是有顺序的</strong>，可以比较大小。</p>\n<p>枚举类型都有一个方法**int ordinal()**，表示枚举值在声明时的顺序，从0开始。</p>\n<p>枚举类型都实现了Java API中的Comparable接口，都可以通过方法compareTo与其他枚举值比较ordinal的大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size size = Size.SMALL;</span><br><span class=\"line\">System.out.println(size.ordinal()); <span class=\"comment\">//输出0</span></span><br><span class=\"line\">size = Size.MEDIUM;</span><br><span class=\"line\">System.out.println(size.ordinal()); <span class=\"comment\">//输出1</span></span><br><span class=\"line\">System.out.println(Size.SMALL.compareTo(Size.MEDIUM));  <span class=\"comment\">//输出-1，表示SMALL小于MEDIUM</span></span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>枚举类型都有一个静态的valueOf(String)方法，可以返回字符串对应的枚举值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(Size.SMALL==Size.valueOf(<span class=\"string\">&quot;SMALL&quot;</span>)); <span class=\"comment\">//输出true</span></span><br></pre></td></tr></table></figure>\n\n<p>枚举类型都有一个静态的values方法，返回一个包括所有枚举值的数组，顺序与声明时的顺序一致。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Size size : Size.values()) &#123;</span><br><span class=\"line\">\tSystem.out.println(size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>屏幕输出三行，分别是SMALL，MEDIUM，LARGE。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>枚举是一种特殊的数据，它的取值是<strong>有限</strong>的，可以枚举出来的。</p>\n<p><strong>基本用法</strong></p>\n<p>举个栗子，为表示衣服的尺寸，需要定义一个枚举类型Size。Size包括三个尺寸，小/中/大。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Size</span> </span>&#123;</span><br><span class=\"line\">    SMALL, MEDIUM, LARGE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举使用enum关键字来定义，Size包括三个值，分别表示小、中、大。<strong>值一般是大写的字母，多个值之间以逗号分隔</strong>。</p>\n<p>枚举类型可以定义为一个单独的文件，也可以定义在其他类内部。</p>\n<p>​    </p>\n<p>使用Size：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size size = Size.MEDIUM;</span><br></pre></td></tr></table></figure>\n\n<p>Size size声明了一个变量size，它的类型是Size，size=Size.MEDIUM将枚举值MEDIUM赋值给size变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size size = Size.SMALL;</span><br><span class=\"line\">System.out.println(size.toString());\t<span class=\"comment\">//输出SMALL</span></span><br><span class=\"line\">System.out.println(size.name());\t<span class=\"comment\">//输出SMALL</span></span><br></pre></td></tr></table></figure>\n\n<p>枚举变量的toString方法返回其字面值（SMALL），所有枚举类型也有一个<strong>name</strong>方法，返回值与toString一样。</p>\n<p>​    </p>\n<p><strong>枚举值是有顺序的</strong>，可以比较大小。</p>\n<p>枚举类型都有一个方法**int ordinal()**，表示枚举值在声明时的顺序，从0开始。</p>\n<p>枚举类型都实现了Java API中的Comparable接口，都可以通过方法compareTo与其他枚举值比较ordinal的大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size size = Size.SMALL;</span><br><span class=\"line\">System.out.println(size.ordinal()); <span class=\"comment\">//输出0</span></span><br><span class=\"line\">size = Size.MEDIUM;</span><br><span class=\"line\">System.out.println(size.ordinal()); <span class=\"comment\">//输出1</span></span><br><span class=\"line\">System.out.println(Size.SMALL.compareTo(Size.MEDIUM));  <span class=\"comment\">//输出-1，表示SMALL小于MEDIUM</span></span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>枚举类型都有一个静态的valueOf(String)方法，可以返回字符串对应的枚举值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(Size.SMALL==Size.valueOf(<span class=\"string\">&quot;SMALL&quot;</span>)); <span class=\"comment\">//输出true</span></span><br></pre></td></tr></table></figure>\n\n<p>枚举类型都有一个静态的values方法，返回一个包括所有枚举值的数组，顺序与声明时的顺序一致。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Size size : Size.values()) &#123;</span><br><span class=\"line\">\tSystem.out.println(size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>屏幕输出三行，分别是SMALL，MEDIUM，LARGE。</p>\n"},{"title":"枚举的好处","date":"2021-10-12T09:21:27.000Z","_content":"\n枚举的优点：\n\n- 定义枚举的语法更为简洁。\n- 枚举更为安全，一个枚举类型的变量，它的值要么为null，要么为枚举值之一，不可能为其他值。\n- 枚举类型自带很多遍历方法（如values,valueOf,toString等），易于使用。\n\n","source":"_posts/枚举的好处.md","raw":"---\ntitle: 枚举的好处\ndate: 2021-10-12 17:21:27\ntags:\n - enum\n - java\ncategories: java\n---\n\n枚举的优点：\n\n- 定义枚举的语法更为简洁。\n- 枚举更为安全，一个枚举类型的变量，它的值要么为null，要么为枚举值之一，不可能为其他值。\n- 枚举类型自带很多遍历方法（如values,valueOf,toString等），易于使用。\n\n","slug":"枚举的好处","published":1,"updated":"2021-10-12T09:25:57.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckunvq5yd0000dkui5sfucjs5","content":"<p>枚举的优点：</p>\n<ul>\n<li>定义枚举的语法更为简洁。</li>\n<li>枚举更为安全，一个枚举类型的变量，它的值要么为null，要么为枚举值之一，不可能为其他值。</li>\n<li>枚举类型自带很多遍历方法（如values,valueOf,toString等），易于使用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>枚举的优点：</p>\n<ul>\n<li>定义枚举的语法更为简洁。</li>\n<li>枚举更为安全，一个枚举类型的变量，它的值要么为null，要么为枚举值之一，不可能为其他值。</li>\n<li>枚举类型自带很多遍历方法（如values,valueOf,toString等），易于使用。</li>\n</ul>\n"},{"title":"枚举的基本实现原理","date":"2021-10-12T09:31:25.000Z","_content":"\n实际上，枚举类型会被Java编译器转换为一个对应的类，这个类继承了Java API中的java.lang.Enum类。\n\nEnum类有两个实例变量name和ordinal，在构造方法中需要传递，name()，toString()，ordinal()，compareTo()，equals()方法都是由Enum类根据其实例变量name和ordinal实现的。\n\nvalues和valueOf方法是编译器给每个枚举类型自动添加的。\n\n枚举类型Size转换后的普通类的代码如下：\n\n```java\npublic final class Size extends Enum<Size> {\t//final，不能被继承\n    public static final Size SMALL = new Size(\"SMALL\",0);\n    public static final Size MEDIUM = new Size(\"MEDIUM\",1);\n    public static final Size LARGE = new Size(\"LARGE\",2);\n    \n    private static Size[] VALUES =\n            new Size[]{SMALL,MEDIUM,LARGE};\n    \n    //私有构造方法，接受name和ordinal，传递给父类。不能在外部创建新的实例。\n    private Size(String name, int ordinal){\n        super(name, ordinal);\n    }\n    \n    public static Size[] values(){\n        Size[] values = new Size[VALUES.length];\n        System.arraycopy(VALUES, 0,\n                values, 0, VALUES.length);//要复制的源数组VALUES,从源数组0的位置开始复制，目标数组为values，目标数组的下标位置是0，要复制的长度是VALUES的长度\n        return values;\n    }\n    \n    public static Size valueOf(String name){\n        return Enum.valueOf(Size.class, name);\n    }\n}\n```\n\n​    \n\n枚举类型本质上也是类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。\n\n","source":"_posts/枚举的基本实现原理.md","raw":"---\ntitle: 枚举的基本实现原理\ndate: 2021-10-12 17:31:25\ntags:\n - enum\n - java\ncategories: java\n---\n\n实际上，枚举类型会被Java编译器转换为一个对应的类，这个类继承了Java API中的java.lang.Enum类。\n\nEnum类有两个实例变量name和ordinal，在构造方法中需要传递，name()，toString()，ordinal()，compareTo()，equals()方法都是由Enum类根据其实例变量name和ordinal实现的。\n\nvalues和valueOf方法是编译器给每个枚举类型自动添加的。\n\n枚举类型Size转换后的普通类的代码如下：\n\n```java\npublic final class Size extends Enum<Size> {\t//final，不能被继承\n    public static final Size SMALL = new Size(\"SMALL\",0);\n    public static final Size MEDIUM = new Size(\"MEDIUM\",1);\n    public static final Size LARGE = new Size(\"LARGE\",2);\n    \n    private static Size[] VALUES =\n            new Size[]{SMALL,MEDIUM,LARGE};\n    \n    //私有构造方法，接受name和ordinal，传递给父类。不能在外部创建新的实例。\n    private Size(String name, int ordinal){\n        super(name, ordinal);\n    }\n    \n    public static Size[] values(){\n        Size[] values = new Size[VALUES.length];\n        System.arraycopy(VALUES, 0,\n                values, 0, VALUES.length);//要复制的源数组VALUES,从源数组0的位置开始复制，目标数组为values，目标数组的下标位置是0，要复制的长度是VALUES的长度\n        return values;\n    }\n    \n    public static Size valueOf(String name){\n        return Enum.valueOf(Size.class, name);\n    }\n}\n```\n\n​    \n\n枚举类型本质上也是类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。\n\n","slug":"枚举的基本实现原理","published":1,"updated":"2021-10-12T11:25:13.374Z","_id":"ckunw8s8o000024ui7tf33904","comments":1,"layout":"post","photos":[],"link":"","content":"<p>实际上，枚举类型会被Java编译器转换为一个对应的类，这个类继承了Java API中的java.lang.Enum类。</p>\n<p>Enum类有两个实例变量name和ordinal，在构造方法中需要传递，name()，toString()，ordinal()，compareTo()，equals()方法都是由Enum类根据其实例变量name和ordinal实现的。</p>\n<p>values和valueOf方法是编译器给每个枚举类型自动添加的。</p>\n<p>枚举类型Size转换后的普通类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Size</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enum</span>&lt;<span class=\"title\">Size</span>&gt; </span>&#123;\t<span class=\"comment\">//final，不能被继承</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Size SMALL = <span class=\"keyword\">new</span> Size(<span class=\"string\">&quot;SMALL&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Size MEDIUM = <span class=\"keyword\">new</span> Size(<span class=\"string\">&quot;MEDIUM&quot;</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Size LARGE = <span class=\"keyword\">new</span> Size(<span class=\"string\">&quot;LARGE&quot;</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Size[] VALUES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Size[]&#123;SMALL,MEDIUM,LARGE&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//私有构造方法，接受name和ordinal，传递给父类。不能在外部创建新的实例。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Size</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> ordinal)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name, ordinal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Size[] values()&#123;</span><br><span class=\"line\">        Size[] values = <span class=\"keyword\">new</span> Size[VALUES.length];</span><br><span class=\"line\">        System.arraycopy(VALUES, <span class=\"number\">0</span>,</span><br><span class=\"line\">                values, <span class=\"number\">0</span>, VALUES.length);<span class=\"comment\">//要复制的源数组VALUES,从源数组0的位置开始复制，目标数组为values，目标数组的下标位置是0，要复制的长度是VALUES的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Size <span class=\"title\">valueOf</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Enum.valueOf(Size.class, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>枚举类型本质上也是类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>实际上，枚举类型会被Java编译器转换为一个对应的类，这个类继承了Java API中的java.lang.Enum类。</p>\n<p>Enum类有两个实例变量name和ordinal，在构造方法中需要传递，name()，toString()，ordinal()，compareTo()，equals()方法都是由Enum类根据其实例变量name和ordinal实现的。</p>\n<p>values和valueOf方法是编译器给每个枚举类型自动添加的。</p>\n<p>枚举类型Size转换后的普通类的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Size</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enum</span>&lt;<span class=\"title\">Size</span>&gt; </span>&#123;\t<span class=\"comment\">//final，不能被继承</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Size SMALL = <span class=\"keyword\">new</span> Size(<span class=\"string\">&quot;SMALL&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Size MEDIUM = <span class=\"keyword\">new</span> Size(<span class=\"string\">&quot;MEDIUM&quot;</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Size LARGE = <span class=\"keyword\">new</span> Size(<span class=\"string\">&quot;LARGE&quot;</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Size[] VALUES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Size[]&#123;SMALL,MEDIUM,LARGE&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//私有构造方法，接受name和ordinal，传递给父类。不能在外部创建新的实例。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Size</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> ordinal)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name, ordinal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Size[] values()&#123;</span><br><span class=\"line\">        Size[] values = <span class=\"keyword\">new</span> Size[VALUES.length];</span><br><span class=\"line\">        System.arraycopy(VALUES, <span class=\"number\">0</span>,</span><br><span class=\"line\">                values, <span class=\"number\">0</span>, VALUES.length);<span class=\"comment\">//要复制的源数组VALUES,从源数组0的位置开始复制，目标数组为values，目标数组的下标位置是0，要复制的长度是VALUES的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Size <span class=\"title\">valueOf</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Enum.valueOf(Size.class, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>枚举类型本质上也是类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。</p>\n"},{"title":"枚举的典型场景","date":"2021-10-12T11:25:25.000Z","_content":"实际应用中，枚举经常会有关联的实例变量和方法。\n\n举个栗子，假设Size的枚举值可能有关联的缩写和中文名称，可能需要静态方法根据缩写返回对应的枚举值：\n\n```java\npublic enum Size {\n    SMALL(\"S\",\"小号\"),\n    MEDIUM(\"M\",\"中号\"),\n    LARGE(\"L\",\"大号\");\n\n    private String abbr;\n    private String title;\n\n    private Size(String abbr,String title) {\n        this.abbr = abbr;\n        this.title = title;\n    }\n\n    public String getAbbr() {\n        return abbr;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n    \n\t//根据abbr返回枚举值，比如输入M返回MEDIUM\n    public static Size fromAbbr(String abbr) {\n        for (Size size : Size.values()) {\n            if (size.getAbbr().equals(abbr)) {\n                return size;\n            }\n        }\n        return null;\n    }\n}\n\n```\n\n**枚举值的定义需要放在最上面，枚举值写完之后，要以分号结尾，然后才能写其他代码**。\n\n\n\n","source":"_posts/枚举的典型场景.md","raw":"---\ntitle: 枚举的典型场景\ndate: 2021-10-12 19:25:25\ntags:\n - enum\n - java\ncategories: java\n---\n实际应用中，枚举经常会有关联的实例变量和方法。\n\n举个栗子，假设Size的枚举值可能有关联的缩写和中文名称，可能需要静态方法根据缩写返回对应的枚举值：\n\n```java\npublic enum Size {\n    SMALL(\"S\",\"小号\"),\n    MEDIUM(\"M\",\"中号\"),\n    LARGE(\"L\",\"大号\");\n\n    private String abbr;\n    private String title;\n\n    private Size(String abbr,String title) {\n        this.abbr = abbr;\n        this.title = title;\n    }\n\n    public String getAbbr() {\n        return abbr;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n    \n\t//根据abbr返回枚举值，比如输入M返回MEDIUM\n    public static Size fromAbbr(String abbr) {\n        for (Size size : Size.values()) {\n            if (size.getAbbr().equals(abbr)) {\n                return size;\n            }\n        }\n        return null;\n    }\n}\n\n```\n\n**枚举值的定义需要放在最上面，枚举值写完之后，要以分号结尾，然后才能写其他代码**。\n\n\n\n","slug":"枚举的典型场景","published":1,"updated":"2021-10-13T06:21:16.422Z","_id":"ckuo0heyv0000egui6kowbhl0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>实际应用中，枚举经常会有关联的实例变量和方法。</p>\n<p>举个栗子，假设Size的枚举值可能有关联的缩写和中文名称，可能需要静态方法根据缩写返回对应的枚举值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Size</span> </span>&#123;</span><br><span class=\"line\">    SMALL(<span class=\"string\">&quot;S&quot;</span>,<span class=\"string\">&quot;小号&quot;</span>),</span><br><span class=\"line\">    MEDIUM(<span class=\"string\">&quot;M&quot;</span>,<span class=\"string\">&quot;中号&quot;</span>),</span><br><span class=\"line\">    LARGE(<span class=\"string\">&quot;L&quot;</span>,<span class=\"string\">&quot;大号&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String abbr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Size</span><span class=\"params\">(String abbr,String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.abbr = abbr;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAbbr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> abbr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//根据abbr返回枚举值，比如输入M返回MEDIUM</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Size <span class=\"title\">fromAbbr</span><span class=\"params\">(String abbr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Size size : Size.values()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size.getAbbr().equals(abbr)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>枚举值的定义需要放在最上面，枚举值写完之后，要以分号结尾，然后才能写其他代码</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>实际应用中，枚举经常会有关联的实例变量和方法。</p>\n<p>举个栗子，假设Size的枚举值可能有关联的缩写和中文名称，可能需要静态方法根据缩写返回对应的枚举值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Size</span> </span>&#123;</span><br><span class=\"line\">    SMALL(<span class=\"string\">&quot;S&quot;</span>,<span class=\"string\">&quot;小号&quot;</span>),</span><br><span class=\"line\">    MEDIUM(<span class=\"string\">&quot;M&quot;</span>,<span class=\"string\">&quot;中号&quot;</span>),</span><br><span class=\"line\">    LARGE(<span class=\"string\">&quot;L&quot;</span>,<span class=\"string\">&quot;大号&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String abbr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Size</span><span class=\"params\">(String abbr,String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.abbr = abbr;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAbbr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> abbr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//根据abbr返回枚举值，比如输入M返回MEDIUM</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Size <span class=\"title\">fromAbbr</span><span class=\"params\">(String abbr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Size size : Size.values()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size.getAbbr().equals(abbr)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>枚举值的定义需要放在最上面，枚举值写完之后，要以分号结尾，然后才能写其他代码</strong>。</p>\n"},{"title":"NullPointerException（空指针异常）","date":"2021-10-13T06:23:59.000Z","_content":"\n```java\npublic class ExceptionTest {\n    public static void main(String[] args) {\n        String s = null;\n        s.indexOf(\"a\"); //查找a在字符串s中首次出现的位置\n        System.out.println(\"end\");\n    }\n}\n```\n\n运行上面的代码，屏幕输出结果为：\n\n```java\nException in thread \"main\" java.lang.NullPointerException\n\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:4)\n```\n\n当运行s.indexOf(\"a\")时，java系统发现s的值为null，没有办法继续执行，这时就启用异常处理机制：\n\n首先 ，创建一个异常对象——类NullPointerException的对象，然后查找看谁能处理这个异常。在上面的代码中，没有代码能处理这个异常，java就启用默认处理机制，打印异常栈信息到屏幕，并退出程序。\n\n​    \n\n**java的默认异常处理机制是退出程序，异常发生点后的代码都不会执行。**\n\n","source":"_posts/NullPointerException（空指针异常）.md","raw":"---\ntitle: NullPointerException（空指针异常）\ndate: 2021-10-13 14:23:59\ntags:\n - exception\n - java\ncategories: java\n---\n\n```java\npublic class ExceptionTest {\n    public static void main(String[] args) {\n        String s = null;\n        s.indexOf(\"a\"); //查找a在字符串s中首次出现的位置\n        System.out.println(\"end\");\n    }\n}\n```\n\n运行上面的代码，屏幕输出结果为：\n\n```java\nException in thread \"main\" java.lang.NullPointerException\n\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:4)\n```\n\n当运行s.indexOf(\"a\")时，java系统发现s的值为null，没有办法继续执行，这时就启用异常处理机制：\n\n首先 ，创建一个异常对象——类NullPointerException的对象，然后查找看谁能处理这个异常。在上面的代码中，没有代码能处理这个异常，java就启用默认处理机制，打印异常栈信息到屏幕，并退出程序。\n\n​    \n\n**java的默认异常处理机制是退出程序，异常发生点后的代码都不会执行。**\n\n","slug":"NullPointerException（空指针异常）","published":1,"updated":"2021-10-13T06:47:33.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckup5ig2p0000voui07tfan6f","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        s.indexOf(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">//查找a在字符串s中首次出现的位置</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行上面的代码，屏幕输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class=\"line\">\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>当运行s.indexOf(“a”)时，java系统发现s的值为null，没有办法继续执行，这时就启用异常处理机制：</p>\n<p>首先 ，创建一个异常对象——类NullPointerException的对象，然后查找看谁能处理这个异常。在上面的代码中，没有代码能处理这个异常，java就启用默认处理机制，打印异常栈信息到屏幕，并退出程序。</p>\n<p>​    </p>\n<p><strong>java的默认异常处理机制是退出程序，异常发生点后的代码都不会执行。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        s.indexOf(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">//查找a在字符串s中首次出现的位置</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行上面的代码，屏幕输出结果为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class=\"line\">\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>当运行s.indexOf(“a”)时，java系统发现s的值为null，没有办法继续执行，这时就启用异常处理机制：</p>\n<p>首先 ，创建一个异常对象——类NullPointerException的对象，然后查找看谁能处理这个异常。在上面的代码中，没有代码能处理这个异常，java就启用默认处理机制，打印异常栈信息到屏幕，并退出程序。</p>\n<p>​    </p>\n<p><strong>java的默认异常处理机制是退出程序，异常发生点后的代码都不会执行。</strong></p>\n"},{"title":"NumberFormatException（数字格式异常）","date":"2021-10-13T06:48:35.000Z","_content":"\n```java\npublic class ExceptionTest {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入数字:\");\n        int num = Integer.parseInt(scanner.next()); //解析控制台输入的整数\n        System.out.println(num);\n    }\n}\n```\n\nscanner要求输入数字，并通过Integer.parseInt将参数转换为一个整数，再输出这个整数。 \n\n如果输入123，屏幕会输出123，但如果用户输入的不是数字，比如doge，屏幕会输出：\n\n```java\nException in thread \"main\" java.lang.NumberFormatException: For input string: \"doge\"\n\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tat java.lang.Integer.parseInt(Integer.java:580)\n\tat java.lang.Integer.parseInt(Integer.java:615)\n\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:9)\n\n```\n\n出现异常NumberFormatException。\n\n​     \n\n对于屏幕输出中的异常栈信息，开发者是可以理解的，但普通用户无法理解。\n我们需要给用户一个更为友好的信息，告诉用户，ta应该输入的是数字。要做到这一点，我们需要自己“捕获”异常。\n\n“捕获”是指使用try/catch关键字，捕获异常后的示例代码如下：\n\n```java\npublic class ExceptionTest {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入数字:\");\n        String input = scanner.next();\n        try {\n            int num = Integer.parseInt(input); //解析控制台输入的整数\n            System.out.println(num);\n        } catch (NumberFormatException e) {\n            System.err.println(\"参数\"+input+\"不是有效的数字，请输入数字。\");\n        }\n    }\n}\n```\n\n使用**try/catch捕获并处理了异常**，try后面的大括号{}内包含可能抛出异常的代码，括号后的catch语句包含能捕获的异常和代理代码。\n\ncatch后面括号内是异常信息，包括异常类型和变量名，这里是NumberFormatException e。大括号{}内是处理代码，这里输出一个更为友好的提示信息。\n\n**捕获异常后，程序就不会异常退出了，但try语句内异常点之后的其他代码就不会执行了，执行完catch内的语句后，程序会继续执行catch大括号外的代码。**\n\n​    \n\n异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过**throw语句**触发。异常可以通过try/catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息。\n\n\n\n","source":"_posts/NumberFormatException（数字格式异常）.md","raw":"---\ntitle: NumberFormatException（数字格式异常）\ndate: 2021-10-13 14:48:35\ntags:\n - exception\n - java\ncategories: java\n---\n\n```java\npublic class ExceptionTest {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入数字:\");\n        int num = Integer.parseInt(scanner.next()); //解析控制台输入的整数\n        System.out.println(num);\n    }\n}\n```\n\nscanner要求输入数字，并通过Integer.parseInt将参数转换为一个整数，再输出这个整数。 \n\n如果输入123，屏幕会输出123，但如果用户输入的不是数字，比如doge，屏幕会输出：\n\n```java\nException in thread \"main\" java.lang.NumberFormatException: For input string: \"doge\"\n\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tat java.lang.Integer.parseInt(Integer.java:580)\n\tat java.lang.Integer.parseInt(Integer.java:615)\n\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:9)\n\n```\n\n出现异常NumberFormatException。\n\n​     \n\n对于屏幕输出中的异常栈信息，开发者是可以理解的，但普通用户无法理解。\n我们需要给用户一个更为友好的信息，告诉用户，ta应该输入的是数字。要做到这一点，我们需要自己“捕获”异常。\n\n“捕获”是指使用try/catch关键字，捕获异常后的示例代码如下：\n\n```java\npublic class ExceptionTest {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入数字:\");\n        String input = scanner.next();\n        try {\n            int num = Integer.parseInt(input); //解析控制台输入的整数\n            System.out.println(num);\n        } catch (NumberFormatException e) {\n            System.err.println(\"参数\"+input+\"不是有效的数字，请输入数字。\");\n        }\n    }\n}\n```\n\n使用**try/catch捕获并处理了异常**，try后面的大括号{}内包含可能抛出异常的代码，括号后的catch语句包含能捕获的异常和代理代码。\n\ncatch后面括号内是异常信息，包括异常类型和变量名，这里是NumberFormatException e。大括号{}内是处理代码，这里输出一个更为友好的提示信息。\n\n**捕获异常后，程序就不会异常退出了，但try语句内异常点之后的其他代码就不会执行了，执行完catch内的语句后，程序会继续执行catch大括号外的代码。**\n\n​    \n\n异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过**throw语句**触发。异常可以通过try/catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息。\n\n\n\n","slug":"NumberFormatException（数字格式异常）","published":1,"updated":"2021-10-13T09:09:26.491Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckupakrdx0000b8ui4j04bc6x","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入数字:&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = Integer.parseInt(scanner.next()); <span class=\"comment\">//解析控制台输入的整数</span></span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>scanner要求输入数字，并通过Integer.parseInt将参数转换为一个整数，再输出这个整数。 </p>\n<p>如果输入123，屏幕会输出123，但如果用户输入的不是数字，比如doge，屏幕会输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.NumberFormatException: For input string: <span class=\"string\">&quot;doge&quot;</span></span><br><span class=\"line\">\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class=\"number\">65</span>)</span><br><span class=\"line\">\tat java.lang.Integer.parseInt(Integer.java:<span class=\"number\">580</span>)</span><br><span class=\"line\">\tat java.lang.Integer.parseInt(Integer.java:<span class=\"number\">615</span>)</span><br><span class=\"line\">\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>出现异常NumberFormatException。</p>\n<p>​     </p>\n<p>对于屏幕输出中的异常栈信息，开发者是可以理解的，但普通用户无法理解。<br>我们需要给用户一个更为友好的信息，告诉用户，ta应该输入的是数字。要做到这一点，我们需要自己“捕获”异常。</p>\n<p>“捕获”是指使用try/catch关键字，捕获异常后的示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入数字:&quot;</span>);</span><br><span class=\"line\">        String input = scanner.next();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = Integer.parseInt(input); <span class=\"comment\">//解析控制台输入的整数</span></span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;参数&quot;</span>+input+<span class=\"string\">&quot;不是有效的数字，请输入数字。&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<strong>try/catch捕获并处理了异常</strong>，try后面的大括号{}内包含可能抛出异常的代码，括号后的catch语句包含能捕获的异常和代理代码。</p>\n<p>catch后面括号内是异常信息，包括异常类型和变量名，这里是NumberFormatException e。大括号{}内是处理代码，这里输出一个更为友好的提示信息。</p>\n<p><strong>捕获异常后，程序就不会异常退出了，但try语句内异常点之后的其他代码就不会执行了，执行完catch内的语句后，程序会继续执行catch大括号外的代码。</strong></p>\n<p>​    </p>\n<p>异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过<strong>throw语句</strong>触发。异常可以通过try/catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入数字:&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = Integer.parseInt(scanner.next()); <span class=\"comment\">//解析控制台输入的整数</span></span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>scanner要求输入数字，并通过Integer.parseInt将参数转换为一个整数，再输出这个整数。 </p>\n<p>如果输入123，屏幕会输出123，但如果用户输入的不是数字，比如doge，屏幕会输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.NumberFormatException: For input string: <span class=\"string\">&quot;doge&quot;</span></span><br><span class=\"line\">\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class=\"number\">65</span>)</span><br><span class=\"line\">\tat java.lang.Integer.parseInt(Integer.java:<span class=\"number\">580</span>)</span><br><span class=\"line\">\tat java.lang.Integer.parseInt(Integer.java:<span class=\"number\">615</span>)</span><br><span class=\"line\">\tat com.example.restservice.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>出现异常NumberFormatException。</p>\n<p>​     </p>\n<p>对于屏幕输出中的异常栈信息，开发者是可以理解的，但普通用户无法理解。<br>我们需要给用户一个更为友好的信息，告诉用户，ta应该输入的是数字。要做到这一点，我们需要自己“捕获”异常。</p>\n<p>“捕获”是指使用try/catch关键字，捕获异常后的示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入数字:&quot;</span>);</span><br><span class=\"line\">        String input = scanner.next();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = Integer.parseInt(input); <span class=\"comment\">//解析控制台输入的整数</span></span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;参数&quot;</span>+input+<span class=\"string\">&quot;不是有效的数字，请输入数字。&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<strong>try/catch捕获并处理了异常</strong>，try后面的大括号{}内包含可能抛出异常的代码，括号后的catch语句包含能捕获的异常和代理代码。</p>\n<p>catch后面括号内是异常信息，包括异常类型和变量名，这里是NumberFormatException e。大括号{}内是处理代码，这里输出一个更为友好的提示信息。</p>\n<p><strong>捕获异常后，程序就不会异常退出了，但try语句内异常点之后的其他代码就不会执行了，执行完catch内的语句后，程序会继续执行catch大括号外的代码。</strong></p>\n<p>​    </p>\n<p>异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过<strong>throw语句</strong>触发。异常可以通过try/catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息。</p>\n"},{"title":"异常类","date":"2021-10-13T09:13:00.000Z","_content":"\nNullPointerException和NumberFormatException都是异常类，所有异常类都有一个共同的父类**Throwable**。\n\nThrowable有4个public构造方法：\n\n1.public Throwable()\n\n2.public Throwable(String message)\n\n3.public Throwable(String message,Throwable cause)\n\n4.public Throwable(Throwable cause)\n\n**message表示异常信息，cause表示触发该异常的其他异常。**\n\n异常可以形成一个异常链，上层的异常由底层异常触发，cause表示底层异常。\n\n\n\n**异常类体系**\n\n以Throwable为根，Java API中定义了非常多的异常类，表示各种类型的异常，部分类示意如下：\n\n![异常类体系.jpg](https://i.loli.net/2021/10/13/fXNLOM4yDZIBGUq.jpg)\n\nThrowable是所有异常的基类，它有两个子类Error和Excepetion。\n\n**Error表示系统错误或资源耗尽**，由java系统自己使用，应用程序不应抛出和处理。比如图中列出的虚拟器错误(VirtualMachineError)、子类内存溢出错误(OutOfMemoryError)、栈溢出错误(StackOverflowError)。\n\n**Exception表示应用程序错误，它有很多子类，应用程序也可以通过继承Exception或其子类创建自定义异常**，比如图中列出的IOException(输入输出I/O异常)，SQLException(数据库SQL异常)，RuntimeException（运行时异常）。\n\n​    \n\nRuntimeException(运行时异常)比较特殊，它的名字有点误导，因为其他异常也是运行时产生的，它表示的实际含义是unchecked exception (未受检异常)，相对而言，Exception的其他子类和Exception自身则是checked exception (受检异常)，Error及其子类也是unchecked exception。\n\nchecked还是unchecked，区别在于java如何处理这两种异常。**对于checked异常，java会强制要求开发者进行处理，否则会有编译错误，而对于unchecked异常则没有这个要求**。\n\n\n\n","source":"_posts/异常类.md","raw":"---\ntitle: 异常类\ndate: 2021-10-13 17:13:00\ntags:\n - exception\n - java\ncategories: java\n---\n\nNullPointerException和NumberFormatException都是异常类，所有异常类都有一个共同的父类**Throwable**。\n\nThrowable有4个public构造方法：\n\n1.public Throwable()\n\n2.public Throwable(String message)\n\n3.public Throwable(String message,Throwable cause)\n\n4.public Throwable(Throwable cause)\n\n**message表示异常信息，cause表示触发该异常的其他异常。**\n\n异常可以形成一个异常链，上层的异常由底层异常触发，cause表示底层异常。\n\n\n\n**异常类体系**\n\n以Throwable为根，Java API中定义了非常多的异常类，表示各种类型的异常，部分类示意如下：\n\n![异常类体系.jpg](https://i.loli.net/2021/10/13/fXNLOM4yDZIBGUq.jpg)\n\nThrowable是所有异常的基类，它有两个子类Error和Excepetion。\n\n**Error表示系统错误或资源耗尽**，由java系统自己使用，应用程序不应抛出和处理。比如图中列出的虚拟器错误(VirtualMachineError)、子类内存溢出错误(OutOfMemoryError)、栈溢出错误(StackOverflowError)。\n\n**Exception表示应用程序错误，它有很多子类，应用程序也可以通过继承Exception或其子类创建自定义异常**，比如图中列出的IOException(输入输出I/O异常)，SQLException(数据库SQL异常)，RuntimeException（运行时异常）。\n\n​    \n\nRuntimeException(运行时异常)比较特殊，它的名字有点误导，因为其他异常也是运行时产生的，它表示的实际含义是unchecked exception (未受检异常)，相对而言，Exception的其他子类和Exception自身则是checked exception (受检异常)，Error及其子类也是unchecked exception。\n\nchecked还是unchecked，区别在于java如何处理这两种异常。**对于checked异常，java会强制要求开发者进行处理，否则会有编译错误，而对于unchecked异常则没有这个要求**。\n\n\n\n","slug":"异常类","published":1,"updated":"2021-10-19T11:08:26.482Z","_id":"ckupfn8me0000s8uigbx6blv7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>NullPointerException和NumberFormatException都是异常类，所有异常类都有一个共同的父类<strong>Throwable</strong>。</p>\n<p>Throwable有4个public构造方法：</p>\n<p>1.public Throwable()</p>\n<p>2.public Throwable(String message)</p>\n<p>3.public Throwable(String message,Throwable cause)</p>\n<p>4.public Throwable(Throwable cause)</p>\n<p><strong>message表示异常信息，cause表示触发该异常的其他异常。</strong></p>\n<p>异常可以形成一个异常链，上层的异常由底层异常触发，cause表示底层异常。</p>\n<p><strong>异常类体系</strong></p>\n<p>以Throwable为根，Java API中定义了非常多的异常类，表示各种类型的异常，部分类示意如下：</p>\n<p><img src=\"https://i.loli.net/2021/10/13/fXNLOM4yDZIBGUq.jpg\" alt=\"异常类体系.jpg\"></p>\n<p>Throwable是所有异常的基类，它有两个子类Error和Excepetion。</p>\n<p><strong>Error表示系统错误或资源耗尽</strong>，由java系统自己使用，应用程序不应抛出和处理。比如图中列出的虚拟器错误(VirtualMachineError)、子类内存溢出错误(OutOfMemoryError)、栈溢出错误(StackOverflowError)。</p>\n<p><strong>Exception表示应用程序错误，它有很多子类，应用程序也可以通过继承Exception或其子类创建自定义异常</strong>，比如图中列出的IOException(输入输出I/O异常)，SQLException(数据库SQL异常)，RuntimeException（运行时异常）。</p>\n<p>​    </p>\n<p>RuntimeException(运行时异常)比较特殊，它的名字有点误导，因为其他异常也是运行时产生的，它表示的实际含义是unchecked exception (未受检异常)，相对而言，Exception的其他子类和Exception自身则是checked exception (受检异常)，Error及其子类也是unchecked exception。</p>\n<p>checked还是unchecked，区别在于java如何处理这两种异常。<strong>对于checked异常，java会强制要求开发者进行处理，否则会有编译错误，而对于unchecked异常则没有这个要求</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>NullPointerException和NumberFormatException都是异常类，所有异常类都有一个共同的父类<strong>Throwable</strong>。</p>\n<p>Throwable有4个public构造方法：</p>\n<p>1.public Throwable()</p>\n<p>2.public Throwable(String message)</p>\n<p>3.public Throwable(String message,Throwable cause)</p>\n<p>4.public Throwable(Throwable cause)</p>\n<p><strong>message表示异常信息，cause表示触发该异常的其他异常。</strong></p>\n<p>异常可以形成一个异常链，上层的异常由底层异常触发，cause表示底层异常。</p>\n<p><strong>异常类体系</strong></p>\n<p>以Throwable为根，Java API中定义了非常多的异常类，表示各种类型的异常，部分类示意如下：</p>\n<p><img src=\"https://i.loli.net/2021/10/13/fXNLOM4yDZIBGUq.jpg\" alt=\"异常类体系.jpg\"></p>\n<p>Throwable是所有异常的基类，它有两个子类Error和Excepetion。</p>\n<p><strong>Error表示系统错误或资源耗尽</strong>，由java系统自己使用，应用程序不应抛出和处理。比如图中列出的虚拟器错误(VirtualMachineError)、子类内存溢出错误(OutOfMemoryError)、栈溢出错误(StackOverflowError)。</p>\n<p><strong>Exception表示应用程序错误，它有很多子类，应用程序也可以通过继承Exception或其子类创建自定义异常</strong>，比如图中列出的IOException(输入输出I/O异常)，SQLException(数据库SQL异常)，RuntimeException（运行时异常）。</p>\n<p>​    </p>\n<p>RuntimeException(运行时异常)比较特殊，它的名字有点误导，因为其他异常也是运行时产生的，它表示的实际含义是unchecked exception (未受检异常)，相对而言，Exception的其他子类和Exception自身则是checked exception (受检异常)，Error及其子类也是unchecked exception。</p>\n<p>checked还是unchecked，区别在于java如何处理这两种异常。<strong>对于checked异常，java会强制要求开发者进行处理，否则会有编译错误，而对于unchecked异常则没有这个要求</strong>。</p>\n"},{"title":"RuntimeException的常见子类","date":"2021-10-19T11:10:34.000Z","_content":"\n|              异常               |       说明       |\n| :-----------------------------: | :--------------: |\n|      NullPointerException       |    空指针异常    |\n|      IllegalStateException      |     非法状态     |\n|       ClassCastException        | 非法强制类型转换 |\n|    IllegalArgumentException     |     参数错误     |\n|      NumberFormatException      |   数字格式错误   |\n| ArrayIndexOutOfBoundsException  |   数组索引越界   |\n| StringIndexOutOfBoundsException |  字符串索引越界  |\n\n这些异常类其实并没有比Throwable这个基类多多少属性和方法，大部分类在继承父类后只是定义了几个构造方法，这些构造方法也只是强调了父类的构造方法。\n\n定义那么多类，主要是为了名字不同。异常类的名字本身就代表了异常的关键信息。\n\n","source":"_posts/RuntimeException的常见子类.md","raw":"---\ntitle: RuntimeException的常见子类\ndate: 2021-10-19 19:10:34\ntags:\n - exception\n - java\ncategories: java\n---\n\n|              异常               |       说明       |\n| :-----------------------------: | :--------------: |\n|      NullPointerException       |    空指针异常    |\n|      IllegalStateException      |     非法状态     |\n|       ClassCastException        | 非法强制类型转换 |\n|    IllegalArgumentException     |     参数错误     |\n|      NumberFormatException      |   数字格式错误   |\n| ArrayIndexOutOfBoundsException  |   数组索引越界   |\n| StringIndexOutOfBoundsException |  字符串索引越界  |\n\n这些异常类其实并没有比Throwable这个基类多多少属性和方法，大部分类在继承父类后只是定义了几个构造方法，这些构造方法也只是强调了父类的构造方法。\n\n定义那么多类，主要是为了名字不同。异常类的名字本身就代表了异常的关键信息。\n\n","slug":"RuntimeException的常见子类","published":1,"updated":"2021-10-19T11:39:40.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckuy0l4q40000e8ui19tg4e0x","content":"<table>\n<thead>\n<tr>\n<th align=\"center\">异常</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">NullPointerException</td>\n<td align=\"center\">空指针异常</td>\n</tr>\n<tr>\n<td align=\"center\">IllegalStateException</td>\n<td align=\"center\">非法状态</td>\n</tr>\n<tr>\n<td align=\"center\">ClassCastException</td>\n<td align=\"center\">非法强制类型转换</td>\n</tr>\n<tr>\n<td align=\"center\">IllegalArgumentException</td>\n<td align=\"center\">参数错误</td>\n</tr>\n<tr>\n<td align=\"center\">NumberFormatException</td>\n<td align=\"center\">数字格式错误</td>\n</tr>\n<tr>\n<td align=\"center\">ArrayIndexOutOfBoundsException</td>\n<td align=\"center\">数组索引越界</td>\n</tr>\n<tr>\n<td align=\"center\">StringIndexOutOfBoundsException</td>\n<td align=\"center\">字符串索引越界</td>\n</tr>\n</tbody></table>\n<p>这些异常类其实并没有比Throwable这个基类多多少属性和方法，大部分类在继承父类后只是定义了几个构造方法，这些构造方法也只是强调了父类的构造方法。</p>\n<p>定义那么多类，主要是为了名字不同。异常类的名字本身就代表了异常的关键信息。</p>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th align=\"center\">异常</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">NullPointerException</td>\n<td align=\"center\">空指针异常</td>\n</tr>\n<tr>\n<td align=\"center\">IllegalStateException</td>\n<td align=\"center\">非法状态</td>\n</tr>\n<tr>\n<td align=\"center\">ClassCastException</td>\n<td align=\"center\">非法强制类型转换</td>\n</tr>\n<tr>\n<td align=\"center\">IllegalArgumentException</td>\n<td align=\"center\">参数错误</td>\n</tr>\n<tr>\n<td align=\"center\">NumberFormatException</td>\n<td align=\"center\">数字格式错误</td>\n</tr>\n<tr>\n<td align=\"center\">ArrayIndexOutOfBoundsException</td>\n<td align=\"center\">数组索引越界</td>\n</tr>\n<tr>\n<td align=\"center\">StringIndexOutOfBoundsException</td>\n<td align=\"center\">字符串索引越界</td>\n</tr>\n</tbody></table>\n<p>这些异常类其实并没有比Throwable这个基类多多少属性和方法，大部分类在继承父类后只是定义了几个构造方法，这些构造方法也只是强调了父类的构造方法。</p>\n<p>定义那么多类，主要是为了名字不同。异常类的名字本身就代表了异常的关键信息。</p>\n"},{"title":"自定义异常","date":"2021-10-19T11:41:11.000Z","_content":"\n自定义异常类，一般通过继承Exception或者它的某个子类。\n如果父类是RuntimeException或它的某个子类，则自定义异常也是unchecked exception。如果是Exception或Exception的其他子类，则自定义异常是checked exception。\n\n​    \n\n继承Exception的栗子：\n\n```java\npublic class AppException extends Exception{\n\n    public AppException() {\n        super();\n    }\n\n    public AppException(String message, Throwable cause) {\n        super(message,cause);\n    }\n\n    public AppException(String message) {\n        super(message);\n    }\n\n    public AppException(Throwable cause) {\n        super(cause);\n    }\n}\n\n```\n\nAppException没有定义额外的属性和代码，只是继承了Exception，定义了构造方法并调用了父类的构造方法。\n\n","source":"_posts/自定义异常.md","raw":"---\ntitle: 自定义异常\ndate: 2021-10-19 19:41:11\ntags:\n - exception\n - java\ncategories: java\n---\n\n自定义异常类，一般通过继承Exception或者它的某个子类。\n如果父类是RuntimeException或它的某个子类，则自定义异常也是unchecked exception。如果是Exception或Exception的其他子类，则自定义异常是checked exception。\n\n​    \n\n继承Exception的栗子：\n\n```java\npublic class AppException extends Exception{\n\n    public AppException() {\n        super();\n    }\n\n    public AppException(String message, Throwable cause) {\n        super(message,cause);\n    }\n\n    public AppException(String message) {\n        super(message);\n    }\n\n    public AppException(Throwable cause) {\n        super(cause);\n    }\n}\n\n```\n\nAppException没有定义额外的属性和代码，只是继承了Exception，定义了构造方法并调用了父类的构造方法。\n\n","slug":"自定义异常","published":1,"updated":"2021-10-21T11:49:46.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv0vu4cp0000xsuifmg060sj","content":"<p>自定义异常类，一般通过继承Exception或者它的某个子类。<br>如果父类是RuntimeException或它的某个子类，则自定义异常也是unchecked exception。如果是Exception或Exception的其他子类，则自定义异常是checked exception。</p>\n<p>​    </p>\n<p>继承Exception的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">(String message, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message,cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">(Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>AppException没有定义额外的属性和代码，只是继承了Exception，定义了构造方法并调用了父类的构造方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自定义异常类，一般通过继承Exception或者它的某个子类。<br>如果父类是RuntimeException或它的某个子类，则自定义异常也是unchecked exception。如果是Exception或Exception的其他子类，则自定义异常是checked exception。</p>\n<p>​    </p>\n<p>继承Exception的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">(String message, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message,cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppException</span><span class=\"params\">(Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>AppException没有定义额外的属性和代码，只是继承了Exception，定义了构造方法并调用了父类的构造方法。</p>\n"},{"title":"异常中的finally","date":"2021-10-22T12:10:51.000Z","_content":"\ncatch后面可以跟**finally**语句，语法如下：\n\n```java\ntry {\n    //可能抛出异常\n} catch (Exception e) {\n    //捕获异常\n} finally {\n    //不管有无异常都执行\n}\n```\n\n**finally内的代码不管有无异常发生**，都会执行：\n\n- 如果没有异常发生，在try内的代码执行结束后执行。\n\n- 如果有异常发生且被catch捕获，在catch内的代码执行结束后执行。\n\n- 如果有异常发生但没被捕获，则在异常被抛给上层之前执行。\n\n由于finally的这个特点，它一般用于释放资源，如数据库连接、文件流等。\n\n​    \n\ntry/catch/finall语法中，catch不是必须的，可以只有try/finally。这表示不捕获异常，异常自动向上传递。\n\n\n\n","source":"_posts/异常中的finally.md","raw":"---\ntitle: 异常中的finally\ndate: 2021-10-22 20:10:51\ntags:\n - exception\n - java\ncategories: java\n---\n\ncatch后面可以跟**finally**语句，语法如下：\n\n```java\ntry {\n    //可能抛出异常\n} catch (Exception e) {\n    //捕获异常\n} finally {\n    //不管有无异常都执行\n}\n```\n\n**finally内的代码不管有无异常发生**，都会执行：\n\n- 如果没有异常发生，在try内的代码执行结束后执行。\n\n- 如果有异常发生且被catch捕获，在catch内的代码执行结束后执行。\n\n- 如果有异常发生但没被捕获，则在异常被抛给上层之前执行。\n\n由于finally的这个特点，它一般用于释放资源，如数据库连接、文件流等。\n\n​    \n\ntry/catch/finall语法中，catch不是必须的，可以只有try/finally。这表示不捕获异常，异常自动向上传递。\n\n\n\n","slug":"异常中的finally","published":1,"updated":"2021-10-27T11:46:51.889Z","_id":"ckv9exhyz00008gui8nz2fuu1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>catch后面可以跟<strong>finally</strong>语句，语法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//可能抛出异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//捕获异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//不管有无异常都执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>finally内的代码不管有无异常发生</strong>，都会执行：</p>\n<ul>\n<li><p>如果没有异常发生，在try内的代码执行结束后执行。</p>\n</li>\n<li><p>如果有异常发生且被catch捕获，在catch内的代码执行结束后执行。</p>\n</li>\n<li><p>如果有异常发生但没被捕获，则在异常被抛给上层之前执行。</p>\n</li>\n</ul>\n<p>由于finally的这个特点，它一般用于释放资源，如数据库连接、文件流等。</p>\n<p>​    </p>\n<p>try/catch/finall语法中，catch不是必须的，可以只有try/finally。这表示不捕获异常，异常自动向上传递。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>catch后面可以跟<strong>finally</strong>语句，语法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//可能抛出异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//捕获异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//不管有无异常都执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>finally内的代码不管有无异常发生</strong>，都会执行：</p>\n<ul>\n<li><p>如果没有异常发生，在try内的代码执行结束后执行。</p>\n</li>\n<li><p>如果有异常发生且被catch捕获，在catch内的代码执行结束后执行。</p>\n</li>\n<li><p>如果有异常发生但没被捕获，则在异常被抛给上层之前执行。</p>\n</li>\n</ul>\n<p>由于finally的这个特点，它一般用于释放资源，如数据库连接、文件流等。</p>\n<p>​    </p>\n<p>try/catch/finall语法中，catch不是必须的，可以只有try/finally。这表示不捕获异常，异常自动向上传递。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cks09lpzv00012wuibu7zcrrm","category_id":"cks0a08qy000030uihje6g1ho","_id":"cks0a08qz000130uiac6a2xal"},{"post_id":"cks09lpzx00032wuignus8w75","category_id":"cks0a1py50002pwuif3yu6wjc","_id":"cks0a1py60003pwui9wmmgufm"},{"post_id":"cks09lpzy00072wui2zot8kay","category_id":"cks0a27e00004pwuic91m9w0b","_id":"cks0a27e00005pwuib5rrhovy"},{"post_id":"cks09lpzx00052wui0r89d0sk","category_id":"cks0a2hip0006pwuiabxrblnm","_id":"cks0a2hip0007pwuiaqmtbuyo"},{"post_id":"cks9zyqbi0000jwui5j9j24rj","category_id":"cks0a192p0000pwui9vseab12","_id":"cks9zyqbn0004jwuiczbpcqlf"},{"post_id":"cks9zyqbl0001jwuid70l7ic2","category_id":"cks0a192p0000pwui9vseab12","_id":"cks9zyqbn0006jwui3tqbg1y4"},{"post_id":"cksg2fmre0000oguieldgcz2c","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog8n1z0000ukui3wdnfwho"},{"post_id":"cksa6jbbo0000zsui1w1k1ld5","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog8qto0001ukui7hgk0bun"},{"post_id":"cksofxgbq0000ksuifs3mcind","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog8tef0002ukui345i51za"},{"post_id":"cksog5rns000008uifraogqoq","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog8vq50003ukui3ou91hwt"},{"post_id":"cksa6jbbs0001zsui2hml9797","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog8ycb0004ukuicm8fcdar"},{"post_id":"cksk9m4970000s0ui6zm8el39","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog90lj0005ukui55qhd7xi"},{"post_id":"cksa6jbbt0003zsuicl9y0ain","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog953z0006ukui5ifz50am"},{"post_id":"ckshdjvb80000nsui582ycseo","category_id":"cks0a192p0000pwui9vseab12","_id":"cksog9bmt0007ukuibbxoa202"},{"post_id":"cksohbobg0000nwui24ycb092","category_id":"cks0a192p0000pwui9vseab12","_id":"cksohbobn0003nwui95lm6f7s"},{"post_id":"cksoitmkm00010wui92yh7e0b","category_id":"cksoitmkn00020wui5opq73cc","_id":"cksoitmks00050wui1qtm7kjz"},{"post_id":"cksu7uhiv00002wui9vbe8g0i","category_id":"cks0a192p0000pwui9vseab12","_id":"cksu7uhj400022wui6esca2dj"},{"post_id":"ckszp1bjb00000guiczys6xp4","category_id":"cks0a192p0000pwui9vseab12","_id":"ckszp1bjf00030guie5i3fq9z"},{"post_id":"ckszv9dew0000kkuiba6ganbd","category_id":"cks0a192p0000pwui9vseab12","_id":"ckszv9df10003kkui8yr3adz8"},{"post_id":"ckt2ckbft0000y0ui9ugbaa2g","category_id":"cks0a192p0000pwui9vseab12","_id":"ckt2ckbfy0003y0ui1pgpg9w2"},{"post_id":"ckt2wa01y0000a0ui3083f1dt","category_id":"cks0a192p0000pwui9vseab12","_id":"ckt2wa0230003a0ui7ilh8bz3"},{"post_id":"ckt3ts0d10000f8uicz2x7fyn","category_id":"cks0a192p0000pwui9vseab12","_id":"ckt3ts0d60003f8ui7hg3h4a4"},{"post_id":"ckt45mpjt0000t0uif9vkfyzv","category_id":"cks0a192p0000pwui9vseab12","_id":"ckt45mpjz0003t0uigwdr3w02"},{"post_id":"cktcss5l40000ncui9n99dtt7","category_id":"cks0a192p0000pwui9vseab12","_id":"cktcss5l80003ncui6q2h22iv"},{"post_id":"cktihggxv000044ui0t2eajcj","category_id":"cks0a192p0000pwui9vseab12","_id":"cktihggxx000344uiepalezaj"},{"post_id":"cktiir3wc0000pkuiemp8b4z6","category_id":"cks0a192p0000pwui9vseab12","_id":"cktiir3wi0003pkuibtzp29qv"},{"post_id":"cktijcmix0000vouiga7eegpd","category_id":"cks0a192p0000pwui9vseab12","_id":"cktjvw2ct000270uignzp8zwa"},{"post_id":"ckto9nscj0000psui5q1y75pl","category_id":"cks0a192p0000pwui9vseab12","_id":"ckto9nscs0003psui4a44ar7m"},{"post_id":"cktpp9ve4000088ui40mj3fog","category_id":"cks0a192p0000pwui9vseab12","_id":"cktpp9vea000388ui575vgn7d"},{"post_id":"cku2dtxbs0000foui7i1i2zcm","category_id":"cks0a192p0000pwui9vseab12","_id":"cku2dtxbw0003foui1kmmf00g"},{"post_id":"cku2f2qcw0000wkui6b8c706h","category_id":"cks0a192p0000pwui9vseab12","_id":"cku2f2qd60002wkui53sxeez0"},{"post_id":"cku3hz0gp0000b4uih4j696yp","category_id":"cks0a192p0000pwui9vseab12","_id":"cku3hz0gt0003b4uidbvk0igq"},{"post_id":"cku3oyo5w0000jsui4qpbcdtx","category_id":"cks0a192p0000pwui9vseab12","_id":"cku3oyo610003jsui0s6v0exg"},{"post_id":"cku3r74m00000v8ui1t5h0xqe","category_id":"cks0a192p0000pwui9vseab12","_id":"cku3r74m50003v8ui5uz575ek"},{"post_id":"cku3tj3m000007guies6icq98","category_id":"cks0a192p0000pwui9vseab12","_id":"cku3tj3m500037guiczwjdx3n"},{"post_id":"cku3vgqxj00008kui0344agcv","category_id":"cks0a192p0000pwui9vseab12","_id":"cku3vgqxn00038kui4q8s52rk"},{"post_id":"cku4wsupr0000asuigaecb7ej","category_id":"cks0a192p0000pwui9vseab12","_id":"cku4wsupv0003asui8iqb4jsx"},{"post_id":"cku6q1yvr0000ooui8gug0p5x","category_id":"cks0a192p0000pwui9vseab12","_id":"cku6q1yw30002ooui4g0y5lif"},{"post_id":"cku6qvr450000f8uial32fseu","category_id":"cks0a192p0000pwui9vseab12","_id":"cku6qvr490002f8ui7di228nn"},{"post_id":"ckunv4b49000080ui2k371hc0","category_id":"cks0a192p0000pwui9vseab12","_id":"ckunv4b4h000380uihsnlbis4"},{"post_id":"ckunvq5yd0000dkui5sfucjs5","category_id":"cks0a192p0000pwui9vseab12","_id":"ckunvq5yi0003dkui5k5t2ioy"},{"post_id":"ckunw8s8o000024ui7tf33904","category_id":"cks0a192p0000pwui9vseab12","_id":"ckunw8s8t000324uigqbd88im"},{"post_id":"ckuo0heyv0000egui6kowbhl0","category_id":"cks0a192p0000pwui9vseab12","_id":"ckuo0hez10003eguigbloaxld"},{"post_id":"ckup5ig2p0000voui07tfan6f","category_id":"cks0a192p0000pwui9vseab12","_id":"ckup5ig330002voui6519fupk"},{"post_id":"ckupakrdx0000b8ui4j04bc6x","category_id":"cks0a192p0000pwui9vseab12","_id":"ckupakre10003b8uifsdfdsuk"},{"post_id":"ckupfn8me0000s8uigbx6blv7","category_id":"cks0a192p0000pwui9vseab12","_id":"ckupfn8mi0003s8ui7738crr9"},{"post_id":"ckuy0l4q40000e8ui19tg4e0x","category_id":"cks0a192p0000pwui9vseab12","_id":"ckuy0l4q80003e8ui1qzahqxz"},{"post_id":"ckv0vu4cp0000xsuifmg060sj","category_id":"cks0a192p0000pwui9vseab12","_id":"ckv0vu4ct0003xsuierot86dp"},{"post_id":"ckv9exhyz00008gui8nz2fuu1","category_id":"cks0a192p0000pwui9vseab12","_id":"ckv9exhz300038guia8qxfr7s"}],"PostTag":[{"post_id":"cks09lpzv00012wuibu7zcrrm","tag_id":"cks09ctlq0000ksui7jff639u","_id":"cks09lpzx00042wui8qvo64dn"},{"post_id":"cks09lpzx00032wuignus8w75","tag_id":"cks09fuz100001kui5fw334yn","_id":"cks09lpzy00062wuia2riblqv"},{"post_id":"cks09lpzx00052wui0r89d0sk","tag_id":"cks09fuz500031kuidji03ek6","_id":"cks09lpzz00082wuicd63dryj"},{"post_id":"cks09lpzy00072wui2zot8kay","tag_id":"cks09fuz400011kui9g2ugiw9","_id":"cks09lpzz00092wuib14j941c"},{"post_id":"cks9zyqbi0000jwui5j9j24rj","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cks9zyqbn0002jwuiczaeheid"},{"post_id":"cks9zyqbl0001jwuid70l7ic2","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cks9zyqbn0003jwuicszl8h3p"},{"post_id":"cks9zyqbl0001jwuid70l7ic2","tag_id":"cks4axw0z0001poui52idfexh","_id":"cks9zyqbn0005jwuihvmo8wde"},{"post_id":"cksa6jbbo0000zsui1w1k1ld5","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksa6jbbt0002zsuih0m9915l"},{"post_id":"cksa6jbbs0001zsui2hml9797","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksa6jbbu0004zsui1lhg0sfu"},{"post_id":"cksa6jbbt0003zsuicl9y0ain","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksa6jbbu0005zsui34xfekpi"},{"post_id":"cksg2fmre0000oguieldgcz2c","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksg2fmrh0001ogui42dy38hk"},{"post_id":"ckshdjvb80000nsui582ycseo","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckshdjvbc0001nsui1eo5gshm"},{"post_id":"cksk9m4970000s0ui6zm8el39","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksk9m49a0001s0ui8kb630e8"},{"post_id":"cksofxgbq0000ksuifs3mcind","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksofxgbx0002ksuif79790a5"},{"post_id":"cksofxgbq0000ksuifs3mcind","tag_id":"cksofxgbu0001ksuia06u7pjz","_id":"cksofxgbx0003ksui33v69g28"},{"post_id":"cksog5rns000008uifraogqoq","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksog5rnt000108ui9aiw0bo6"},{"post_id":"cksog5rns000008uifraogqoq","tag_id":"cksofxgbu0001ksuia06u7pjz","_id":"cksog5rnt000208ui5dy7esc0"},{"post_id":"cksohbobg0000nwui24ycb092","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksohbobn0001nwuidlxjgnkf"},{"post_id":"cksohbobg0000nwui24ycb092","tag_id":"cksofxgbu0001ksuia06u7pjz","_id":"cksohbobn0002nwui3twbf73k"},{"post_id":"cksoitmkm00010wui92yh7e0b","tag_id":"cksoitmkr00030wui51jvf9tx","_id":"cksoitmks00040wuifrfldpqe"},{"post_id":"cksoitmkm00010wui92yh7e0b","tag_id":"cksoiyivx00004cuiazzybt1x","_id":"cksoiyivy00014cuib9122liq"},{"post_id":"cksu7uhiv00002wui9vbe8g0i","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cksu7uhj400032wui2a1x2h5d"},{"post_id":"cksu7uhiv00002wui9vbe8g0i","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cksu7uhj400042wuibhnu8vh7"},{"post_id":"ckszp1bjb00000guiczys6xp4","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckszp1bjf00010gui8h2gha4v"},{"post_id":"ckszp1bjb00000guiczys6xp4","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"ckszp1bjf00020guidt0n24xu"},{"post_id":"ckszv9dew0000kkuiba6ganbd","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckszv9df00001kkui5l1p3n7o"},{"post_id":"ckszv9dew0000kkuiba6ganbd","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"ckszv9df10002kkui4xvshne6"},{"post_id":"ckt2ckbft0000y0ui9ugbaa2g","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckt2ckbfy0001y0uiecl52udz"},{"post_id":"ckt2ckbft0000y0ui9ugbaa2g","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"ckt2ckbfy0002y0ui1gfeh9yy"},{"post_id":"ckt2ckbft0000y0ui9ugbaa2g","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"ckt2r4oxk000160uifzyw1u3h"},{"post_id":"ckszv9dew0000kkuiba6ganbd","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"ckt2r4oxn000360ui9ozgggxa"},{"post_id":"ckt2wa01y0000a0ui3083f1dt","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckt2wa0220001a0uifpzwgj11"},{"post_id":"ckt2wa01y0000a0ui3083f1dt","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"ckt2wa0220002a0ui5qnuggko"},{"post_id":"ckt2wa01y0000a0ui3083f1dt","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"ckt2wa0230004a0uic8v949qr"},{"post_id":"ckt3ts0d10000f8uicz2x7fyn","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckt3ts0d60001f8uifp5358mq"},{"post_id":"ckt3ts0d10000f8uicz2x7fyn","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"ckt3ts0d60002f8ui2tobad12"},{"post_id":"ckt3ts0d10000f8uicz2x7fyn","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"ckt3ts0d60004f8ui1pd08k4k"},{"post_id":"ckt45mpjt0000t0uif9vkfyzv","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckt45mpjz0001t0uidshegvn9"},{"post_id":"ckt45mpjt0000t0uif9vkfyzv","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"ckt45mpjz0002t0ui92kcfy3a"},{"post_id":"ckt45mpjt0000t0uif9vkfyzv","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"ckt45mpjz0004t0ui6rx06tkv"},{"post_id":"cktcss5l40000ncui9n99dtt7","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cktcss5l80001ncui2v560y4y"},{"post_id":"cktcss5l40000ncui9n99dtt7","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cktcss5l80002ncuifhxldpn1"},{"post_id":"cktcss5l40000ncui9n99dtt7","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"cktcss5l90004ncuih8e6ek19"},{"post_id":"cktihggxv000044ui0t2eajcj","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cktihggxw000144ui3r3z95na"},{"post_id":"cktihggxv000044ui0t2eajcj","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cktihggxx000244ui0jjpfd0j"},{"post_id":"cktihggxv000044ui0t2eajcj","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"cktihggxx000444ui5xeqc0hr"},{"post_id":"cktiir3wc0000pkuiemp8b4z6","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cktiir3wi0001pkuifl2efm3w"},{"post_id":"cktiir3wc0000pkuiemp8b4z6","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cktiir3wi0002pkuiccks1urf"},{"post_id":"cktiir3wc0000pkuiemp8b4z6","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"cktiir3wi0004pkuibw8q6xdp"},{"post_id":"cktijcmix0000vouiga7eegpd","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cktjvw2ct000070ui7iev3bc3"},{"post_id":"cktijcmix0000vouiga7eegpd","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cktjvw2ct000170ui191lbi0e"},{"post_id":"cktijcmix0000vouiga7eegpd","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"cktjvw2ct000370uib7rw7brl"},{"post_id":"ckto9nscj0000psui5q1y75pl","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckto9nscs0001psui1onjckdq"},{"post_id":"ckto9nscj0000psui5q1y75pl","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"ckto9nscs0002psui590x7on0"},{"post_id":"ckto9nscj0000psui5q1y75pl","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"ckto9nscs0004psui1r151ncv"},{"post_id":"cktpp9ve4000088ui40mj3fog","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cktpp9ve9000188ui33iv7iiq"},{"post_id":"cktpp9ve4000088ui40mj3fog","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cktpp9vea000288uigsc2609w"},{"post_id":"cktpp9ve4000088ui40mj3fog","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"cktpp9vea000488uifl49c7m7"},{"post_id":"cku2dtxbs0000foui7i1i2zcm","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku2dtxbw0001fouigixcf7w3"},{"post_id":"cku2dtxbs0000foui7i1i2zcm","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku2dtxbw0002fouih1d2cclg"},{"post_id":"cku2dtxbs0000foui7i1i2zcm","tag_id":"ckt2r4oxf000060ui0ass8s4w","_id":"cku2dtxbw0004fouia79j89nh"},{"post_id":"cku2f2qcw0000wkui6b8c706h","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku2f2qd60003wkui0ojgaeen"},{"post_id":"cku2f2qcw0000wkui6b8c706h","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku2f2qd60004wkuihftjbnzu"},{"post_id":"cku2f2qcw0000wkui6b8c706h","tag_id":"cku2f2qd00001wkui5noe9qn3","_id":"cku2f2qd70005wkui3fkbebzf"},{"post_id":"cku3hz0gp0000b4uih4j696yp","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku3hz0gt0001b4uibzlg6w4t"},{"post_id":"cku3hz0gp0000b4uih4j696yp","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku3hz0gt0002b4uib4pz5vu9"},{"post_id":"cku3hz0gp0000b4uih4j696yp","tag_id":"cku2f2qd00001wkui5noe9qn3","_id":"cku3hz0gt0004b4ui4qyuaszu"},{"post_id":"cku3oyo5w0000jsui4qpbcdtx","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku3oyo610001jsuihdcv4kgo"},{"post_id":"cku3oyo5w0000jsui4qpbcdtx","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku3oyo610002jsuia5wffyca"},{"post_id":"cku3oyo5w0000jsui4qpbcdtx","tag_id":"cku2f2qd00001wkui5noe9qn3","_id":"cku3oyo610004jsuigd3vet3b"},{"post_id":"cku3r74m00000v8ui1t5h0xqe","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku3r74m40001v8uid6zqfjn4"},{"post_id":"cku3r74m00000v8ui1t5h0xqe","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku3r74m50002v8uignav736c"},{"post_id":"cku3r74m00000v8ui1t5h0xqe","tag_id":"cku2f2qd00001wkui5noe9qn3","_id":"cku3r74m50004v8uig1jdbryp"},{"post_id":"cku3tj3m000007guies6icq98","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku3tj3m500017gui0wttg6cr"},{"post_id":"cku3tj3m000007guies6icq98","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku3tj3m500027gui539n4a4v"},{"post_id":"cku3tj3m000007guies6icq98","tag_id":"cku3thnkk0001x0ui5ictgcng","_id":"cku3tj3m500047guib8tzb79w"},{"post_id":"cku3vgqxj00008kui0344agcv","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku3vgqxn00018kui8pox6sj8"},{"post_id":"cku3vgqxj00008kui0344agcv","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku3vgqxn00028kui3pajc26u"},{"post_id":"cku3vgqxj00008kui0344agcv","tag_id":"cku3thnkk0001x0ui5ictgcng","_id":"cku3vgqxn00048kuieu938axb"},{"post_id":"cku3vgqxj00008kui0344agcv","tag_id":"cku2f2qd00001wkui5noe9qn3","_id":"cku3vgqxn00058kuia0if1d77"},{"post_id":"cku4wsupr0000asuigaecb7ej","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku4wsupv0001asuie3bp6itd"},{"post_id":"cku4wsupr0000asuigaecb7ej","tag_id":"cksu7uhiz00012wuidztl6x2d","_id":"cku4wsupv0002asui9roo2dv7"},{"post_id":"cku6q1yvr0000ooui8gug0p5x","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku6q1yw40003oouibx6u8o7p"},{"post_id":"cku6q1yvr0000ooui8gug0p5x","tag_id":"cku6q1yvv0001ooui8mma3czh","_id":"cku6q1yw40004oouig3wd7izk"},{"post_id":"cku6qvr450000f8uial32fseu","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"cku6qvr490001f8uieqcw2rwk"},{"post_id":"ckunv4b49000080ui2k371hc0","tag_id":"cku6se71q0001xwui1krbc1zl","_id":"ckunv4b4g000180ui1zfpgkw6"},{"post_id":"ckunv4b49000080ui2k371hc0","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckunv4b4h000280uicmwm8a73"},{"post_id":"ckunvq5yd0000dkui5sfucjs5","tag_id":"cku6se71q0001xwui1krbc1zl","_id":"ckunvq5yh0001dkuidxrw1xwz"},{"post_id":"ckunvq5yd0000dkui5sfucjs5","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckunvq5yi0002dkuiep0a1a96"},{"post_id":"ckunw8s8o000024ui7tf33904","tag_id":"cku6se71q0001xwui1krbc1zl","_id":"ckunw8s8t000124ui9udrbdq5"},{"post_id":"ckunw8s8o000024ui7tf33904","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckunw8s8t000224ui4kh0aef0"},{"post_id":"ckuo0heyv0000egui6kowbhl0","tag_id":"cku6se71q0001xwui1krbc1zl","_id":"ckuo0hez10001egui4dwz74hq"},{"post_id":"ckuo0heyv0000egui6kowbhl0","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckuo0hez10002eguihtwc2o9r"},{"post_id":"ckup5ig2p0000voui07tfan6f","tag_id":"ckup5ig2u0001voui9vcv55vw","_id":"ckup5ig330003voui9rfu8mym"},{"post_id":"ckup5ig2p0000voui07tfan6f","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckup5ig330004voui2rz4ftr8"},{"post_id":"ckupakrdx0000b8ui4j04bc6x","tag_id":"ckup5ig2u0001voui9vcv55vw","_id":"ckupakre10001b8ui1fzgbe2a"},{"post_id":"ckupakrdx0000b8ui4j04bc6x","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckupakre10002b8uif4y28oyf"},{"post_id":"ckupfn8me0000s8uigbx6blv7","tag_id":"ckup5ig2u0001voui9vcv55vw","_id":"ckupfn8mi0001s8ui5hwr2zhy"},{"post_id":"ckupfn8me0000s8uigbx6blv7","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckupfn8mi0002s8uidedbhj27"},{"post_id":"ckuy0l4q40000e8ui19tg4e0x","tag_id":"ckup5ig2u0001voui9vcv55vw","_id":"ckuy0l4q80001e8ui0yw6hv16"},{"post_id":"ckuy0l4q40000e8ui19tg4e0x","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckuy0l4q80002e8ui33lrcx57"},{"post_id":"ckv0vu4cp0000xsuifmg060sj","tag_id":"ckup5ig2u0001voui9vcv55vw","_id":"ckv0vu4ct0001xsuiehlhcvyk"},{"post_id":"ckv0vu4cp0000xsuifmg060sj","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckv0vu4ct0002xsui9y577pij"},{"post_id":"ckv9exhyz00008gui8nz2fuu1","tag_id":"ckup5ig2u0001voui9vcv55vw","_id":"ckv9exhz300018guigmlp4sxh"},{"post_id":"ckv9exhyz00008gui8nz2fuu1","tag_id":"cks09ctls0001ksui80p3hv3t","_id":"ckv9exhz300028gui0jpebv1p"}],"Tag":[{"name":"algorithm","_id":"cks09ctlq0000ksui7jff639u"},{"name":"java","_id":"cks09ctls0001ksui80p3hv3t"},{"name":"network","_id":"cks09fuz100001kui5fw334yn"},{"name":"pet","_id":"cks09fuz400011kui9g2ugiw9"},{"name":"travel","_id":"cks09fuz500031kuidji03ek6"},{"name":"array","_id":"cks4axw0z0001poui52idfexh"},{"name":"function","_id":"cksofxgbu0001ksuia06u7pjz"},{"name":"stack","_id":"cksoitmkr00030wui51jvf9tx"},{"name":"data structure","_id":"cksoiyivx00004cuiazzybt1x"},{"name":"class","_id":"cksu7uhiz00012wuidztl6x2d"},{"name":"extends","_id":"ckt2r4oxf000060ui0ass8s4w"},{"name":"interface","_id":"cku2f2qd00001wkui5noe9qn3"},{"name":"abstract","_id":"cku3thnkk0001x0ui5ictgcng"},{"name":"package","_id":"cku6q1yvv0001ooui8mma3czh"},{"name":"enum","_id":"cku6se71q0001xwui1krbc1zl"},{"name":"exception","_id":"ckup5ig2u0001voui9vcv55vw"}]}}