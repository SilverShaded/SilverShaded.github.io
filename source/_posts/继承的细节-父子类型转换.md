---
title: 继承的细节--父子类型转换
date: 2021-09-03 12:00:31
tags:
 - java
 - class
 - extends
categories: java
---

继承和多态概念还有一些相关的细节，具体包括：

- 构造方法  
- 重名与静态绑定 
- 重载和重写
- 父子类型转换 <font color=blue>now!</font>
- 继承访问权限（protected）
- 可见性重写
- 防止继承（final）

​    

根据《从图形处理类看继承和多态》一章可知，子类型的对象可以赋值给父类型的引用变量。

但父类型的变量不一定能成功赋值给子类型的变量，**向下转型**不一定成功。

栗子如下：

```java
Base base = new Child();
Child child = (Child)base;
```

Child child = (Child)base就是将变量base的类型强制转换为Child并赋值为child。
因为base的动态类型就是child，所以向下转型没问题。

```java
Base base = new Base();
Child child = (Child)base;
```

上面代码，在运行时会抛出错误，错误为类型转换异常。

​    

**一个父类的变量，能否转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。**

​    

给定一个父类的变量，通过**instanceof**关键字，能知道它到底是不是某个子类的对象，从而安全的进行类型转换。

```java
public static boolean canCast(Base b) {
   return b instanceof Child; 
}
```

canCast函数返回Base类型变量b是否可以转换为Child类型。

instanceof前面是变量，后面是类，返回值为true时表示变量引用的对象是该类或其子类的对象，false则反之。



