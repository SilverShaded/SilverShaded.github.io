---
title: 继承的细节--重载和重写
date: 2021-09-02 20:19:31
tags:
 - java
 - class
 - extends
categories: java
---

继承和多态概念还有一些相关的细节，具体包括：

- 构造方法  

- 重名与静态绑定

- 重载和重写 <font color=blue>now!</font>

- 父子类型转换

- 继承访问权限（protected）

- 可见性重写

- 防止继承（final）

​    

**重载和重写**

重载=方法名称相同，但参数签名不同（参数个数或类型或顺序不同）。

重写= 子类重写父类相同参数签名的方法。

​    

举一个栗子，父类代码如下：

```java
public class Base {
    public int sum(int a,int b) {
        System.out.println("base_int_int");
        return a+b;
    }
}
```

父类定义了sum(int a,int b)方法。

子类代码如下：

```java
public class Child extends Base{
   public long sum(long a,long b) {
       System.out.println("child_long_long");
       return a+b;
   }
}
```

子类定义了sum(long a,long b)方法。

​    

调用代码如下：

```java
public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        int a = 2;
        int b = 3;
        child.sum(a,b);
    }
}
```

虽然每个sum方法都是兼容的，int类型可以自动转型为long，当只有一个方法的时候，那个方法就会被调用。

但现在有多个方法可用，子类的sum方法参数类型虽然兼容但是不完全匹配，而父类的sum方法参数类型是完全匹配的。

所以父类的sum方法被调用了，输出结果为：

```java
base_int_int
```

​    

如果父类将其中一个int参数改为long参数，代码如下：

```java
public class Base {
    public long sum(int a,long b) {
        System.out.println("base_int_long");
        return a+b;
    }
}
```

再运行程序，调用的依然是父类的sum函数，代码如下：

```java
base_int_long
```

虽然子类和父类的两个方法的参数类型都不完全匹配，但是相比之下，还是父类的sum方法更匹配一些，至少有一个int参数。

​    

现在修改一下子类代码，让它的参数类型和父类一致：

```java
public class Main {
    public static void main(String[] args) {
        Base base = new Child();//静态类型是Base，动态类型是Child
        int a = 2;
        int b = 3;
        base.sum(a,b);
    }
}
```

输出结果为：

```java
child_int_long
```

说明这一回调用的是子类的sum函数。

​    

从上面的这些栗子中，我们可以得知——**当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的。换句话说，寻找在所有重载函数中最匹配的。然后才看变量的动态类型，进行动态绑定。**



